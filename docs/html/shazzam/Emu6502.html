<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>shazzam.Emu6502 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>shazzam.Emu6502</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
from io import BytesIO
import traceback
from enum import Enum, auto
from typing import List

import cooked_input as ci
from cooked_input import GetInputCommand, GetInputInterrupt, CommandResponse, COMMAND_ACTION_NOP, COMMAND_ACTION_CANCEL, COMMAND_ACTION_USE_VALUE

from py65emu.cpu import CPU
from py65emu.mmu import MMU

from shazzam.Instruction import Instruction

class Action(Enum):
    READ_MEMORY = auto()
    READ_REGISTERS = auto()
    EXIT = auto()
    RUN_NEXT = auto()
    SHOW_INSTRUCTION = auto()
    SHOW_CYCLES_COUNT = auto()
    SET_BREAKPOINT = auto()
    CLEAR_BREAKPOINT = auto()

class Emu6502():

    def __init__(self):
        self.logger = logging.getLogger(&#34;shazzam&#34;)
        self.breakpoints = []
        self.mmu = None
        self.cpu = None
        self.debug_mode = False
        self.breakpoint_in = -1
        self.nb_cycles_used = 0

    def reset_breakpoint(self, address : int):
        &#34;&#34;&#34;[summary]

        Args:
            address (int): [description]

        Raises:
            ValueError: [description]
        &#34;&#34;&#34;
        if isinstance(address, int) and address in range(0, 0xffff):
            if address not in self.breakpoints:
                self.breakpoints.append(address)
            else:
                self.breakpoints.remove(address)
        else:
            raise ValueError(f&#34;Invalid breakpoint {address}&#34;)

    def clear_beakpoints(self):
        &#34;&#34;&#34;Clear all breakpoints&#34;&#34;&#34;
        self.breakpoints = []
        self.logger.debug(&#34;All breakpoints are removed&#34;)

    def load_and_run(self, segments: List, entry_address: int, stop_address: int = None, cycles_count_start: int = None, cycles_count_end: int = None, debug_mode: bool = False) -&gt; (CPU, MMU, int):
        &#34;&#34;&#34;[summary]

        Args:
            segments (List[Segment]): [description]
            entry_address (int): [description]
            cycles_count_start (int, optional): [description]. Defaults to None.
            cycles_count_end (int, optional): [description]. Defaults to None.
            debug_mode (bool, optional): [description]. Defaults to False.

        Returns:
            CPU, MMU, int: [description]
        &#34;&#34;&#34;
        low_ram = (0x0000, segments[0].start_adr, False)
        hi_ram = (segments[-1].end_adr, 0xffff, False)

        mmu_segments = []

        mmu_segments.append(low_ram)
        for seg in segments:
            bytecode = BytesIO(seg.get_segment_bytecode())
            mmu_s = (seg.start_adr, seg.end_adr - seg.start_adr, False, bytecode)
            mmu_segments.append(mmu_s)
        mmu_segments.append(hi_ram)

        self.logger.info(mmu_segments)
        self.debug_mode = debug_mode

        self.mmu = MMU(mmu_segments)
        self.cpu = CPU(self.mmu, entry_address)

        counting_enabled = False if cycles_count_start is not None else True
        stop_address = 0xffff if stop_address is None else stop_address

        self.logger.info(f&#34;Loading code from {segments[0].start_adr:04X} to {segments[-1].end_adr:04X}&#34;)
        self.logger.debug(f&#34;Set PC at {entry_address:04X}&#34;)
        self.logger.debug(f&#34;Emulating from ${self.cpu.r.pc:04X} to ${stop_address:04X}&#34;)

        self.nb_cycles_used = 0
        current_bytecode = self.mmu.read(self.cpu.r.pc)
        current_instruction = Instruction.opcodes[current_bytecode]
        current_operand_size = Instruction.operand_sizes[current_instruction[1]]+1
        current_operand = [self.mmu.read(self.cpu.r.pc + 1 + i) for i in range(current_operand_size)]

        while(self.cpu.r.pc &lt; stop_address and current_instruction[0] != &#39;brk&#39;):
            try:
                if self.cpu.r.pc == cycles_count_start:
                    counting_enabled = True
                    self.logger.info(f&#34;Starting to count cycle at ${self.cpu.r.pc:04X}&#34;)
                if self.cpu.r.pc == cycles_count_end:
                    counting_enabled = False
                    self.logger.info(f&#34;Stopping to count cycle at ${self.cpu.r.pc:04X}&#34;)

                current_bytecode = self.mmu.read(self.cpu.r.pc)
                current_instruction = Instruction.opcodes[current_bytecode]
                current_operand_size = Instruction.operand_sizes[current_instruction[1]]+1
                current_operand = [self.mmu.read(self.cpu.r.pc+1+i) for i in range(current_operand_size)]

                if counting_enabled:
                    self.nb_cycles_used += self.cpu.cc

                if self.debug_mode or self.cpu.r.pc in self.breakpoints or self.breakpoint_in == 0:
                    print(f&#34;${self.cpu.r.pc:04X}: {current_instruction[0]} [{current_instruction[1]}] (${int.from_bytes(current_operand, &#39;big&#39;):02X})&#34;)
                    print(f&#34;{self.cpu.r}&#34;)
                    if self.breakpoints:
                        print(f&#34;Breakpoints: {[f&#39;${bp:04X}&#39; for bp in self.breakpoints]}&#34;)

                    inputs = self.get_input(f&#34;${self.cpu.r.pc:04X}&#34;)
                    if inputs:
                        self.process_input(inputs, current_instruction, int.from_bytes(current_operand, &#39;big&#39;), cycles_count_start)
                    else:
                        self.debug_mode = False
                else:
                    if counting_enabled and self.nb_cycles_used % 1000 == 0:
                        self.logger.info(f&#34;Total: {self.nb_cycles_used} R: {self.cpu.r} CC: {self.cpu.cc}&#34;)

                    self.cpu.step()

                    if self.breakpoint_in &gt; 0:
                        self.breakpoint_in -= 1

            except Exception as e:
                self.logger.critical(f&#34;Emulation crashed at ${self.cpu.r.pc:04X} (bytecode {current_bytecode:02X}) due to {e.__class__}&#34;)
                self.logger.critical(f&#34;{current_instruction} operand: {int.from_bytes(current_operand, &#39;big&#39;):02X}&#34;)
                self.logger.critical(f&#34;Registers: {self.cpu.r}&#34;)
                self.logger.critical(traceback.format_exc())
                break

        self.logger.info(f&#34;Emulation stopped at ${self.cpu.r.pc:04X} with last instruction executed: {current_instruction[0]}&#34;)

        return self.cpu, self.mmu, self.nb_cycles_used

    def process_input(self, inputs, inst, operand, nb_cycles_start):
        &#34;&#34;&#34;[summary]

        Args:
            inputs ([type]): [description]
            inst ([type]): [description]
            operand ([type]): [description]
            nb_cycles_start ([type]): [description]
        &#34;&#34;&#34;
        if inputs[&#39;cmd&#39;] == Action.READ_MEMORY:
            vals = [int(x) for x in inputs[&#39;args&#39;]]

            if len(vals) == 1:
                print(f&#34;${vals[0]:04X}: {self.mmu.read(vals[0])}&#34;)
            else:
                delta = vals[1] - vals[0] + 1
                if delta &lt; 1:
                    print(f&#34;-&gt; Memory range cannot be null or negative: ${delta:04X} = ${vals[1]:04X} - ${vals[0]:04X}&#34;)
                else:
                    modulo = 1 if delta % 16 != 0 else 0

                    for i in range((delta // 16) + modulo):
                        print(f&#34;${vals[0]+(i*16):04X}: &#34;, end= &#39;&#39;)
                        for j in range(min(16, delta - (i*16))):
                            print(f&#34;{self.mmu.read(vals[0]):02X}&#34;, end = &#39; &#39;)
                        print()

        elif inputs[&#39;cmd&#39;] == Action.READ_REGISTERS:
            if len(inputs[&#39;args&#39;]) == 0:
                print(f&#34;Registers: {self.cpu.r}&#34;)
            else:
                for r in inputs[&#39;args&#39;]:
                    print(f&#34;Register {r}: {eval(f&#39;self.cpu.r.{r.lower()}&#39;)} | ${eval(f&#39;self.cpu.r.{r.lower()}&#39;):0X} | %{eval(f&#39;self.cpu.r.{r.lower()}&#39;):0b}&#34;)

        elif inputs[&#39;cmd&#39;] == Action.RUN_NEXT:
            if len(inputs[&#39;args&#39;]) == 0:
                self.cpu.step()
            else:
                self.debug_mode = False
                self.breakpoint_in = int(inputs[&#39;args&#39;][0])
                print(f&#34;-&gt; Program will stop in {self.breakpoint_in} instructions&#34;)

        elif inputs[&#39;cmd&#39;] == Action.SHOW_INSTRUCTION:
            print(f&#34;${self.cpu.r.pc:04X}: {&#39; &#39;.join(inst)} {operand:02X}&#34;)

        elif inputs[&#39;cmd&#39;] == Action.SHOW_CYCLES_COUNT:
            if nb_cycles_start:
                print(f&#34;${self.cpu.r.pc:04X}: {self.nb_cycles_used} cycles used since ${nb_cycles_start:04X}&#34;)
            else:
                print(f&#34;${self.cpu.r.pc:04X}: {self.nb_cycles_used} cycles used&#34;)

        elif inputs[&#39;cmd&#39;] == Action.SET_BREAKPOINT:
            if inputs[&#39;args&#39;]:
                for bp in [int(v) for v in inputs[&#39;args&#39;]]:
                    self.reset_breakpoint(bp)
                    print(f&#34;-&gt; Breakpoint added at ${bp:04X}&#34;)
            else:
                print(f&#34;-&gt; Breakpoints {[f&#39;${bp:04X}&#39; for bp in self.breakpoints]} cleared&#34;)
                self.clear_beakpoints()

        else:
            self.logger.warning(f&#34;-&gt; Debugger input {inputs} not managed!&#34;)

    def get_input(self, prompt: str):

        def memory_action(cmd_str, cmd_vars, cmd_dict):
            list_loc = cmd_vars.split(&#39; &#39;)
            addresses = []

            if len(list_loc) &gt; 2:
                raise ValueError(&#34;too many addresses, should be one or a range&#34;)

            for loc in list_loc:
                addresses.append(self._parse_string_address(loc))

            res = f&#34;!{Action.READ_MEMORY} {&#39; &#39;.join(addresses)}&#34;
            return (COMMAND_ACTION_USE_VALUE, res)

        def registers_action(cmd_str, cmd_vars, cmd_dict):
            if cmd_vars:
                list_reg = [reg.upper() for reg in cmd_vars.split(&#39; &#39;)]
                for reg in list_reg:
                    if reg not in [&#39;A&#39;, &#39;Y&#39;, &#39;X&#39;, &#39;P&#39;, &#39;S&#39;, &#39;PC&#39;]:
                        raise ValueError(f&#34;Unknown register {reg}&#34;)

                res = f&#34;!{Action.READ_REGISTERS} {&#39; &#39;.join(list_reg)}&#34;
                return (COMMAND_ACTION_USE_VALUE, res)
            else:
                res = f&#34;!{Action.READ_REGISTERS}&#34;
                return (COMMAND_ACTION_USE_VALUE, res)

        def next_action(cmd_str, cmd_vars, cmd_dict):
            if cmd_vars:
                cmd_vars = int(cmd_vars, 0)

            res = f&#34;!{Action.RUN_NEXT} {cmd_vars}&#34;
            return (COMMAND_ACTION_USE_VALUE, res)

        def instruction_action(cmd_str, cmd_vars, cmd_dict):
            res = f&#34;!{Action.SHOW_INSTRUCTION}&#34;
            return (COMMAND_ACTION_USE_VALUE, res)

        def cycles_action(cmd_str, cmd_vars, cmd_dict):
            if cmd_vars:
                try:
                    nb = int(cmd_vars)
                except:
                    raise ValueError(&#34;Invalid number of instructions&#34;)
                res = f&#34;!{Action.SHOW_CYCLES_COUNT} {cmd_vars}&#34;
            else:
                res = f&#34;!{Action.SHOW_CYCLES_COUNT}&#34;

            return (COMMAND_ACTION_USE_VALUE, res)

        def breakpoint_action(cmd_str, cmd_vars, cmd_dict):
            if cmd_vars:
                list_loc = cmd_vars.split(&#39; &#39;)
                adresses = []
                for loc in list_loc:
                    adresses.append(self._parse_string_address(loc))

                res = f&#34;!{Action.SET_BREAKPOINT} {&#39; &#39;.join(adresses)}&#34;
                return (COMMAND_ACTION_USE_VALUE, res)
            else:
                res = f&#34;!{Action.SET_BREAKPOINT}&#34;
                return (COMMAND_ACTION_USE_VALUE, res)


        def cancel_action(cmd_str, cmd_vars, cmd_dict):
            return (COMMAND_ACTION_CANCEL, None)

        def show_help_action(cmd_str, cmd_vars, cmd_dict):
            print(&#39;Available commands:&#39;)
            print(&#39;? - show this message&#39;)
            print(&#39;e - exit simulator&#39;)
            print(&#39;n [nb]- run next nb instructions&#39;)
            print(&#39;m - show memory&#39;)
            print(&#39;r - show registers&#39;)
            print(&#39;i - show instruction&#39;)
            print(&#39;c - show cycles count&#39;)
            print(&#39;b - set/reset/clear breakpoints&#39;)

            return CommandResponse(COMMAND_ACTION_NOP, None)

        cmds = {
            &#39;?&#39;: GetInputCommand(show_help_action),
            &#39;e&#39;: GetInputCommand(cancel_action),
            &#39;n&#39;: GetInputCommand(next_action),
            &#39;m&#39;: GetInputCommand(memory_action),
            &#39;r&#39;: GetInputCommand(registers_action),
            &#39;i&#39;: GetInputCommand(instruction_action),
            &#39;c&#39;: GetInputCommand(cycles_action),
            &#39;b&#39;: GetInputCommand(breakpoint_action),
        }

        while True:
            try:
                result = ci.get_string(prompt=prompt, commands=cmds)

                if result[0] == &#39;!&#39;:

                    res = result[1:].split(&#39; &#39;)
                    return {
                         &#34;cmd&#34;: eval(res[0]),
                         &#34;args&#34;: res[1:]
                    }
                else:
                    print(f&#34;Unknown command {result}, enter ? for help&#34;)
            except ValueError as e:
                print(f&#34;Bad format: {e}&#34;)
            except GetInputInterrupt:
                break

    def _parse_string_address(self, adr_string: str) -&gt; str:
        try:
            if &#34;$&#34; in adr_string:
                val = str(int(adr_string[1:], 16))
            elif &#34;0x&#34; in adr_string:
                val = str(int(adr_string[2:], 16))
            else:
                val = str(int(adr_string))
        except Exception as e:
            raise ValueError(f&#34;Cannot convert {adr_string} into address due to: {e}&#34;)

        return val</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="shazzam.Emu6502.Action"><code class="flex name class">
<span>class <span class="ident">Action</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Action(Enum):
    READ_MEMORY = auto()
    READ_REGISTERS = auto()
    EXIT = auto()
    RUN_NEXT = auto()
    SHOW_INSTRUCTION = auto()
    SHOW_CYCLES_COUNT = auto()
    SET_BREAKPOINT = auto()
    CLEAR_BREAKPOINT = auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="shazzam.Emu6502.Action.CLEAR_BREAKPOINT"><code class="name">var <span class="ident">CLEAR_BREAKPOINT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Emu6502.Action.EXIT"><code class="name">var <span class="ident">EXIT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Emu6502.Action.READ_MEMORY"><code class="name">var <span class="ident">READ_MEMORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Emu6502.Action.READ_REGISTERS"><code class="name">var <span class="ident">READ_REGISTERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Emu6502.Action.RUN_NEXT"><code class="name">var <span class="ident">RUN_NEXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Emu6502.Action.SET_BREAKPOINT"><code class="name">var <span class="ident">SET_BREAKPOINT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Emu6502.Action.SHOW_CYCLES_COUNT"><code class="name">var <span class="ident">SHOW_CYCLES_COUNT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Emu6502.Action.SHOW_INSTRUCTION"><code class="name">var <span class="ident">SHOW_INSTRUCTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="shazzam.Emu6502.Emu6502"><code class="flex name class">
<span>class <span class="ident">Emu6502</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Emu6502():

    def __init__(self):
        self.logger = logging.getLogger(&#34;shazzam&#34;)
        self.breakpoints = []
        self.mmu = None
        self.cpu = None
        self.debug_mode = False
        self.breakpoint_in = -1
        self.nb_cycles_used = 0

    def reset_breakpoint(self, address : int):
        &#34;&#34;&#34;[summary]

        Args:
            address (int): [description]

        Raises:
            ValueError: [description]
        &#34;&#34;&#34;
        if isinstance(address, int) and address in range(0, 0xffff):
            if address not in self.breakpoints:
                self.breakpoints.append(address)
            else:
                self.breakpoints.remove(address)
        else:
            raise ValueError(f&#34;Invalid breakpoint {address}&#34;)

    def clear_beakpoints(self):
        &#34;&#34;&#34;Clear all breakpoints&#34;&#34;&#34;
        self.breakpoints = []
        self.logger.debug(&#34;All breakpoints are removed&#34;)

    def load_and_run(self, segments: List, entry_address: int, stop_address: int = None, cycles_count_start: int = None, cycles_count_end: int = None, debug_mode: bool = False) -&gt; (CPU, MMU, int):
        &#34;&#34;&#34;[summary]

        Args:
            segments (List[Segment]): [description]
            entry_address (int): [description]
            cycles_count_start (int, optional): [description]. Defaults to None.
            cycles_count_end (int, optional): [description]. Defaults to None.
            debug_mode (bool, optional): [description]. Defaults to False.

        Returns:
            CPU, MMU, int: [description]
        &#34;&#34;&#34;
        low_ram = (0x0000, segments[0].start_adr, False)
        hi_ram = (segments[-1].end_adr, 0xffff, False)

        mmu_segments = []

        mmu_segments.append(low_ram)
        for seg in segments:
            bytecode = BytesIO(seg.get_segment_bytecode())
            mmu_s = (seg.start_adr, seg.end_adr - seg.start_adr, False, bytecode)
            mmu_segments.append(mmu_s)
        mmu_segments.append(hi_ram)

        self.logger.info(mmu_segments)
        self.debug_mode = debug_mode

        self.mmu = MMU(mmu_segments)
        self.cpu = CPU(self.mmu, entry_address)

        counting_enabled = False if cycles_count_start is not None else True
        stop_address = 0xffff if stop_address is None else stop_address

        self.logger.info(f&#34;Loading code from {segments[0].start_adr:04X} to {segments[-1].end_adr:04X}&#34;)
        self.logger.debug(f&#34;Set PC at {entry_address:04X}&#34;)
        self.logger.debug(f&#34;Emulating from ${self.cpu.r.pc:04X} to ${stop_address:04X}&#34;)

        self.nb_cycles_used = 0
        current_bytecode = self.mmu.read(self.cpu.r.pc)
        current_instruction = Instruction.opcodes[current_bytecode]
        current_operand_size = Instruction.operand_sizes[current_instruction[1]]+1
        current_operand = [self.mmu.read(self.cpu.r.pc + 1 + i) for i in range(current_operand_size)]

        while(self.cpu.r.pc &lt; stop_address and current_instruction[0] != &#39;brk&#39;):
            try:
                if self.cpu.r.pc == cycles_count_start:
                    counting_enabled = True
                    self.logger.info(f&#34;Starting to count cycle at ${self.cpu.r.pc:04X}&#34;)
                if self.cpu.r.pc == cycles_count_end:
                    counting_enabled = False
                    self.logger.info(f&#34;Stopping to count cycle at ${self.cpu.r.pc:04X}&#34;)

                current_bytecode = self.mmu.read(self.cpu.r.pc)
                current_instruction = Instruction.opcodes[current_bytecode]
                current_operand_size = Instruction.operand_sizes[current_instruction[1]]+1
                current_operand = [self.mmu.read(self.cpu.r.pc+1+i) for i in range(current_operand_size)]

                if counting_enabled:
                    self.nb_cycles_used += self.cpu.cc

                if self.debug_mode or self.cpu.r.pc in self.breakpoints or self.breakpoint_in == 0:
                    print(f&#34;${self.cpu.r.pc:04X}: {current_instruction[0]} [{current_instruction[1]}] (${int.from_bytes(current_operand, &#39;big&#39;):02X})&#34;)
                    print(f&#34;{self.cpu.r}&#34;)
                    if self.breakpoints:
                        print(f&#34;Breakpoints: {[f&#39;${bp:04X}&#39; for bp in self.breakpoints]}&#34;)

                    inputs = self.get_input(f&#34;${self.cpu.r.pc:04X}&#34;)
                    if inputs:
                        self.process_input(inputs, current_instruction, int.from_bytes(current_operand, &#39;big&#39;), cycles_count_start)
                    else:
                        self.debug_mode = False
                else:
                    if counting_enabled and self.nb_cycles_used % 1000 == 0:
                        self.logger.info(f&#34;Total: {self.nb_cycles_used} R: {self.cpu.r} CC: {self.cpu.cc}&#34;)

                    self.cpu.step()

                    if self.breakpoint_in &gt; 0:
                        self.breakpoint_in -= 1

            except Exception as e:
                self.logger.critical(f&#34;Emulation crashed at ${self.cpu.r.pc:04X} (bytecode {current_bytecode:02X}) due to {e.__class__}&#34;)
                self.logger.critical(f&#34;{current_instruction} operand: {int.from_bytes(current_operand, &#39;big&#39;):02X}&#34;)
                self.logger.critical(f&#34;Registers: {self.cpu.r}&#34;)
                self.logger.critical(traceback.format_exc())
                break

        self.logger.info(f&#34;Emulation stopped at ${self.cpu.r.pc:04X} with last instruction executed: {current_instruction[0]}&#34;)

        return self.cpu, self.mmu, self.nb_cycles_used

    def process_input(self, inputs, inst, operand, nb_cycles_start):
        &#34;&#34;&#34;[summary]

        Args:
            inputs ([type]): [description]
            inst ([type]): [description]
            operand ([type]): [description]
            nb_cycles_start ([type]): [description]
        &#34;&#34;&#34;
        if inputs[&#39;cmd&#39;] == Action.READ_MEMORY:
            vals = [int(x) for x in inputs[&#39;args&#39;]]

            if len(vals) == 1:
                print(f&#34;${vals[0]:04X}: {self.mmu.read(vals[0])}&#34;)
            else:
                delta = vals[1] - vals[0] + 1
                if delta &lt; 1:
                    print(f&#34;-&gt; Memory range cannot be null or negative: ${delta:04X} = ${vals[1]:04X} - ${vals[0]:04X}&#34;)
                else:
                    modulo = 1 if delta % 16 != 0 else 0

                    for i in range((delta // 16) + modulo):
                        print(f&#34;${vals[0]+(i*16):04X}: &#34;, end= &#39;&#39;)
                        for j in range(min(16, delta - (i*16))):
                            print(f&#34;{self.mmu.read(vals[0]):02X}&#34;, end = &#39; &#39;)
                        print()

        elif inputs[&#39;cmd&#39;] == Action.READ_REGISTERS:
            if len(inputs[&#39;args&#39;]) == 0:
                print(f&#34;Registers: {self.cpu.r}&#34;)
            else:
                for r in inputs[&#39;args&#39;]:
                    print(f&#34;Register {r}: {eval(f&#39;self.cpu.r.{r.lower()}&#39;)} | ${eval(f&#39;self.cpu.r.{r.lower()}&#39;):0X} | %{eval(f&#39;self.cpu.r.{r.lower()}&#39;):0b}&#34;)

        elif inputs[&#39;cmd&#39;] == Action.RUN_NEXT:
            if len(inputs[&#39;args&#39;]) == 0:
                self.cpu.step()
            else:
                self.debug_mode = False
                self.breakpoint_in = int(inputs[&#39;args&#39;][0])
                print(f&#34;-&gt; Program will stop in {self.breakpoint_in} instructions&#34;)

        elif inputs[&#39;cmd&#39;] == Action.SHOW_INSTRUCTION:
            print(f&#34;${self.cpu.r.pc:04X}: {&#39; &#39;.join(inst)} {operand:02X}&#34;)

        elif inputs[&#39;cmd&#39;] == Action.SHOW_CYCLES_COUNT:
            if nb_cycles_start:
                print(f&#34;${self.cpu.r.pc:04X}: {self.nb_cycles_used} cycles used since ${nb_cycles_start:04X}&#34;)
            else:
                print(f&#34;${self.cpu.r.pc:04X}: {self.nb_cycles_used} cycles used&#34;)

        elif inputs[&#39;cmd&#39;] == Action.SET_BREAKPOINT:
            if inputs[&#39;args&#39;]:
                for bp in [int(v) for v in inputs[&#39;args&#39;]]:
                    self.reset_breakpoint(bp)
                    print(f&#34;-&gt; Breakpoint added at ${bp:04X}&#34;)
            else:
                print(f&#34;-&gt; Breakpoints {[f&#39;${bp:04X}&#39; for bp in self.breakpoints]} cleared&#34;)
                self.clear_beakpoints()

        else:
            self.logger.warning(f&#34;-&gt; Debugger input {inputs} not managed!&#34;)

    def get_input(self, prompt: str):

        def memory_action(cmd_str, cmd_vars, cmd_dict):
            list_loc = cmd_vars.split(&#39; &#39;)
            addresses = []

            if len(list_loc) &gt; 2:
                raise ValueError(&#34;too many addresses, should be one or a range&#34;)

            for loc in list_loc:
                addresses.append(self._parse_string_address(loc))

            res = f&#34;!{Action.READ_MEMORY} {&#39; &#39;.join(addresses)}&#34;
            return (COMMAND_ACTION_USE_VALUE, res)

        def registers_action(cmd_str, cmd_vars, cmd_dict):
            if cmd_vars:
                list_reg = [reg.upper() for reg in cmd_vars.split(&#39; &#39;)]
                for reg in list_reg:
                    if reg not in [&#39;A&#39;, &#39;Y&#39;, &#39;X&#39;, &#39;P&#39;, &#39;S&#39;, &#39;PC&#39;]:
                        raise ValueError(f&#34;Unknown register {reg}&#34;)

                res = f&#34;!{Action.READ_REGISTERS} {&#39; &#39;.join(list_reg)}&#34;
                return (COMMAND_ACTION_USE_VALUE, res)
            else:
                res = f&#34;!{Action.READ_REGISTERS}&#34;
                return (COMMAND_ACTION_USE_VALUE, res)

        def next_action(cmd_str, cmd_vars, cmd_dict):
            if cmd_vars:
                cmd_vars = int(cmd_vars, 0)

            res = f&#34;!{Action.RUN_NEXT} {cmd_vars}&#34;
            return (COMMAND_ACTION_USE_VALUE, res)

        def instruction_action(cmd_str, cmd_vars, cmd_dict):
            res = f&#34;!{Action.SHOW_INSTRUCTION}&#34;
            return (COMMAND_ACTION_USE_VALUE, res)

        def cycles_action(cmd_str, cmd_vars, cmd_dict):
            if cmd_vars:
                try:
                    nb = int(cmd_vars)
                except:
                    raise ValueError(&#34;Invalid number of instructions&#34;)
                res = f&#34;!{Action.SHOW_CYCLES_COUNT} {cmd_vars}&#34;
            else:
                res = f&#34;!{Action.SHOW_CYCLES_COUNT}&#34;

            return (COMMAND_ACTION_USE_VALUE, res)

        def breakpoint_action(cmd_str, cmd_vars, cmd_dict):
            if cmd_vars:
                list_loc = cmd_vars.split(&#39; &#39;)
                adresses = []
                for loc in list_loc:
                    adresses.append(self._parse_string_address(loc))

                res = f&#34;!{Action.SET_BREAKPOINT} {&#39; &#39;.join(adresses)}&#34;
                return (COMMAND_ACTION_USE_VALUE, res)
            else:
                res = f&#34;!{Action.SET_BREAKPOINT}&#34;
                return (COMMAND_ACTION_USE_VALUE, res)


        def cancel_action(cmd_str, cmd_vars, cmd_dict):
            return (COMMAND_ACTION_CANCEL, None)

        def show_help_action(cmd_str, cmd_vars, cmd_dict):
            print(&#39;Available commands:&#39;)
            print(&#39;? - show this message&#39;)
            print(&#39;e - exit simulator&#39;)
            print(&#39;n [nb]- run next nb instructions&#39;)
            print(&#39;m - show memory&#39;)
            print(&#39;r - show registers&#39;)
            print(&#39;i - show instruction&#39;)
            print(&#39;c - show cycles count&#39;)
            print(&#39;b - set/reset/clear breakpoints&#39;)

            return CommandResponse(COMMAND_ACTION_NOP, None)

        cmds = {
            &#39;?&#39;: GetInputCommand(show_help_action),
            &#39;e&#39;: GetInputCommand(cancel_action),
            &#39;n&#39;: GetInputCommand(next_action),
            &#39;m&#39;: GetInputCommand(memory_action),
            &#39;r&#39;: GetInputCommand(registers_action),
            &#39;i&#39;: GetInputCommand(instruction_action),
            &#39;c&#39;: GetInputCommand(cycles_action),
            &#39;b&#39;: GetInputCommand(breakpoint_action),
        }

        while True:
            try:
                result = ci.get_string(prompt=prompt, commands=cmds)

                if result[0] == &#39;!&#39;:

                    res = result[1:].split(&#39; &#39;)
                    return {
                         &#34;cmd&#34;: eval(res[0]),
                         &#34;args&#34;: res[1:]
                    }
                else:
                    print(f&#34;Unknown command {result}, enter ? for help&#34;)
            except ValueError as e:
                print(f&#34;Bad format: {e}&#34;)
            except GetInputInterrupt:
                break

    def _parse_string_address(self, adr_string: str) -&gt; str:
        try:
            if &#34;$&#34; in adr_string:
                val = str(int(adr_string[1:], 16))
            elif &#34;0x&#34; in adr_string:
                val = str(int(adr_string[2:], 16))
            else:
                val = str(int(adr_string))
        except Exception as e:
            raise ValueError(f&#34;Cannot convert {adr_string} into address due to: {e}&#34;)

        return val</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="shazzam.Emu6502.Emu6502.clear_beakpoints"><code class="name flex">
<span>def <span class="ident">clear_beakpoints</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all breakpoints</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_beakpoints(self):
    &#34;&#34;&#34;Clear all breakpoints&#34;&#34;&#34;
    self.breakpoints = []
    self.logger.debug(&#34;All breakpoints are removed&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.Emu6502.Emu6502.get_input"><code class="name flex">
<span>def <span class="ident">get_input</span></span>(<span>self, prompt: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input(self, prompt: str):

    def memory_action(cmd_str, cmd_vars, cmd_dict):
        list_loc = cmd_vars.split(&#39; &#39;)
        addresses = []

        if len(list_loc) &gt; 2:
            raise ValueError(&#34;too many addresses, should be one or a range&#34;)

        for loc in list_loc:
            addresses.append(self._parse_string_address(loc))

        res = f&#34;!{Action.READ_MEMORY} {&#39; &#39;.join(addresses)}&#34;
        return (COMMAND_ACTION_USE_VALUE, res)

    def registers_action(cmd_str, cmd_vars, cmd_dict):
        if cmd_vars:
            list_reg = [reg.upper() for reg in cmd_vars.split(&#39; &#39;)]
            for reg in list_reg:
                if reg not in [&#39;A&#39;, &#39;Y&#39;, &#39;X&#39;, &#39;P&#39;, &#39;S&#39;, &#39;PC&#39;]:
                    raise ValueError(f&#34;Unknown register {reg}&#34;)

            res = f&#34;!{Action.READ_REGISTERS} {&#39; &#39;.join(list_reg)}&#34;
            return (COMMAND_ACTION_USE_VALUE, res)
        else:
            res = f&#34;!{Action.READ_REGISTERS}&#34;
            return (COMMAND_ACTION_USE_VALUE, res)

    def next_action(cmd_str, cmd_vars, cmd_dict):
        if cmd_vars:
            cmd_vars = int(cmd_vars, 0)

        res = f&#34;!{Action.RUN_NEXT} {cmd_vars}&#34;
        return (COMMAND_ACTION_USE_VALUE, res)

    def instruction_action(cmd_str, cmd_vars, cmd_dict):
        res = f&#34;!{Action.SHOW_INSTRUCTION}&#34;
        return (COMMAND_ACTION_USE_VALUE, res)

    def cycles_action(cmd_str, cmd_vars, cmd_dict):
        if cmd_vars:
            try:
                nb = int(cmd_vars)
            except:
                raise ValueError(&#34;Invalid number of instructions&#34;)
            res = f&#34;!{Action.SHOW_CYCLES_COUNT} {cmd_vars}&#34;
        else:
            res = f&#34;!{Action.SHOW_CYCLES_COUNT}&#34;

        return (COMMAND_ACTION_USE_VALUE, res)

    def breakpoint_action(cmd_str, cmd_vars, cmd_dict):
        if cmd_vars:
            list_loc = cmd_vars.split(&#39; &#39;)
            adresses = []
            for loc in list_loc:
                adresses.append(self._parse_string_address(loc))

            res = f&#34;!{Action.SET_BREAKPOINT} {&#39; &#39;.join(adresses)}&#34;
            return (COMMAND_ACTION_USE_VALUE, res)
        else:
            res = f&#34;!{Action.SET_BREAKPOINT}&#34;
            return (COMMAND_ACTION_USE_VALUE, res)


    def cancel_action(cmd_str, cmd_vars, cmd_dict):
        return (COMMAND_ACTION_CANCEL, None)

    def show_help_action(cmd_str, cmd_vars, cmd_dict):
        print(&#39;Available commands:&#39;)
        print(&#39;? - show this message&#39;)
        print(&#39;e - exit simulator&#39;)
        print(&#39;n [nb]- run next nb instructions&#39;)
        print(&#39;m - show memory&#39;)
        print(&#39;r - show registers&#39;)
        print(&#39;i - show instruction&#39;)
        print(&#39;c - show cycles count&#39;)
        print(&#39;b - set/reset/clear breakpoints&#39;)

        return CommandResponse(COMMAND_ACTION_NOP, None)

    cmds = {
        &#39;?&#39;: GetInputCommand(show_help_action),
        &#39;e&#39;: GetInputCommand(cancel_action),
        &#39;n&#39;: GetInputCommand(next_action),
        &#39;m&#39;: GetInputCommand(memory_action),
        &#39;r&#39;: GetInputCommand(registers_action),
        &#39;i&#39;: GetInputCommand(instruction_action),
        &#39;c&#39;: GetInputCommand(cycles_action),
        &#39;b&#39;: GetInputCommand(breakpoint_action),
    }

    while True:
        try:
            result = ci.get_string(prompt=prompt, commands=cmds)

            if result[0] == &#39;!&#39;:

                res = result[1:].split(&#39; &#39;)
                return {
                     &#34;cmd&#34;: eval(res[0]),
                     &#34;args&#34;: res[1:]
                }
            else:
                print(f&#34;Unknown command {result}, enter ? for help&#34;)
        except ValueError as e:
            print(f&#34;Bad format: {e}&#34;)
        except GetInputInterrupt:
            break</code></pre>
</details>
</dd>
<dt id="shazzam.Emu6502.Emu6502.load_and_run"><code class="name flex">
<span>def <span class="ident">load_and_run</span></span>(<span>self, segments: List, entry_address: int, stop_address: int = None, cycles_count_start: int = None, cycles_count_end: int = None, debug_mode: bool = False) ‑> (<class 'py65emu.cpu.CPU'>, <class 'py65emu.mmu.MMU'>, <class 'int'>)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>segments</code></strong> :&ensp;<code>List[Segment]</code></dt>
<dd>[description]</dd>
<dt><strong><code>entry_address</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>cycles_count_start</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>cycles_count_end</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>debug_mode</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CPU, MMU, int</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_and_run(self, segments: List, entry_address: int, stop_address: int = None, cycles_count_start: int = None, cycles_count_end: int = None, debug_mode: bool = False) -&gt; (CPU, MMU, int):
    &#34;&#34;&#34;[summary]

    Args:
        segments (List[Segment]): [description]
        entry_address (int): [description]
        cycles_count_start (int, optional): [description]. Defaults to None.
        cycles_count_end (int, optional): [description]. Defaults to None.
        debug_mode (bool, optional): [description]. Defaults to False.

    Returns:
        CPU, MMU, int: [description]
    &#34;&#34;&#34;
    low_ram = (0x0000, segments[0].start_adr, False)
    hi_ram = (segments[-1].end_adr, 0xffff, False)

    mmu_segments = []

    mmu_segments.append(low_ram)
    for seg in segments:
        bytecode = BytesIO(seg.get_segment_bytecode())
        mmu_s = (seg.start_adr, seg.end_adr - seg.start_adr, False, bytecode)
        mmu_segments.append(mmu_s)
    mmu_segments.append(hi_ram)

    self.logger.info(mmu_segments)
    self.debug_mode = debug_mode

    self.mmu = MMU(mmu_segments)
    self.cpu = CPU(self.mmu, entry_address)

    counting_enabled = False if cycles_count_start is not None else True
    stop_address = 0xffff if stop_address is None else stop_address

    self.logger.info(f&#34;Loading code from {segments[0].start_adr:04X} to {segments[-1].end_adr:04X}&#34;)
    self.logger.debug(f&#34;Set PC at {entry_address:04X}&#34;)
    self.logger.debug(f&#34;Emulating from ${self.cpu.r.pc:04X} to ${stop_address:04X}&#34;)

    self.nb_cycles_used = 0
    current_bytecode = self.mmu.read(self.cpu.r.pc)
    current_instruction = Instruction.opcodes[current_bytecode]
    current_operand_size = Instruction.operand_sizes[current_instruction[1]]+1
    current_operand = [self.mmu.read(self.cpu.r.pc + 1 + i) for i in range(current_operand_size)]

    while(self.cpu.r.pc &lt; stop_address and current_instruction[0] != &#39;brk&#39;):
        try:
            if self.cpu.r.pc == cycles_count_start:
                counting_enabled = True
                self.logger.info(f&#34;Starting to count cycle at ${self.cpu.r.pc:04X}&#34;)
            if self.cpu.r.pc == cycles_count_end:
                counting_enabled = False
                self.logger.info(f&#34;Stopping to count cycle at ${self.cpu.r.pc:04X}&#34;)

            current_bytecode = self.mmu.read(self.cpu.r.pc)
            current_instruction = Instruction.opcodes[current_bytecode]
            current_operand_size = Instruction.operand_sizes[current_instruction[1]]+1
            current_operand = [self.mmu.read(self.cpu.r.pc+1+i) for i in range(current_operand_size)]

            if counting_enabled:
                self.nb_cycles_used += self.cpu.cc

            if self.debug_mode or self.cpu.r.pc in self.breakpoints or self.breakpoint_in == 0:
                print(f&#34;${self.cpu.r.pc:04X}: {current_instruction[0]} [{current_instruction[1]}] (${int.from_bytes(current_operand, &#39;big&#39;):02X})&#34;)
                print(f&#34;{self.cpu.r}&#34;)
                if self.breakpoints:
                    print(f&#34;Breakpoints: {[f&#39;${bp:04X}&#39; for bp in self.breakpoints]}&#34;)

                inputs = self.get_input(f&#34;${self.cpu.r.pc:04X}&#34;)
                if inputs:
                    self.process_input(inputs, current_instruction, int.from_bytes(current_operand, &#39;big&#39;), cycles_count_start)
                else:
                    self.debug_mode = False
            else:
                if counting_enabled and self.nb_cycles_used % 1000 == 0:
                    self.logger.info(f&#34;Total: {self.nb_cycles_used} R: {self.cpu.r} CC: {self.cpu.cc}&#34;)

                self.cpu.step()

                if self.breakpoint_in &gt; 0:
                    self.breakpoint_in -= 1

        except Exception as e:
            self.logger.critical(f&#34;Emulation crashed at ${self.cpu.r.pc:04X} (bytecode {current_bytecode:02X}) due to {e.__class__}&#34;)
            self.logger.critical(f&#34;{current_instruction} operand: {int.from_bytes(current_operand, &#39;big&#39;):02X}&#34;)
            self.logger.critical(f&#34;Registers: {self.cpu.r}&#34;)
            self.logger.critical(traceback.format_exc())
            break

    self.logger.info(f&#34;Emulation stopped at ${self.cpu.r.pc:04X} with last instruction executed: {current_instruction[0]}&#34;)

    return self.cpu, self.mmu, self.nb_cycles_used</code></pre>
</details>
</dd>
<dt id="shazzam.Emu6502.Emu6502.process_input"><code class="name flex">
<span>def <span class="ident">process_input</span></span>(<span>self, inputs, inst, operand, nb_cycles_start)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>inst</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>operand</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>nb_cycles_start</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_input(self, inputs, inst, operand, nb_cycles_start):
    &#34;&#34;&#34;[summary]

    Args:
        inputs ([type]): [description]
        inst ([type]): [description]
        operand ([type]): [description]
        nb_cycles_start ([type]): [description]
    &#34;&#34;&#34;
    if inputs[&#39;cmd&#39;] == Action.READ_MEMORY:
        vals = [int(x) for x in inputs[&#39;args&#39;]]

        if len(vals) == 1:
            print(f&#34;${vals[0]:04X}: {self.mmu.read(vals[0])}&#34;)
        else:
            delta = vals[1] - vals[0] + 1
            if delta &lt; 1:
                print(f&#34;-&gt; Memory range cannot be null or negative: ${delta:04X} = ${vals[1]:04X} - ${vals[0]:04X}&#34;)
            else:
                modulo = 1 if delta % 16 != 0 else 0

                for i in range((delta // 16) + modulo):
                    print(f&#34;${vals[0]+(i*16):04X}: &#34;, end= &#39;&#39;)
                    for j in range(min(16, delta - (i*16))):
                        print(f&#34;{self.mmu.read(vals[0]):02X}&#34;, end = &#39; &#39;)
                    print()

    elif inputs[&#39;cmd&#39;] == Action.READ_REGISTERS:
        if len(inputs[&#39;args&#39;]) == 0:
            print(f&#34;Registers: {self.cpu.r}&#34;)
        else:
            for r in inputs[&#39;args&#39;]:
                print(f&#34;Register {r}: {eval(f&#39;self.cpu.r.{r.lower()}&#39;)} | ${eval(f&#39;self.cpu.r.{r.lower()}&#39;):0X} | %{eval(f&#39;self.cpu.r.{r.lower()}&#39;):0b}&#34;)

    elif inputs[&#39;cmd&#39;] == Action.RUN_NEXT:
        if len(inputs[&#39;args&#39;]) == 0:
            self.cpu.step()
        else:
            self.debug_mode = False
            self.breakpoint_in = int(inputs[&#39;args&#39;][0])
            print(f&#34;-&gt; Program will stop in {self.breakpoint_in} instructions&#34;)

    elif inputs[&#39;cmd&#39;] == Action.SHOW_INSTRUCTION:
        print(f&#34;${self.cpu.r.pc:04X}: {&#39; &#39;.join(inst)} {operand:02X}&#34;)

    elif inputs[&#39;cmd&#39;] == Action.SHOW_CYCLES_COUNT:
        if nb_cycles_start:
            print(f&#34;${self.cpu.r.pc:04X}: {self.nb_cycles_used} cycles used since ${nb_cycles_start:04X}&#34;)
        else:
            print(f&#34;${self.cpu.r.pc:04X}: {self.nb_cycles_used} cycles used&#34;)

    elif inputs[&#39;cmd&#39;] == Action.SET_BREAKPOINT:
        if inputs[&#39;args&#39;]:
            for bp in [int(v) for v in inputs[&#39;args&#39;]]:
                self.reset_breakpoint(bp)
                print(f&#34;-&gt; Breakpoint added at ${bp:04X}&#34;)
        else:
            print(f&#34;-&gt; Breakpoints {[f&#39;${bp:04X}&#39; for bp in self.breakpoints]} cleared&#34;)
            self.clear_beakpoints()

    else:
        self.logger.warning(f&#34;-&gt; Debugger input {inputs} not managed!&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.Emu6502.Emu6502.reset_breakpoint"><code class="name flex">
<span>def <span class="ident">reset_breakpoint</span></span>(<span>self, address: int)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_breakpoint(self, address : int):
    &#34;&#34;&#34;[summary]

    Args:
        address (int): [description]

    Raises:
        ValueError: [description]
    &#34;&#34;&#34;
    if isinstance(address, int) and address in range(0, 0xffff):
        if address not in self.breakpoints:
            self.breakpoints.append(address)
        else:
            self.breakpoints.remove(address)
    else:
        raise ValueError(f&#34;Invalid breakpoint {address}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="shazzam" href="index.html">shazzam</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="shazzam.Emu6502.Action" href="#shazzam.Emu6502.Action">Action</a></code></h4>
<ul class="two-column">
<li><code><a title="shazzam.Emu6502.Action.CLEAR_BREAKPOINT" href="#shazzam.Emu6502.Action.CLEAR_BREAKPOINT">CLEAR_BREAKPOINT</a></code></li>
<li><code><a title="shazzam.Emu6502.Action.EXIT" href="#shazzam.Emu6502.Action.EXIT">EXIT</a></code></li>
<li><code><a title="shazzam.Emu6502.Action.READ_MEMORY" href="#shazzam.Emu6502.Action.READ_MEMORY">READ_MEMORY</a></code></li>
<li><code><a title="shazzam.Emu6502.Action.READ_REGISTERS" href="#shazzam.Emu6502.Action.READ_REGISTERS">READ_REGISTERS</a></code></li>
<li><code><a title="shazzam.Emu6502.Action.RUN_NEXT" href="#shazzam.Emu6502.Action.RUN_NEXT">RUN_NEXT</a></code></li>
<li><code><a title="shazzam.Emu6502.Action.SET_BREAKPOINT" href="#shazzam.Emu6502.Action.SET_BREAKPOINT">SET_BREAKPOINT</a></code></li>
<li><code><a title="shazzam.Emu6502.Action.SHOW_CYCLES_COUNT" href="#shazzam.Emu6502.Action.SHOW_CYCLES_COUNT">SHOW_CYCLES_COUNT</a></code></li>
<li><code><a title="shazzam.Emu6502.Action.SHOW_INSTRUCTION" href="#shazzam.Emu6502.Action.SHOW_INSTRUCTION">SHOW_INSTRUCTION</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="shazzam.Emu6502.Emu6502" href="#shazzam.Emu6502.Emu6502">Emu6502</a></code></h4>
<ul class="">
<li><code><a title="shazzam.Emu6502.Emu6502.clear_beakpoints" href="#shazzam.Emu6502.Emu6502.clear_beakpoints">clear_beakpoints</a></code></li>
<li><code><a title="shazzam.Emu6502.Emu6502.get_input" href="#shazzam.Emu6502.Emu6502.get_input">get_input</a></code></li>
<li><code><a title="shazzam.Emu6502.Emu6502.load_and_run" href="#shazzam.Emu6502.Emu6502.load_and_run">load_and_run</a></code></li>
<li><code><a title="shazzam.Emu6502.Emu6502.process_input" href="#shazzam.Emu6502.Emu6502.process_input">process_input</a></code></li>
<li><code><a title="shazzam.Emu6502.Emu6502.reset_breakpoint" href="#shazzam.Emu6502.Emu6502.reset_breakpoint">reset_breakpoint</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>