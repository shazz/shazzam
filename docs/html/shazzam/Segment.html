<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>shazzam.Segment API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>shazzam.Segment</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import shazzam.globals as g
from shazzam.defs import *
from shazzam.Instruction import Instruction
from shazzam.ByteData import ByteData
from shazzam.Rasterline import Rasterline
from shazzam.Emu6502 import Emu6502

import binascii
from typing import List
import io
from functools import reduce
import logging

# ---------------------------------------------------------------------
# internal utils
# ---------------------------------------------------------------------
def _insert(source_str, insert_str, pos):
    &#34;&#34;&#34;[summary]

    Args:
        source_str ([type]): [description]
        insert_str ([type]): [description]
        pos ([type]): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    return source_str[:pos] + insert_str + source_str[pos:len(source_str)-len(insert_str)]

# ---------------------------------------------------------------------
# Segment class
# ---------------------------------------------------------------------
class Segment():
    &#34;&#34;&#34;Segment class&#34;&#34;&#34;
    comments_chars = {
        CommentsFormat.USE_SEMICOLON: &#39;;&#39;,
        CommentsFormat.USE_SHARP: &#34;#&#34;,
        CommentsFormat.USE_SLASH: &#34;//&#34;
    }

    directive_prefix = {
        DirectiveFormat.NO_PREFIX: &#39;&#39;,
        DirectiveFormat.USE_DOT: &#39;.&#39;,
        DirectiveFormat.USE_EXCLAMATION: &#39;!&#39;
    }

    def __init__(self, start_adr: int, name: str, code_format: List[CodeFormat] = None, comments_format: CommentsFormat = None, directive_prefix: DirectiveFormat = None, use_relative_addressing: bool = False):
        &#34;&#34;&#34;[summary]

        Args:
            start_adr (int): [description]
            name (str): [description]
            code_format (List[CodeFormat], optional): [description]. Defaults to None.
            comments_format (CommentsFormat, optional): [description]. Defaults to CommentsFormat.USE_SEMICOLON.
            directive_prefix (DirectiveFormat, optional): [description]. Defaults to DirectiveFormat.USE_DOT.
        &#34;&#34;&#34;
        self.start_adr = start_adr
        self.end_adr = start_adr
        self.instructions = {}
        self.next_position = start_adr
        self.name = name
        self.total_cycles_used = 0
        self.labels = {}
        self.required_labels = {}
        self.use_relative_addressing = use_relative_addressing
        self.logger = logging.getLogger(&#34;shazzam&#34;)

        if code_format is None:
            code_format = g._CODE_FORMAT
        if comments_format is None:
            comments_format = g._COMMENTS_FORMAT
        if directive_prefix is None:
            directive_prefix = g._DIRECTIVE_PREFIX

        self.logger.debug(f&#34;Prefs: {code_format} / {comments_format} / {directive_prefix}&#34;)

        self.show_address = True if CodeFormat.ADDRESS in code_format else False
        self.show_bytecode = True if CodeFormat.BYTECODE in code_format else False
        self.show_cycles = True if CodeFormat.CYCLES in code_format else False
        self.use_uppercase = True if CodeFormat.UPPERCASE in code_format else False
        self.use_hex = True if CodeFormat.USE_HEX in code_format else False

        self.comment_char = Segment.comments_chars[comments_format]
        self.directive_prefix = Segment.directive_prefix[directive_prefix]

        self.rasterlines = {}
        self.anonymous_labels = {}

    def close(self) -&gt; None:
        &#34;&#34;&#34;[summary]
        &#34;&#34;&#34;
        self.end_adr = self.next_position

    def add_instruction(self, instr: Instruction) -&gt; bytearray:
        &#34;&#34;&#34;[summary]

        Args:
            instr (Instruction): [description]

        Returns:
            bytearray: [description]
        &#34;&#34;&#34;
        self.instructions[self.next_position] = instr
        self.next_position += instr.get_size()
        self.total_cycles_used += instr.get_cycle_count()
        instr.end_address = self.next_position

        # check size, relative addresses,...
        instr.check_constraints()

        if g._CURRENT_RASTER is not None:
            self.logger.debug(f&#34;Adding {instr} to rasterline&#34;)
            g._CURRENT_RASTER.add_cycles(instr.get_cycle_count())

        return self.get_bytecode(instr)

    def add_byte(self, value: int, label: str = None) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            value (int): [description]
            label (str, optional): [description]. Defaults to None.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        data = ByteData(value, label)
        self.instructions[self.next_position] = data
        self.next_position += 1

        return self.get_bytecode(data)

    def add_label(self, name: str) -&gt; int:
        &#34;&#34;&#34;Add segment label

        Args:
            name (str): [description]

        Raises:
            ValueError: [description]

        Returns:
            int: [description]
        &#34;&#34;&#34;
        if name in self.labels:
            raise ValueError(f&#34;Label {name} already defined in segment at {self.labels[name]}&#34;)

        self.labels[name] = self.next_position

        return self.labels[name]

    def get_address(self, label: str) -&gt; int:
        &#34;&#34;&#34;[summary]

        Args:
            label (str): [description]

        Raises:
            ValueError: [description]

        Returns:
            int: [description]
        &#34;&#34;&#34;
        if label not in self.labels:
            raise ValueError(f&#34;Cannot find label {label}&#34;)

        return self.labels[label]

    def need_label(self, label: str, relative: bool = False) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            label (str): [description]
            relative (bool, optional): [description]. Defaults to False.
        &#34;&#34;&#34;
        self.required_labels[label] = {
            &#34;from&#34;: self.next_position,
            &#34;relative&#34;: relative
        }

    def get_segment_bytecode(self) -&gt; bytearray:

        self.resolve_labels()

        bytecode = bytearray([])
        for adr, instr in self.instructions.items():
            bytecode += self.get_bytecode(instr)

        return bytecode

    def get_bytecode(self, instr: Instruction) -&gt; bytearray:
        &#34;&#34;&#34;[summary]

        Args:
            instr (Instruction): [description]

        Returns:
            bytearray: [description]
        &#34;&#34;&#34;
        ope = instr.get_operand()
        op = instr.get_opcode()

        if ope is not None:
            if instr.get_size() == 2+1:
                self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:04X}&#34;)
                data = [op, ope &amp; 0xff, (ope &gt;&gt; 8) &amp; 0xff]
            else:
                self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:02X}&#34;)
                data = [op, ope &amp; 0xff]
        else:
            self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X}&#34;)
            data = [instr.get_opcode()]

        self.logger.debug(f&#34;Got bytecode for {instr}: {data}&#34;)

        return bytearray(data)

    def resolve_labels(self) -&gt; None:
        &#34;&#34;&#34;Replace all instructions with their absolute address.

        Raises:
            ValueError: [description]
            ValueError: [description]
        &#34;&#34;&#34;
        # check labels
        for label, params in self.required_labels.items():
            if (label not in self.labels) and (label not in g._PROGRAM.global_labels):
                print(&#34;global:&#34;, g._PROGRAM.global_labels)
                raise ValueError(f&#34;Label {label} is used but not defined locally or globally!&#34;)

            if params[&#39;relative&#39;] and abs(params[&#39;from&#39;] - self.labels[label]) &gt; 255:
                raise ValueError(f&#34;Label {label} branch at {params[&#39;from&#39;]} is more than 1 bytes!&#34;)

        # resolve labels now!
        for adr, instr in self.instructions.items():
            if instr.label:
                if instr.label in self.labels:

                    if self.use_relative_addressing:

                        instr.value = self.labels[instr.label] - adr - instr.get_size() if adr &lt; self.labels[instr.label] else adr - self.labels[instr.label] - instr.get_size()
                        self.logger.info(f&#34;Use relative addressing to label {instr.label} at {self.labels[instr.label]:04X} from {adr:04X} will be: {instr.value}&#34;)

                    else:
                        instr.value = self.labels[instr.label]

                elif instr.label in g._PROGRAM.global_labels:
                    instr.value = g._PROGRAM.global_labels[instr.label]
                else:
                    raise ValueError(f&#34;Label {label} cannot be resolved locally or globally!&#34;)

                self.logger.debug(f&#34;Label {instr.label} replaced by absolute address {instr.value:04X}&#34;)

    def gen_code(self) -&gt; None:
        &#34;&#34;&#34;Generates assembly code.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        self.resolve_labels()

        code = []

        # add segment directive
        code.append(f&#39;\t\t{self.directive_prefix}segment &#34;{self.name}&#34;\n&#39;)

        code_template_index = {
            &#34;address&#34;: 0,
            &#34;bytecode&#34;: 8 if self.show_address else 0,
            &#34;label&#34;: 40 if self.show_bytecode else 8 if self.show_address else 0,
            &#34;instruction&#34;: 50 if self.show_bytecode else 18 if self.show_address else 10,
            &#34;cycles&#34;: 70 if self.show_bytecode else 38 if self.show_address else 30,
        }

        process_byte = True
        for adr, instr in self.instructions.items():

            if self.use_uppercase:
                instr.use_upper = True
            if self.use_hex:
                instr.use_hex = True

            label = [k for k,v in self.labels.items() if v == adr]

            # substract start address if relative addressing
            address_offset = self.start_adr if self.use_relative_addressing else 0

            if isinstance(instr, ByteData):
                if process_byte:

                    process_byte = False

                    prefix = self.directive_prefix

                    nb_bytes = 0

                    #TODO: break if a label is defined in the middle else won&#39;t be shown
                    # won&#39;t work with process_byte bool
                    try:
                        while adr+nb_bytes in self.instructions and isinstance(self.instructions[adr+nb_bytes], ByteData):
                            nb_bytes += 1
                    except KeyError as e:
                        self.logger.error(f&#34;Could not find address {adr+nb_bytes} (${adr+nb_bytes:04X}) in {self.instructions.keys()}&#34;)
                        raise

                    self.logger.debug(f&#34;{nb_bytes} bytes of data before instruction&#34;)
                    if nb_bytes &gt; 8:

                        # manage the remaining bytes if not a multiple of 8
                        nb_rows = nb_bytes // 8 + 1 if nb_bytes % 8 != 0 else nb_bytes // 8

                        for row in range(nb_rows):

                            r_label = [k for k,v in self.labels.items() if v == adr+(row*8)]
                            s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                            s_address = f&#34;{adr+(row*8)-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                            bcode = &#34;&#34;
                            for b in range(min(8, nb_bytes-(8*row))):
                                bytedata = self.instructions[adr+(row*8)+b]
                                bcode += str(binascii.hexlify(self.get_bytecode(bytedata)))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()
                            bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                            bcode2 = &#39;$&#39;+&#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                            line = &#39; &#39;*100
                            if self.show_address:
                                line = _insert(line, s_address, code_template_index[&#34;address&#34;])
                            if self.show_bytecode:
                                line = _insert(line, bcode1, code_template_index[&#34;bytecode&#34;])

                            line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                            line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                            line.strip()
                            line  += &#39;\n&#39;

                            code.append(line)
                    else:
                        s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                        s_label = f&#34;{label[0]}:&#34; if label else &#34;&#34;
                        bcode = &#34;&#34;
                        for b in range(nb_bytes):
                            bytedata = self.instructions[adr+b]
                            bcode += str(binascii.hexlify(self.get_bytecode(bytedata)))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()
                        bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                        bcode2 = &#39;$&#39;+&#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                        line = &#39; &#39;*100
                        if self.show_address:
                            line = _insert(line, s_address, code_template_index[&#34;address&#34;])
                        if self.show_bytecode:
                            line = _insert(line, bcode1, code_template_index[&#34;bytecode&#34;])

                        line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                        line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                        line.strip()
                        line  += &#39;\n&#39;

                        code.append(line)
            else:
                process_byte = True
                s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                s_label = f&#34;{label[0]}:&#34; if label else &#34;&#34;

                bcode = str(binascii.hexlify(self.get_bytecode(instr)))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()    # remove leading &#39;b and trailing &#39;. Ex: bytearray(b&#39;\xa9\x0b&#39;) A90B
                bcode = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                s_bytecode = f&#34;{bcode}&#34; if self.show_bytecode else &#34;&#34;

                cycles = instr.get_cycle_count()
                s_cycles = f&#34;{self.comment_char} {cycles}&#34; if self.show_cycles and cycles &gt; 0 else &#34;&#34;

                prefix = self.directive_prefix if isinstance(instr, ByteData) else &#39;&#39;

                line = &#39; &#39;*100
                line = _insert(line, s_address, code_template_index[&#34;address&#34;])
                line = _insert(line, s_bytecode, code_template_index[&#34;bytecode&#34;])
                line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                line = _insert(line, f&#34;{prefix}{instr}&#34;, code_template_index[&#34;instruction&#34;])
                line = _insert(line, s_cycles, code_template_index[&#34;cycles&#34;])
                line.strip()
                line  += &#39;\n&#39;

                code.append(line)

        return code

    def emulate(self, start_address: int = None):
        &#34;&#34;&#34;Emulates the code from start_address .

        Args:
            start_address (int, optional): [description]. Defaults to None.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if start_address is None:
            start_address = self.start_adr

        emu = Emu6502()
        ram = io.BytesIO(self.get_segment_bytecode())

        self.logger.info(f&#34;Emulating from {self.start_adr:04X}, to {self.next_position:04X} starting at {start_address:04X}&#34;)

        cpu_state = emu.load_and_run(ram, self.start_adr, self.next_position, start_address)

        return cpu_state

    def get_last_instruction(self) -&gt; Instruction:
        &#34;&#34;&#34;[summary]

        Returns:
            Instruction: [description]
        &#34;&#34;&#34;
        self.logger.debug(f&#34;Instructions in the current segment: {list(self.instructions.keys())}&#34;)
        return self.instructions[list(self.instructions.keys())[-1]]

    def get_stats(self):
        &#34;&#34;&#34;[summary]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if len(self.instructions) == 0:
            raise RuntimeError(f&#34;No instruction in the segment!&#34;)

        last_instr = self.get_last_instruction()
        return {
            &#34;size&#34;: self.next_position - self.start_adr,
            &#34;cycles_used&#34;: self.total_cycles_used,
            &#34;instructions&#34;: len(self.instructions),
            &#34;start_address&#34;: hex(self.start_adr),
            &#34;current_address&#34;: hex(self.next_position),
            &#34;last_instruction&#34;: {
                &#34;code&#34;: str(last_instr),
                &#34;size&#34;: last_instr.get_size(),
                &#34;cycles&#34;: last_instr.get_cycle_count()
            }
        }


    def get_anonymous_label(self, prefix: str) -&gt; str:
        &#34;&#34;&#34;Generate an anonymous label, in a macro for example

        Args:
            prefix (str): [description]

        Returns:
            str: [description]
        &#34;&#34;&#34;
        if prefix not in self.anonymous_labels:
            self.anonymous_labels[prefix] = 0
        else:
            self.anonymous_labels[prefix] += 1

        return f&#34;_{prefix}_{self.anonymous_labels[prefix]}&#34;

    # def checksum(self) -&gt; int:
    #     return reduce(lambda x,y : hashlib.md5((x+y).encode()).hexdigest(), [item.hash() for item in self.instructions.values()])

    def add_rasterline(self, index: int, rasterline: Rasterline) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            index (int): [description]
            rasterline (Rasterline): [description]
        &#34;&#34;&#34;
        self.rasterlines[index] = rasterline</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="shazzam.Segment.Segment"><code class="flex name class">
<span>class <span class="ident">Segment</span></span>
<span>(</span><span>start_adr: int, name: str, code_format: List[<a title="shazzam.defs.CodeFormat" href="defs.html#shazzam.defs.CodeFormat">CodeFormat</a>] = None, comments_format: <a title="shazzam.defs.CommentsFormat" href="defs.html#shazzam.defs.CommentsFormat">CommentsFormat</a> = None, directive_prefix: <a title="shazzam.defs.DirectiveFormat" href="defs.html#shazzam.defs.DirectiveFormat">DirectiveFormat</a> = None, use_relative_addressing: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Segment class</p>
<p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_adr</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>code_format</code></strong> :&ensp;<code>List[CodeFormat]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>comments_format</code></strong> :&ensp;<code>CommentsFormat</code>, optional</dt>
<dd>[description]. Defaults to CommentsFormat.USE_SEMICOLON.</dd>
<dt><strong><code>directive_prefix</code></strong> :&ensp;<code>DirectiveFormat</code>, optional</dt>
<dd>[description]. Defaults to DirectiveFormat.USE_DOT.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Segment():
    &#34;&#34;&#34;Segment class&#34;&#34;&#34;
    comments_chars = {
        CommentsFormat.USE_SEMICOLON: &#39;;&#39;,
        CommentsFormat.USE_SHARP: &#34;#&#34;,
        CommentsFormat.USE_SLASH: &#34;//&#34;
    }

    directive_prefix = {
        DirectiveFormat.NO_PREFIX: &#39;&#39;,
        DirectiveFormat.USE_DOT: &#39;.&#39;,
        DirectiveFormat.USE_EXCLAMATION: &#39;!&#39;
    }

    def __init__(self, start_adr: int, name: str, code_format: List[CodeFormat] = None, comments_format: CommentsFormat = None, directive_prefix: DirectiveFormat = None, use_relative_addressing: bool = False):
        &#34;&#34;&#34;[summary]

        Args:
            start_adr (int): [description]
            name (str): [description]
            code_format (List[CodeFormat], optional): [description]. Defaults to None.
            comments_format (CommentsFormat, optional): [description]. Defaults to CommentsFormat.USE_SEMICOLON.
            directive_prefix (DirectiveFormat, optional): [description]. Defaults to DirectiveFormat.USE_DOT.
        &#34;&#34;&#34;
        self.start_adr = start_adr
        self.end_adr = start_adr
        self.instructions = {}
        self.next_position = start_adr
        self.name = name
        self.total_cycles_used = 0
        self.labels = {}
        self.required_labels = {}
        self.use_relative_addressing = use_relative_addressing
        self.logger = logging.getLogger(&#34;shazzam&#34;)

        if code_format is None:
            code_format = g._CODE_FORMAT
        if comments_format is None:
            comments_format = g._COMMENTS_FORMAT
        if directive_prefix is None:
            directive_prefix = g._DIRECTIVE_PREFIX

        self.logger.debug(f&#34;Prefs: {code_format} / {comments_format} / {directive_prefix}&#34;)

        self.show_address = True if CodeFormat.ADDRESS in code_format else False
        self.show_bytecode = True if CodeFormat.BYTECODE in code_format else False
        self.show_cycles = True if CodeFormat.CYCLES in code_format else False
        self.use_uppercase = True if CodeFormat.UPPERCASE in code_format else False
        self.use_hex = True if CodeFormat.USE_HEX in code_format else False

        self.comment_char = Segment.comments_chars[comments_format]
        self.directive_prefix = Segment.directive_prefix[directive_prefix]

        self.rasterlines = {}
        self.anonymous_labels = {}

    def close(self) -&gt; None:
        &#34;&#34;&#34;[summary]
        &#34;&#34;&#34;
        self.end_adr = self.next_position

    def add_instruction(self, instr: Instruction) -&gt; bytearray:
        &#34;&#34;&#34;[summary]

        Args:
            instr (Instruction): [description]

        Returns:
            bytearray: [description]
        &#34;&#34;&#34;
        self.instructions[self.next_position] = instr
        self.next_position += instr.get_size()
        self.total_cycles_used += instr.get_cycle_count()
        instr.end_address = self.next_position

        # check size, relative addresses,...
        instr.check_constraints()

        if g._CURRENT_RASTER is not None:
            self.logger.debug(f&#34;Adding {instr} to rasterline&#34;)
            g._CURRENT_RASTER.add_cycles(instr.get_cycle_count())

        return self.get_bytecode(instr)

    def add_byte(self, value: int, label: str = None) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            value (int): [description]
            label (str, optional): [description]. Defaults to None.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        data = ByteData(value, label)
        self.instructions[self.next_position] = data
        self.next_position += 1

        return self.get_bytecode(data)

    def add_label(self, name: str) -&gt; int:
        &#34;&#34;&#34;Add segment label

        Args:
            name (str): [description]

        Raises:
            ValueError: [description]

        Returns:
            int: [description]
        &#34;&#34;&#34;
        if name in self.labels:
            raise ValueError(f&#34;Label {name} already defined in segment at {self.labels[name]}&#34;)

        self.labels[name] = self.next_position

        return self.labels[name]

    def get_address(self, label: str) -&gt; int:
        &#34;&#34;&#34;[summary]

        Args:
            label (str): [description]

        Raises:
            ValueError: [description]

        Returns:
            int: [description]
        &#34;&#34;&#34;
        if label not in self.labels:
            raise ValueError(f&#34;Cannot find label {label}&#34;)

        return self.labels[label]

    def need_label(self, label: str, relative: bool = False) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            label (str): [description]
            relative (bool, optional): [description]. Defaults to False.
        &#34;&#34;&#34;
        self.required_labels[label] = {
            &#34;from&#34;: self.next_position,
            &#34;relative&#34;: relative
        }

    def get_segment_bytecode(self) -&gt; bytearray:

        self.resolve_labels()

        bytecode = bytearray([])
        for adr, instr in self.instructions.items():
            bytecode += self.get_bytecode(instr)

        return bytecode

    def get_bytecode(self, instr: Instruction) -&gt; bytearray:
        &#34;&#34;&#34;[summary]

        Args:
            instr (Instruction): [description]

        Returns:
            bytearray: [description]
        &#34;&#34;&#34;
        ope = instr.get_operand()
        op = instr.get_opcode()

        if ope is not None:
            if instr.get_size() == 2+1:
                self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:04X}&#34;)
                data = [op, ope &amp; 0xff, (ope &gt;&gt; 8) &amp; 0xff]
            else:
                self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:02X}&#34;)
                data = [op, ope &amp; 0xff]
        else:
            self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X}&#34;)
            data = [instr.get_opcode()]

        self.logger.debug(f&#34;Got bytecode for {instr}: {data}&#34;)

        return bytearray(data)

    def resolve_labels(self) -&gt; None:
        &#34;&#34;&#34;Replace all instructions with their absolute address.

        Raises:
            ValueError: [description]
            ValueError: [description]
        &#34;&#34;&#34;
        # check labels
        for label, params in self.required_labels.items():
            if (label not in self.labels) and (label not in g._PROGRAM.global_labels):
                print(&#34;global:&#34;, g._PROGRAM.global_labels)
                raise ValueError(f&#34;Label {label} is used but not defined locally or globally!&#34;)

            if params[&#39;relative&#39;] and abs(params[&#39;from&#39;] - self.labels[label]) &gt; 255:
                raise ValueError(f&#34;Label {label} branch at {params[&#39;from&#39;]} is more than 1 bytes!&#34;)

        # resolve labels now!
        for adr, instr in self.instructions.items():
            if instr.label:
                if instr.label in self.labels:

                    if self.use_relative_addressing:

                        instr.value = self.labels[instr.label] - adr - instr.get_size() if adr &lt; self.labels[instr.label] else adr - self.labels[instr.label] - instr.get_size()
                        self.logger.info(f&#34;Use relative addressing to label {instr.label} at {self.labels[instr.label]:04X} from {adr:04X} will be: {instr.value}&#34;)

                    else:
                        instr.value = self.labels[instr.label]

                elif instr.label in g._PROGRAM.global_labels:
                    instr.value = g._PROGRAM.global_labels[instr.label]
                else:
                    raise ValueError(f&#34;Label {label} cannot be resolved locally or globally!&#34;)

                self.logger.debug(f&#34;Label {instr.label} replaced by absolute address {instr.value:04X}&#34;)

    def gen_code(self) -&gt; None:
        &#34;&#34;&#34;Generates assembly code.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        self.resolve_labels()

        code = []

        # add segment directive
        code.append(f&#39;\t\t{self.directive_prefix}segment &#34;{self.name}&#34;\n&#39;)

        code_template_index = {
            &#34;address&#34;: 0,
            &#34;bytecode&#34;: 8 if self.show_address else 0,
            &#34;label&#34;: 40 if self.show_bytecode else 8 if self.show_address else 0,
            &#34;instruction&#34;: 50 if self.show_bytecode else 18 if self.show_address else 10,
            &#34;cycles&#34;: 70 if self.show_bytecode else 38 if self.show_address else 30,
        }

        process_byte = True
        for adr, instr in self.instructions.items():

            if self.use_uppercase:
                instr.use_upper = True
            if self.use_hex:
                instr.use_hex = True

            label = [k for k,v in self.labels.items() if v == adr]

            # substract start address if relative addressing
            address_offset = self.start_adr if self.use_relative_addressing else 0

            if isinstance(instr, ByteData):
                if process_byte:

                    process_byte = False

                    prefix = self.directive_prefix

                    nb_bytes = 0

                    #TODO: break if a label is defined in the middle else won&#39;t be shown
                    # won&#39;t work with process_byte bool
                    try:
                        while adr+nb_bytes in self.instructions and isinstance(self.instructions[adr+nb_bytes], ByteData):
                            nb_bytes += 1
                    except KeyError as e:
                        self.logger.error(f&#34;Could not find address {adr+nb_bytes} (${adr+nb_bytes:04X}) in {self.instructions.keys()}&#34;)
                        raise

                    self.logger.debug(f&#34;{nb_bytes} bytes of data before instruction&#34;)
                    if nb_bytes &gt; 8:

                        # manage the remaining bytes if not a multiple of 8
                        nb_rows = nb_bytes // 8 + 1 if nb_bytes % 8 != 0 else nb_bytes // 8

                        for row in range(nb_rows):

                            r_label = [k for k,v in self.labels.items() if v == adr+(row*8)]
                            s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                            s_address = f&#34;{adr+(row*8)-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                            bcode = &#34;&#34;
                            for b in range(min(8, nb_bytes-(8*row))):
                                bytedata = self.instructions[adr+(row*8)+b]
                                bcode += str(binascii.hexlify(self.get_bytecode(bytedata)))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()
                            bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                            bcode2 = &#39;$&#39;+&#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                            line = &#39; &#39;*100
                            if self.show_address:
                                line = _insert(line, s_address, code_template_index[&#34;address&#34;])
                            if self.show_bytecode:
                                line = _insert(line, bcode1, code_template_index[&#34;bytecode&#34;])

                            line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                            line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                            line.strip()
                            line  += &#39;\n&#39;

                            code.append(line)
                    else:
                        s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                        s_label = f&#34;{label[0]}:&#34; if label else &#34;&#34;
                        bcode = &#34;&#34;
                        for b in range(nb_bytes):
                            bytedata = self.instructions[adr+b]
                            bcode += str(binascii.hexlify(self.get_bytecode(bytedata)))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()
                        bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                        bcode2 = &#39;$&#39;+&#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                        line = &#39; &#39;*100
                        if self.show_address:
                            line = _insert(line, s_address, code_template_index[&#34;address&#34;])
                        if self.show_bytecode:
                            line = _insert(line, bcode1, code_template_index[&#34;bytecode&#34;])

                        line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                        line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                        line.strip()
                        line  += &#39;\n&#39;

                        code.append(line)
            else:
                process_byte = True
                s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                s_label = f&#34;{label[0]}:&#34; if label else &#34;&#34;

                bcode = str(binascii.hexlify(self.get_bytecode(instr)))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()    # remove leading &#39;b and trailing &#39;. Ex: bytearray(b&#39;\xa9\x0b&#39;) A90B
                bcode = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                s_bytecode = f&#34;{bcode}&#34; if self.show_bytecode else &#34;&#34;

                cycles = instr.get_cycle_count()
                s_cycles = f&#34;{self.comment_char} {cycles}&#34; if self.show_cycles and cycles &gt; 0 else &#34;&#34;

                prefix = self.directive_prefix if isinstance(instr, ByteData) else &#39;&#39;

                line = &#39; &#39;*100
                line = _insert(line, s_address, code_template_index[&#34;address&#34;])
                line = _insert(line, s_bytecode, code_template_index[&#34;bytecode&#34;])
                line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                line = _insert(line, f&#34;{prefix}{instr}&#34;, code_template_index[&#34;instruction&#34;])
                line = _insert(line, s_cycles, code_template_index[&#34;cycles&#34;])
                line.strip()
                line  += &#39;\n&#39;

                code.append(line)

        return code

    def emulate(self, start_address: int = None):
        &#34;&#34;&#34;Emulates the code from start_address .

        Args:
            start_address (int, optional): [description]. Defaults to None.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if start_address is None:
            start_address = self.start_adr

        emu = Emu6502()
        ram = io.BytesIO(self.get_segment_bytecode())

        self.logger.info(f&#34;Emulating from {self.start_adr:04X}, to {self.next_position:04X} starting at {start_address:04X}&#34;)

        cpu_state = emu.load_and_run(ram, self.start_adr, self.next_position, start_address)

        return cpu_state

    def get_last_instruction(self) -&gt; Instruction:
        &#34;&#34;&#34;[summary]

        Returns:
            Instruction: [description]
        &#34;&#34;&#34;
        self.logger.debug(f&#34;Instructions in the current segment: {list(self.instructions.keys())}&#34;)
        return self.instructions[list(self.instructions.keys())[-1]]

    def get_stats(self):
        &#34;&#34;&#34;[summary]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if len(self.instructions) == 0:
            raise RuntimeError(f&#34;No instruction in the segment!&#34;)

        last_instr = self.get_last_instruction()
        return {
            &#34;size&#34;: self.next_position - self.start_adr,
            &#34;cycles_used&#34;: self.total_cycles_used,
            &#34;instructions&#34;: len(self.instructions),
            &#34;start_address&#34;: hex(self.start_adr),
            &#34;current_address&#34;: hex(self.next_position),
            &#34;last_instruction&#34;: {
                &#34;code&#34;: str(last_instr),
                &#34;size&#34;: last_instr.get_size(),
                &#34;cycles&#34;: last_instr.get_cycle_count()
            }
        }


    def get_anonymous_label(self, prefix: str) -&gt; str:
        &#34;&#34;&#34;Generate an anonymous label, in a macro for example

        Args:
            prefix (str): [description]

        Returns:
            str: [description]
        &#34;&#34;&#34;
        if prefix not in self.anonymous_labels:
            self.anonymous_labels[prefix] = 0
        else:
            self.anonymous_labels[prefix] += 1

        return f&#34;_{prefix}_{self.anonymous_labels[prefix]}&#34;

    # def checksum(self) -&gt; int:
    #     return reduce(lambda x,y : hashlib.md5((x+y).encode()).hexdigest(), [item.hash() for item in self.instructions.values()])

    def add_rasterline(self, index: int, rasterline: Rasterline) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            index (int): [description]
            rasterline (Rasterline): [description]
        &#34;&#34;&#34;
        self.rasterlines[index] = rasterline</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="shazzam.Segment.Segment.comments_chars"><code class="name">var <span class="ident">comments_chars</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Segment.Segment.directive_prefix"><code class="name">var <span class="ident">directive_prefix</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="shazzam.Segment.Segment.add_byte"><code class="name flex">
<span>def <span class="ident">add_byte</span></span>(<span>self, value: int, label: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_byte(self, value: int, label: str = None) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        value (int): [description]
        label (str, optional): [description]. Defaults to None.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    data = ByteData(value, label)
    self.instructions[self.next_position] = data
    self.next_position += 1

    return self.get_bytecode(data)</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.add_instruction"><code class="name flex">
<span>def <span class="ident">add_instruction</span></span>(<span>self, instr: <a title="shazzam.Instruction.Instruction" href="Instruction.html#shazzam.Instruction.Instruction">Instruction</a>) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instr</code></strong> :&ensp;<code>Instruction</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytearray</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_instruction(self, instr: Instruction) -&gt; bytearray:
    &#34;&#34;&#34;[summary]

    Args:
        instr (Instruction): [description]

    Returns:
        bytearray: [description]
    &#34;&#34;&#34;
    self.instructions[self.next_position] = instr
    self.next_position += instr.get_size()
    self.total_cycles_used += instr.get_cycle_count()
    instr.end_address = self.next_position

    # check size, relative addresses,...
    instr.check_constraints()

    if g._CURRENT_RASTER is not None:
        self.logger.debug(f&#34;Adding {instr} to rasterline&#34;)
        g._CURRENT_RASTER.add_cycles(instr.get_cycle_count())

    return self.get_bytecode(instr)</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.add_label"><code class="name flex">
<span>def <span class="ident">add_label</span></span>(<span>self, name: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Add segment label</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_label(self, name: str) -&gt; int:
    &#34;&#34;&#34;Add segment label

    Args:
        name (str): [description]

    Raises:
        ValueError: [description]

    Returns:
        int: [description]
    &#34;&#34;&#34;
    if name in self.labels:
        raise ValueError(f&#34;Label {name} already defined in segment at {self.labels[name]}&#34;)

    self.labels[name] = self.next_position

    return self.labels[name]</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.add_rasterline"><code class="name flex">
<span>def <span class="ident">add_rasterline</span></span>(<span>self, index: int, rasterline: <a title="shazzam.Rasterline.Rasterline" href="Rasterline.html#shazzam.Rasterline.Rasterline">Rasterline</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>rasterline</code></strong> :&ensp;<code>Rasterline</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_rasterline(self, index: int, rasterline: Rasterline) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        index (int): [description]
        rasterline (Rasterline): [description]
    &#34;&#34;&#34;
    self.rasterlines[index] = rasterline</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;[summary]
    &#34;&#34;&#34;
    self.end_adr = self.next_position</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.emulate"><code class="name flex">
<span>def <span class="ident">emulate</span></span>(<span>self, start_address: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Emulates the code from start_address .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_address</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emulate(self, start_address: int = None):
    &#34;&#34;&#34;Emulates the code from start_address .

    Args:
        start_address (int, optional): [description]. Defaults to None.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    if start_address is None:
        start_address = self.start_adr

    emu = Emu6502()
    ram = io.BytesIO(self.get_segment_bytecode())

    self.logger.info(f&#34;Emulating from {self.start_adr:04X}, to {self.next_position:04X} starting at {start_address:04X}&#34;)

    cpu_state = emu.load_and_run(ram, self.start_adr, self.next_position, start_address)

    return cpu_state</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.gen_code"><code class="name flex">
<span>def <span class="ident">gen_code</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Generates assembly code.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_code(self) -&gt; None:
    &#34;&#34;&#34;Generates assembly code.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    self.resolve_labels()

    code = []

    # add segment directive
    code.append(f&#39;\t\t{self.directive_prefix}segment &#34;{self.name}&#34;\n&#39;)

    code_template_index = {
        &#34;address&#34;: 0,
        &#34;bytecode&#34;: 8 if self.show_address else 0,
        &#34;label&#34;: 40 if self.show_bytecode else 8 if self.show_address else 0,
        &#34;instruction&#34;: 50 if self.show_bytecode else 18 if self.show_address else 10,
        &#34;cycles&#34;: 70 if self.show_bytecode else 38 if self.show_address else 30,
    }

    process_byte = True
    for adr, instr in self.instructions.items():

        if self.use_uppercase:
            instr.use_upper = True
        if self.use_hex:
            instr.use_hex = True

        label = [k for k,v in self.labels.items() if v == adr]

        # substract start address if relative addressing
        address_offset = self.start_adr if self.use_relative_addressing else 0

        if isinstance(instr, ByteData):
            if process_byte:

                process_byte = False

                prefix = self.directive_prefix

                nb_bytes = 0

                #TODO: break if a label is defined in the middle else won&#39;t be shown
                # won&#39;t work with process_byte bool
                try:
                    while adr+nb_bytes in self.instructions and isinstance(self.instructions[adr+nb_bytes], ByteData):
                        nb_bytes += 1
                except KeyError as e:
                    self.logger.error(f&#34;Could not find address {adr+nb_bytes} (${adr+nb_bytes:04X}) in {self.instructions.keys()}&#34;)
                    raise

                self.logger.debug(f&#34;{nb_bytes} bytes of data before instruction&#34;)
                if nb_bytes &gt; 8:

                    # manage the remaining bytes if not a multiple of 8
                    nb_rows = nb_bytes // 8 + 1 if nb_bytes % 8 != 0 else nb_bytes // 8

                    for row in range(nb_rows):

                        r_label = [k for k,v in self.labels.items() if v == adr+(row*8)]
                        s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                        s_address = f&#34;{adr+(row*8)-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                        bcode = &#34;&#34;
                        for b in range(min(8, nb_bytes-(8*row))):
                            bytedata = self.instructions[adr+(row*8)+b]
                            bcode += str(binascii.hexlify(self.get_bytecode(bytedata)))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()
                        bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                        bcode2 = &#39;$&#39;+&#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                        line = &#39; &#39;*100
                        if self.show_address:
                            line = _insert(line, s_address, code_template_index[&#34;address&#34;])
                        if self.show_bytecode:
                            line = _insert(line, bcode1, code_template_index[&#34;bytecode&#34;])

                        line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                        line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                        line.strip()
                        line  += &#39;\n&#39;

                        code.append(line)
                else:
                    s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                    s_label = f&#34;{label[0]}:&#34; if label else &#34;&#34;
                    bcode = &#34;&#34;
                    for b in range(nb_bytes):
                        bytedata = self.instructions[adr+b]
                        bcode += str(binascii.hexlify(self.get_bytecode(bytedata)))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()
                    bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                    bcode2 = &#39;$&#39;+&#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                    line = &#39; &#39;*100
                    if self.show_address:
                        line = _insert(line, s_address, code_template_index[&#34;address&#34;])
                    if self.show_bytecode:
                        line = _insert(line, bcode1, code_template_index[&#34;bytecode&#34;])

                    line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                    line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                    line.strip()
                    line  += &#39;\n&#39;

                    code.append(line)
        else:
            process_byte = True
            s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
            s_label = f&#34;{label[0]}:&#34; if label else &#34;&#34;

            bcode = str(binascii.hexlify(self.get_bytecode(instr)))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()    # remove leading &#39;b and trailing &#39;. Ex: bytearray(b&#39;\xa9\x0b&#39;) A90B
            bcode = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

            s_bytecode = f&#34;{bcode}&#34; if self.show_bytecode else &#34;&#34;

            cycles = instr.get_cycle_count()
            s_cycles = f&#34;{self.comment_char} {cycles}&#34; if self.show_cycles and cycles &gt; 0 else &#34;&#34;

            prefix = self.directive_prefix if isinstance(instr, ByteData) else &#39;&#39;

            line = &#39; &#39;*100
            line = _insert(line, s_address, code_template_index[&#34;address&#34;])
            line = _insert(line, s_bytecode, code_template_index[&#34;bytecode&#34;])
            line = _insert(line, s_label, code_template_index[&#34;label&#34;])
            line = _insert(line, f&#34;{prefix}{instr}&#34;, code_template_index[&#34;instruction&#34;])
            line = _insert(line, s_cycles, code_template_index[&#34;cycles&#34;])
            line.strip()
            line  += &#39;\n&#39;

            code.append(line)

    return code</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_address"><code class="name flex">
<span>def <span class="ident">get_address</span></span>(<span>self, label: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_address(self, label: str) -&gt; int:
    &#34;&#34;&#34;[summary]

    Args:
        label (str): [description]

    Raises:
        ValueError: [description]

    Returns:
        int: [description]
    &#34;&#34;&#34;
    if label not in self.labels:
        raise ValueError(f&#34;Cannot find label {label}&#34;)

    return self.labels[label]</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_anonymous_label"><code class="name flex">
<span>def <span class="ident">get_anonymous_label</span></span>(<span>self, prefix: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an anonymous label, in a macro for example</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_anonymous_label(self, prefix: str) -&gt; str:
    &#34;&#34;&#34;Generate an anonymous label, in a macro for example

    Args:
        prefix (str): [description]

    Returns:
        str: [description]
    &#34;&#34;&#34;
    if prefix not in self.anonymous_labels:
        self.anonymous_labels[prefix] = 0
    else:
        self.anonymous_labels[prefix] += 1

    return f&#34;_{prefix}_{self.anonymous_labels[prefix]}&#34;</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_bytecode"><code class="name flex">
<span>def <span class="ident">get_bytecode</span></span>(<span>self, instr: <a title="shazzam.Instruction.Instruction" href="Instruction.html#shazzam.Instruction.Instruction">Instruction</a>) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instr</code></strong> :&ensp;<code>Instruction</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytearray</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bytecode(self, instr: Instruction) -&gt; bytearray:
    &#34;&#34;&#34;[summary]

    Args:
        instr (Instruction): [description]

    Returns:
        bytearray: [description]
    &#34;&#34;&#34;
    ope = instr.get_operand()
    op = instr.get_opcode()

    if ope is not None:
        if instr.get_size() == 2+1:
            self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:04X}&#34;)
            data = [op, ope &amp; 0xff, (ope &gt;&gt; 8) &amp; 0xff]
        else:
            self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:02X}&#34;)
            data = [op, ope &amp; 0xff]
    else:
        self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X}&#34;)
        data = [instr.get_opcode()]

    self.logger.debug(f&#34;Got bytecode for {instr}: {data}&#34;)

    return bytearray(data)</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_last_instruction"><code class="name flex">
<span>def <span class="ident">get_last_instruction</span></span>(<span>self) ‑> <a title="shazzam.Instruction.Instruction" href="Instruction.html#shazzam.Instruction.Instruction">Instruction</a></span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Instruction</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_instruction(self) -&gt; Instruction:
    &#34;&#34;&#34;[summary]

    Returns:
        Instruction: [description]
    &#34;&#34;&#34;
    self.logger.debug(f&#34;Instructions in the current segment: {list(self.instructions.keys())}&#34;)
    return self.instructions[list(self.instructions.keys())[-1]]</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_segment_bytecode"><code class="name flex">
<span>def <span class="ident">get_segment_bytecode</span></span>(<span>self) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_segment_bytecode(self) -&gt; bytearray:

    self.resolve_labels()

    bytecode = bytearray([])
    for adr, instr in self.instructions.items():
        bytecode += self.get_bytecode(instr)

    return bytecode</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_stats"><code class="name flex">
<span>def <span class="ident">get_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stats(self):
    &#34;&#34;&#34;[summary]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    if len(self.instructions) == 0:
        raise RuntimeError(f&#34;No instruction in the segment!&#34;)

    last_instr = self.get_last_instruction()
    return {
        &#34;size&#34;: self.next_position - self.start_adr,
        &#34;cycles_used&#34;: self.total_cycles_used,
        &#34;instructions&#34;: len(self.instructions),
        &#34;start_address&#34;: hex(self.start_adr),
        &#34;current_address&#34;: hex(self.next_position),
        &#34;last_instruction&#34;: {
            &#34;code&#34;: str(last_instr),
            &#34;size&#34;: last_instr.get_size(),
            &#34;cycles&#34;: last_instr.get_cycle_count()
        }
    }</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.need_label"><code class="name flex">
<span>def <span class="ident">need_label</span></span>(<span>self, label: str, relative: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>relative</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def need_label(self, label: str, relative: bool = False) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        label (str): [description]
        relative (bool, optional): [description]. Defaults to False.
    &#34;&#34;&#34;
    self.required_labels[label] = {
        &#34;from&#34;: self.next_position,
        &#34;relative&#34;: relative
    }</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.resolve_labels"><code class="name flex">
<span>def <span class="ident">resolve_labels</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Replace all instructions with their absolute address.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_labels(self) -&gt; None:
    &#34;&#34;&#34;Replace all instructions with their absolute address.

    Raises:
        ValueError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    # check labels
    for label, params in self.required_labels.items():
        if (label not in self.labels) and (label not in g._PROGRAM.global_labels):
            print(&#34;global:&#34;, g._PROGRAM.global_labels)
            raise ValueError(f&#34;Label {label} is used but not defined locally or globally!&#34;)

        if params[&#39;relative&#39;] and abs(params[&#39;from&#39;] - self.labels[label]) &gt; 255:
            raise ValueError(f&#34;Label {label} branch at {params[&#39;from&#39;]} is more than 1 bytes!&#34;)

    # resolve labels now!
    for adr, instr in self.instructions.items():
        if instr.label:
            if instr.label in self.labels:

                if self.use_relative_addressing:

                    instr.value = self.labels[instr.label] - adr - instr.get_size() if adr &lt; self.labels[instr.label] else adr - self.labels[instr.label] - instr.get_size()
                    self.logger.info(f&#34;Use relative addressing to label {instr.label} at {self.labels[instr.label]:04X} from {adr:04X} will be: {instr.value}&#34;)

                else:
                    instr.value = self.labels[instr.label]

            elif instr.label in g._PROGRAM.global_labels:
                instr.value = g._PROGRAM.global_labels[instr.label]
            else:
                raise ValueError(f&#34;Label {label} cannot be resolved locally or globally!&#34;)

            self.logger.debug(f&#34;Label {instr.label} replaced by absolute address {instr.value:04X}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="shazzam" href="index.html">shazzam</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="shazzam.Segment.Segment" href="#shazzam.Segment.Segment">Segment</a></code></h4>
<ul class="">
<li><code><a title="shazzam.Segment.Segment.add_byte" href="#shazzam.Segment.Segment.add_byte">add_byte</a></code></li>
<li><code><a title="shazzam.Segment.Segment.add_instruction" href="#shazzam.Segment.Segment.add_instruction">add_instruction</a></code></li>
<li><code><a title="shazzam.Segment.Segment.add_label" href="#shazzam.Segment.Segment.add_label">add_label</a></code></li>
<li><code><a title="shazzam.Segment.Segment.add_rasterline" href="#shazzam.Segment.Segment.add_rasterline">add_rasterline</a></code></li>
<li><code><a title="shazzam.Segment.Segment.close" href="#shazzam.Segment.Segment.close">close</a></code></li>
<li><code><a title="shazzam.Segment.Segment.comments_chars" href="#shazzam.Segment.Segment.comments_chars">comments_chars</a></code></li>
<li><code><a title="shazzam.Segment.Segment.directive_prefix" href="#shazzam.Segment.Segment.directive_prefix">directive_prefix</a></code></li>
<li><code><a title="shazzam.Segment.Segment.emulate" href="#shazzam.Segment.Segment.emulate">emulate</a></code></li>
<li><code><a title="shazzam.Segment.Segment.gen_code" href="#shazzam.Segment.Segment.gen_code">gen_code</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_address" href="#shazzam.Segment.Segment.get_address">get_address</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_anonymous_label" href="#shazzam.Segment.Segment.get_anonymous_label">get_anonymous_label</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_bytecode" href="#shazzam.Segment.Segment.get_bytecode">get_bytecode</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_last_instruction" href="#shazzam.Segment.Segment.get_last_instruction">get_last_instruction</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_segment_bytecode" href="#shazzam.Segment.Segment.get_segment_bytecode">get_segment_bytecode</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_stats" href="#shazzam.Segment.Segment.get_stats">get_stats</a></code></li>
<li><code><a title="shazzam.Segment.Segment.need_label" href="#shazzam.Segment.Segment.need_label">need_label</a></code></li>
<li><code><a title="shazzam.Segment.Segment.resolve_labels" href="#shazzam.Segment.Segment.resolve_labels">resolve_labels</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>