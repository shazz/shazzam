<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>shazzam.py64gen API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>shazzam.py64gen</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from time import sleep
from contextlib import contextmanager
import hashlib
import os
import dill

from reloading import reloading

import shazzam.globals as g
from shazzam.Instruction import Instruction
from shazzam.defs import *
from shazzam.Rasterline import Rasterline
from shazzam.Segment import Segment
from shazzam.Address import Address
from shazzam.Immediate import Immediate
from shazzam.Cruncher import Cruncher
from shazzam.Assembler import Assembler
import enum
from typing import List, Any, Dict


# ---------------------------------------------------------------------
# py64gen public functions
# ---------------------------------------------------------------------
def set_prefs(default_code_segment: str, code_format: List[CodeFormat], comments_format: CommentsFormat, directive_prefix: DirectiveFormat):
    global _CODE_FORMAT, _COMMENTS_FORMAT, _DIRECTIVE_PREFIX

    g._CODE_FORMAT = code_format
    g._COMMENTS_FORMAT = comments_format
    g._DIRECTIVE_PREFIX = directive_prefix
    g._DEFAULT_CODE_SEGMENT = default_code_segment

@contextmanager
def segment(start_adr: int, name: str, use_relative_addressing: bool = False, check_address_dups: bool = True) -&gt; Segment:
    &#34;&#34;&#34;[summary]

    Args:
        start_adr (int): [description]
        name (str): [description]
        gen_files (bool, optional): [description]. Defaults to True.

    Returns:
        Segment: [description]

    Yields:
        Iterator[Segment]: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT, _PROGRAM

    seg = Segment(start_adr=start_adr, name=name.upper(), use_relative_addressing=use_relative_addressing)
    g._CURRENT_CONTEXT = seg

    yield seg

    found = False
    for segment in g._PROGRAM.segments:

        # check segments with same base address
        if segment.start_adr == start_adr and segment.name != seg.name and check_address_dups:
            raise ValueError(f&#34;Multiple segments have the same start address {start_adr:04X}: {segment.name} and {seg.name}&#34;)

        # else
        if segment.start_adr == start_adr and segment.name == seg.name:
            found = True

            g.logger.debug(f&#34;Removing segment {segment.name} to PROGRAM&#34;)
            g._PROGRAM.segments.remove(segment)

            g.logger.debug(f&#34;Adding segment {segment.name} to PROGRAM&#34;)
            g._PROGRAM.segments.append(seg)

            break

    if not found:
        g.logger.debug(f&#34;Adding new segment {seg.name} to PROGRAM&#34;)
        g._PROGRAM.segments.append(seg)

    g._CURRENT_CONTEXT.close()
    g._CURRENT_CONTEXT = None

@contextmanager
def rasterline(system: System = System.PAL, mode: DetectMode = DetectMode.MANUAL, nb_sprites: int = 8, y_pos: int = 0, y_scroll: int = 0) -&gt; Rasterline:
    &#34;&#34;&#34;[summary]

    Args:
        system (System, optional): [description]. Defaults to System.PAL.
        mode (DetectMode, optional): [description]. Defaults to DetectMode.MANUAL.
        nb_sprites (int, optional): [description]. Defaults to 8.
        y_pos (int, optional): [description]. Defaults to 0.
        y_scroll (int, optional): [description]. Defaults to 0.

    Returns:
        Rasterline: [description]

    Yields:
        Iterator[Rasterline]: [description]
    &#34;&#34;&#34;
    global _CURRENT_RASTER, _PROGRAM, _CURRENT_CONTEXT

    line = Rasterline(system, mode, nb_sprites, y_pos, y_scroll)
    g._CURRENT_RASTER = line

    yield line

    # seg = _CURRENT_CONTEXT

    g._CURRENT_RASTER.close()
    g._CURRENT_RASTER = None

def gen_code(header: str = None, prefs: Alias = None) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        header (str, optional): [description]. Defaults to None.
    &#34;&#34;&#34;
    global _PROGRAM

    overlaps = _check_segments_ovelap()

    if header is None:
        header  = &#34;; Generated code using Shazzam py64gen\n&#34;
        header += &#34;; Copyright (C) 2021 TRSi\n&#34;
        header += &#34;; \n&#34;
        header += &#34;; https://github.com/shazz/shazzam\n\n&#34;

    if prefs:
        g.logger.debug(f&#34;Setting assembler pref: {prefs}&#34;)
        set_prefs(default_code_segment=prefs.default_code_segment, code_format=prefs.code, comments_format=prefs.comments, directive_prefix=prefs.directive)

    for segment in g._PROGRAM.segments:

        g.logger.debug(f&#34;generating code for segment {segment.name} from {g._PROGRAM.segments}&#34;)
        segment.change_format()
        code = segment.gen_code()

        if code:
            os.makedirs(f&#34;generated/{g._PROGRAM.name}&#34;, exist_ok = True)
            with open(f&#34;generated/{g._PROGRAM.name}/{segment.name}.asm&#34;, &#34;w&#34;) as f:
                f.writelines(header)
                f.writelines(code)

def gen_listing(header: str = None) -&gt; None:
    &#34;&#34;&#34;[summary] gen_listing

    Args:
        header (str, optional): [description]. Defaults to None.
    &#34;&#34;&#34;
    global _PROGRAM

    if header is None:
        header  = &#34;; Generated listing using Shazzam py64gen\n&#34;
        header += &#34;; Copyright (C) 2021 TRSi\n&#34;
        header += &#34;; \n&#34;
        header += &#34;; https://github.com/shazz/shazzam\n\n&#34;

    prefs = Alias( {
            &#34;default_code_segment&#34;: &#34;CODE&#34;,
            &#34;code&#34;: [CodeFormat.USE_HEX, CodeFormat.BYTECODE, CodeFormat.ADDRESS, CodeFormat.SHOW_LABELS],
            &#34;comments&#34;: CommentsFormat.USE_SEMICOLON,
            &#34;directive&#34;: DirectiveFormat.USE_DOT
        })
    set_prefs(default_code_segment=prefs.default_code_segment, code_format=prefs.code, comments_format=prefs.comments, directive_prefix=prefs.directive)

    for segment in g._PROGRAM.segments:

        segment.change_format()
        code = segment.gen_code()

        if code:
            os.makedirs(f&#34;generated/{g._PROGRAM.name}&#34;, exist_ok = True)
            with open(f&#34;generated/{g._PROGRAM.name}/{segment.name}.lst&#34;, &#34;w&#34;) as f:
                f.writelines(header)
                f.writelines(code)

def assemble_segment(assembler: Assembler) -&gt; None:
    &#34;&#34;&#34;Assemble segment

    Args:
        assembler ([type]): [description]
        cruncher (None): [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT, _PROGRAM

    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    output_file = assembler.assemble_segment(g._PROGRAM, g._CURRENT_CONTEXT)

    return output_file

def assemble_prg(assembler: Assembler, start_address: int, cruncher: Cruncher = None) -&gt; None:
    &#34;&#34;&#34;Assemble listing

    Args:
        assembler ([type]): [description]
        start_address (int): [description]
        cruncher (None): [description]
    &#34;&#34;&#34;
    global _PROGRAM

    output_file = assembler.assemble_prg(g._PROGRAM, start_address)

    if cruncher is not None:
        try:
            cruncher.crunch_prg(output_file)
        except AttributeError as e:
            g.logger.error(f&#34;The cruncher class {cruncher.__class__} needs to implement crunch_prg()!&#34;)
            g.logger.error(e)

def get_segment_addresses(name: str) -&gt; int:
    &#34;&#34;&#34;get_segment_start_address

    Args:
        name (str): [description]

    Raises:
        ValueError: [description]

    Returns:
        int: [description]
    &#34;&#34;&#34;
    global _PROGRAM

    # import threading
    # x = threading.Thread(target=_watch_segment, args=(name,))

    #TODO: how to make this works if a segment is defined after this call ?
    for segment in g._PROGRAM.segments:

        if segment.name.upper() == name.upper():
            return Alias({
                &#34;start_address&#34;: segment.start_adr,
                &#34;end_address&#34;: segment.end_adr
            })

    raise ValueError(f&#34;Segment {name} not (yet?) found!&#34;)

# def _watch_segment(name):
#     import time
#     print(f&#34;Looking for segment {name}&#34;)

#     not_found = True

#     while not_found:
#         for segment in g._PROGRAM.segments:
#             if segment.name.upper() == name.upper():
#                 info = Alias({
#                     &#34;start_address&#34;: segment.start_adr,
#                     &#34;end_address&#34;: segment.end_adr
#                 })
#                 not_found = False
#                 break
#         time.sleep(1)

#     return info

def gen_irqloader_script(irqloader, parts_definition: Dict):
    &#34;&#34;&#34;gen_irqloader_script

    Args:
        irqloader ([type]): [description]
        parts_definition (Dict): [description]

    Raises:
        NotImplementedError: [description]
    &#34;&#34;&#34;
    global _PROGRAM

    for segment in _PROGRAM:

        if code:
            raise NotImplementedError()

# ---------------------------------------------------------------------
# Assembler directives
# ---------------------------------------------------------------------
def at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value)
    elif isinstance(value, int):
        return Address(value=value)
    else:
        raise ValueError(&#34;Address must be an int or a non empty string&#34;)

def ind_at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value, indirect=True)
    elif isinstance(value, int):
        return Address(value=value, indirect=True)
    else:
        raise ValueError(&#34;Address must be an int or a non empty string&#34;)

def rel_at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value)
    elif isinstance(value, int):
        rel_address = (value - (get_current_address() + 2)) &amp; 0xff
        g.logger.debug(f&#34;Relative address: {value:04X} - ({get_current_address():04X}+2) = {rel_address:04X}&#34;)

        if rel_address &gt; 0xff:
            raise ValueError(f&#34;Relative address cannot be bigger than a byte: {get_current_address():04X} - {value:04X} = {rel_address:04X}&#34;)

        return Address(value=value, relative=rel_address)
    else:
        raise ValueError(&#34;Relative address must be an int or a non empty string&#34;)

def imm(value: Any) -&gt; Immediate:
    if isinstance(value, str):
        if value.startswith(&#39;&gt;&#39;):
            return Immediate(name=value[1:], high_byte=True)
        elif value.startswith(&#39;&lt;&#39;):
            return Immediate(name=value[1:], high_byte=False)
        else:
            raise ValueError(f&#34;Low byte (&lt;) or High byte (&gt;) must be specified. Not {value}&#34;)

    elif isinstance(value, int):
        return Immediate(value=value)
    else:
        raise ValueError(&#34;Immediate must be an int or a string&#34;)

def label(name: str, is_global: bool = False) -&gt; Address:
    &#34;&#34;&#34;[summary]

    Args:
        name (str): [description]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    if name == None or len(name) == 0:
        raise ValueError(f&#34;Label cannot be empty&#34;)

    label: Address = g._CURRENT_CONTEXT.add_label(name)

    if is_global:
        g._PROGRAM.add_label(label)
        # TODO: generate include file? with globals addresses ?

    return label

def get_anonymous_label(name: str) -&gt; str:
    &#34;&#34;&#34;[summary]

    Args:
        name (str): [description]

    Raises:
        RuntimeError: [description]

    Returns:
        str: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    return g._CURRENT_CONTEXT.get_anonymous_label(name)

def byte(value: Any) -&gt; bytearray:

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    bcode = None
    if isinstance(value, str):
        if value.startswith(&#39;&gt;&#39;):
            return g._CURRENT_CONTEXT.add_byte(Immediate(name=value[1:], high_byte=True))
        elif value.startswith(&#39;&lt;&#39;):
            return g._CURRENT_CONTEXT.add_byte(Immediate(name=value[1:], high_byte=False))
        else:
            g.logger.warning(f&#34;Low byte (&lt;) or High byte (&gt;) not specified. Considering this is a character string&#34;)

            ret_array = []
            for v in value:
                ret_array.append(g._CURRENT_CONTEXT.add_byte(Immediate(value=ord(v))))

            return ret_array

    elif isinstance(value, int):
        return g._CURRENT_CONTEXT.add_byte(Immediate(value=value))

    elif isinstance(value, list):
        ret_array = []
        for v in value:
            ret_array.append(g._CURRENT_CONTEXT.add_byte(Immediate(value=v)))
        return bytearray(ret_array)
    else:
        raise ValueError(&#34;Immediate must be an int or a string&#34;)


def word(value: int, label: str) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        value (int): [description]
        label (str): [description]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    if value &gt; 0xffff:
        raise ValueError(f&#34;Value exceed word size: {value}&#34;)

    g._CURRENT_CONTEXT.add_word(value, label)

def incbin(data: bytearray) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        data (bytearray): [description]

    Raises:
        RuntimeError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    if data is not None:
        if not isinstance(data, bytearray):
            raise ValueError(f&#34;incbin argument muust be a bytearray and not a {type(data)}&#34;)

        for b in data:
            g._CURRENT_CONTEXT.add_byte(Immediate(value=b))

def get_current_address() -&gt; int:

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    return g._CURRENT_CONTEXT.next_position

# ---------------------------------------------------------------------
# Utils
# ---------------------------------------------------------------------
_funcs = {}
def generate(func, program_name: str) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        func ([type]): [description]
    &#34;&#34;&#34;
    global _PROGRAM
    g._PROGRAM.set_name(program_name)

    for i in reloading(range(10)):
        src = dill.source.getsource(func.__dict__[&#39;__inner__&#39;])
        # src = dill.source.getsource(func)
        h = hashlib.md5(src.encode()).hexdigest()

        if func.__name__ not in _funcs:
            _funcs[func.__name__] = h
            func()
        else:
            if _funcs[func.__name__] != h:
                _funcs[func.__name__] = h
                func()

        sleep(1.0)
    generate(func, program_name)

def _create_a_function(*args, **kwargs):
    &#34;&#34;&#34;[summary]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
        NotImplementedError: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    mnemonic = kwargs[&#39;mnemonic&#39;]
    g.logger.debug(f&#39;creating wrapper for {mnemonic}&#39;)
    modes = []

    opcode_found = False
    for opcode in Instruction.opcodes:
        if opcode[0] == mnemonic:
            modes.append(opcode[1])
            opcode_found = True

    if not opcode_found:
        raise ValueError(f&#34;Opcode {mnemonic} doesn&#39;t exist!&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Opcode can&#39;t have more than 2 operands!&#34;)

    def function_template(*args, **kwargs):

        global _CURRENT_CONTEXT
        if g._CURRENT_CONTEXT is None:
            raise RuntimeError(f&#34;No segment defined!&#34;)

        address = None
        immediate = None
        index = None

        if len(args) &gt; 0:
            if isinstance(args[0], Address):
                address = args[0]
            elif isinstance(args[0], Immediate):
                immediate = args[0]
            elif isinstance(args[0], enum.EnumMeta):
                index = args[0]
            else:
                raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

        if len(args) == 2:
            index = args[1]
            if not isinstance(index, enum.EnumMeta):
                raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

        if len(args) &gt; 2:
            raise ValueError(f&#34;Too many arguments!&#34;)

        g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

        try:
            if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

            if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

            if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
                if address.value is not None:
                    if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                    elif address.value &gt; 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
                else:
                    adr = g._CURRENT_CONTEXT.need_label(address.name)
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

            if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
                if address.value is not None:
                    if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                    elif address.value &gt; 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
                else:
                    adr = g._CURRENT_CONTEXT.need_label(address.name)
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

            if &#39;abs&#39; in modes and index is None and address and not address.indirect:
                if address.value is not None:
                    if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                    elif address.value &gt;= 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
                else:
                    adr = g._CURRENT_CONTEXT.need_label(address.name)
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

            if &#39;rel&#39; in modes:
                if address.relative is not None:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
                else:
                    adr = g._CURRENT_CONTEXT.need_label(address.name)
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

            if &#39;imm&#39; in modes and immediate is not None:
                if immediate.value is None:
                    adr = g._CURRENT_CONTEXT.need_label(immediate.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

            if &#39;imp&#39; in modes:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

            if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
                if address.value and address.value &lt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

            if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
                if address.value and address.value &lt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

            if &#39;acc&#39; in modes and index is RegisterACC:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

            if &#39;ind&#39; in modes:
                if address.value :
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
                else:
                    adr = g._CURRENT_CONTEXT.need_label(address.name)
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
        except Exception as e:
            import inspect
            callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

            frame = callerframerecord[0]
            info = inspect.getframeinfo(frame)
            print(info)

            raise

        raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)

    return function_template

# ---------------------------------------------------------------------
# Opcodes wrappers
# ---------------------------------------------------------------------


g.initialize()

ADC     = _create_a_function(mnemonic=&#34;adc&#34;)
AND = _create_a_function(mnemonic=&#34;and&#34;)
ASL     = _create_a_function(mnemonic=&#34;asl&#34;)
BCC     = _create_a_function(mnemonic=&#34;bcc&#34;)
BCS     = _create_a_function(mnemonic=&#34;bcs&#34;)
BEQ     = _create_a_function(mnemonic=&#34;beq&#34;)
BIT     = _create_a_function(mnemonic=&#34;bit&#34;)
BMI     = _create_a_function(mnemonic=&#34;bmi&#34;)
BNE     = _create_a_function(mnemonic=&#34;bne&#34;)
BPL     = _create_a_function(mnemonic=&#34;bpl&#34;)
BRK     = _create_a_function(mnemonic=&#34;brk&#34;)
BVC     = _create_a_function(mnemonic=&#34;bvc&#34;)
BVS     = _create_a_function(mnemonic=&#34;bvs&#34;)
CLC     = _create_a_function(mnemonic=&#34;clc&#34;)
CLD     = _create_a_function(mnemonic=&#34;cld&#34;)
CLI     = _create_a_function(mnemonic=&#34;cli&#34;)
CLV     = _create_a_function(mnemonic=&#34;clv&#34;)
CMP     = _create_a_function(mnemonic=&#34;cmp&#34;)
CPX     = _create_a_function(mnemonic=&#34;cpx&#34;)
CPY     = _create_a_function(mnemonic=&#34;cpy&#34;)
DEC     = _create_a_function(mnemonic=&#34;dec&#34;)
DEX     = _create_a_function(mnemonic=&#34;dex&#34;)
DEY     = _create_a_function(mnemonic=&#34;dey&#34;)
EOR     = _create_a_function(mnemonic=&#34;eor&#34;)
INC     = _create_a_function(mnemonic=&#34;inc&#34;)
INX     = _create_a_function(mnemonic=&#34;inx&#34;)
INY     = _create_a_function(mnemonic=&#34;iny&#34;)
JMP     = _create_a_function(mnemonic=&#34;jmp&#34;)
JSR     = _create_a_function(mnemonic=&#34;jsr&#34;)
LDA     = _create_a_function(mnemonic=&#34;lda&#34;)
LDX     = _create_a_function(mnemonic=&#34;ldx&#34;)
LDY     = _create_a_function(mnemonic=&#34;ldy&#34;)
LSR     = _create_a_function(mnemonic=&#34;lsr&#34;)
NOP     = _create_a_function(mnemonic=&#34;nop&#34;)
ORA     = _create_a_function(mnemonic=&#34;ora&#34;)
PHA     = _create_a_function(mnemonic=&#34;pha&#34;)
PHP     = _create_a_function(mnemonic=&#34;php&#34;)
PLA     = _create_a_function(mnemonic=&#34;pla&#34;)
PLP     = _create_a_function(mnemonic=&#34;plp&#34;)
ROL     = _create_a_function(mnemonic=&#34;rol&#34;)
ROR     = _create_a_function(mnemonic=&#34;ror&#34;)
RTI     = _create_a_function(mnemonic=&#34;rti&#34;)
RTS     = _create_a_function(mnemonic=&#34;rts&#34;)
SBC     = _create_a_function(mnemonic=&#34;sbc&#34;)
SEC     = _create_a_function(mnemonic=&#34;sec&#34;)
SED     = _create_a_function(mnemonic=&#34;sed&#34;)
SEI     = _create_a_function(mnemonic=&#34;sei&#34;)
STA     = _create_a_function(mnemonic=&#34;sta&#34;)
STX     = _create_a_function(mnemonic=&#34;stx&#34;)
STY     = _create_a_function(mnemonic=&#34;sty&#34;)
TAX     = _create_a_function(mnemonic=&#34;tax&#34;)
TAY     = _create_a_function(mnemonic=&#34;tay&#34;)
TSX     = _create_a_function(mnemonic=&#34;tsx&#34;)
TXA     = _create_a_function(mnemonic=&#34;txa&#34;)
TXS     = _create_a_function(mnemonic=&#34;txs&#34;)
TYA     = _create_a_function(mnemonic=&#34;tya&#34;)

adc     = _create_a_function(mnemonic=&#34;adc&#34;)
andr = _create_a_function(mnemonic=&#34;and&#34;)
asl     = _create_a_function(mnemonic=&#34;asl&#34;)
bcc     = _create_a_function(mnemonic=&#34;bcc&#34;)
bcs     = _create_a_function(mnemonic=&#34;bcs&#34;)
beq     = _create_a_function(mnemonic=&#34;beq&#34;)
bit     = _create_a_function(mnemonic=&#34;bit&#34;)
bmi     = _create_a_function(mnemonic=&#34;bmi&#34;)
bne     = _create_a_function(mnemonic=&#34;bne&#34;)
bpl     = _create_a_function(mnemonic=&#34;bpl&#34;)
brk     = _create_a_function(mnemonic=&#34;brk&#34;)
bvc     = _create_a_function(mnemonic=&#34;bvc&#34;)
bvs     = _create_a_function(mnemonic=&#34;bvs&#34;)
clc     = _create_a_function(mnemonic=&#34;clc&#34;)
cld     = _create_a_function(mnemonic=&#34;cld&#34;)
cli     = _create_a_function(mnemonic=&#34;cli&#34;)
clv     = _create_a_function(mnemonic=&#34;clv&#34;)
cmp     = _create_a_function(mnemonic=&#34;cmp&#34;)
cpx     = _create_a_function(mnemonic=&#34;cpx&#34;)
cpy     = _create_a_function(mnemonic=&#34;cpy&#34;)
dec     = _create_a_function(mnemonic=&#34;dec&#34;)
dex     = _create_a_function(mnemonic=&#34;dex&#34;)
dey     = _create_a_function(mnemonic=&#34;dey&#34;)
eor     = _create_a_function(mnemonic=&#34;eor&#34;)
inc     = _create_a_function(mnemonic=&#34;inc&#34;)
inx     = _create_a_function(mnemonic=&#34;inx&#34;)
iny     = _create_a_function(mnemonic=&#34;iny&#34;)
jmp     = _create_a_function(mnemonic=&#34;jmp&#34;)
jsr     = _create_a_function(mnemonic=&#34;jsr&#34;)
lda     = _create_a_function(mnemonic=&#34;lda&#34;)
ldx     = _create_a_function(mnemonic=&#34;ldx&#34;)
ldy     = _create_a_function(mnemonic=&#34;ldy&#34;)
lsr     = _create_a_function(mnemonic=&#34;lsr&#34;)
nop     = _create_a_function(mnemonic=&#34;nop&#34;)
ora     = _create_a_function(mnemonic=&#34;ora&#34;)
pha     = _create_a_function(mnemonic=&#34;pha&#34;)
php     = _create_a_function(mnemonic=&#34;php&#34;)
pla     = _create_a_function(mnemonic=&#34;pla&#34;)
plp     = _create_a_function(mnemonic=&#34;plp&#34;)
rol     = _create_a_function(mnemonic=&#34;rol&#34;)
ror     = _create_a_function(mnemonic=&#34;ror&#34;)
rti     = _create_a_function(mnemonic=&#34;rti&#34;)
rts     = _create_a_function(mnemonic=&#34;rts&#34;)
sbc     = _create_a_function(mnemonic=&#34;sbc&#34;)
sec     = _create_a_function(mnemonic=&#34;sec&#34;)
sed     = _create_a_function(mnemonic=&#34;sed&#34;)
sei     = _create_a_function(mnemonic=&#34;sei&#34;)
sta     = _create_a_function(mnemonic=&#34;sta&#34;)
stx     = _create_a_function(mnemonic=&#34;stx&#34;)
sty     = _create_a_function(mnemonic=&#34;sty&#34;)
tax     = _create_a_function(mnemonic=&#34;tax&#34;)
tay     = _create_a_function(mnemonic=&#34;tay&#34;)
tsx     = _create_a_function(mnemonic=&#34;tsx&#34;)
txa     = _create_a_function(mnemonic=&#34;txa&#34;)
txs     = _create_a_function(mnemonic=&#34;txs&#34;)
tya     = _create_a_function(mnemonic=&#34;tya&#34;)

# -----------------------------------------------------------
# Private functions
# -----------------------------------------------------------

def _check_segments_ovelap(code_segment: str = &#34;CODE&#34;) -&gt; None:

    intervals = []
    for segment in g._PROGRAM.segments:
        if segment.name == code_segment:
            intervals.append((segment.start_adr, segment.end_adr+13))   # adding basic header 13 bytes
        else:
            intervals.append((segment.start_adr, segment.end_adr))

    intervals.sort()
    g.logger.info(f&#34;Checking overlapping intervals: {[(hex(interval[0]), hex(interval[1])) for interval in intervals]}&#34;)

    for i in range(1, len(intervals)):
        if intervals[i][0] &lt;= intervals[i-1][1]:
            raise ValueError(f&#34;The segments {g._PROGRAM.segments[i-1].name} and {g._PROGRAM.segments[i].name} overlap!&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="shazzam.py64gen.ADC"><code class="name flex">
<span>def <span class="ident">ADC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.AND"><code class="name flex">
<span>def <span class="ident">AND</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ASL"><code class="name flex">
<span>def <span class="ident">ASL</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BCC"><code class="name flex">
<span>def <span class="ident">BCC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BCS"><code class="name flex">
<span>def <span class="ident">BCS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BEQ"><code class="name flex">
<span>def <span class="ident">BEQ</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BIT"><code class="name flex">
<span>def <span class="ident">BIT</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BMI"><code class="name flex">
<span>def <span class="ident">BMI</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BNE"><code class="name flex">
<span>def <span class="ident">BNE</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BPL"><code class="name flex">
<span>def <span class="ident">BPL</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BRK"><code class="name flex">
<span>def <span class="ident">BRK</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BVC"><code class="name flex">
<span>def <span class="ident">BVC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BVS"><code class="name flex">
<span>def <span class="ident">BVS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CLC"><code class="name flex">
<span>def <span class="ident">CLC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CLD"><code class="name flex">
<span>def <span class="ident">CLD</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CLI"><code class="name flex">
<span>def <span class="ident">CLI</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CLV"><code class="name flex">
<span>def <span class="ident">CLV</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CMP"><code class="name flex">
<span>def <span class="ident">CMP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CPX"><code class="name flex">
<span>def <span class="ident">CPX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CPY"><code class="name flex">
<span>def <span class="ident">CPY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.DEC"><code class="name flex">
<span>def <span class="ident">DEC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.DEX"><code class="name flex">
<span>def <span class="ident">DEX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.DEY"><code class="name flex">
<span>def <span class="ident">DEY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.EOR"><code class="name flex">
<span>def <span class="ident">EOR</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.INC"><code class="name flex">
<span>def <span class="ident">INC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.INX"><code class="name flex">
<span>def <span class="ident">INX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.INY"><code class="name flex">
<span>def <span class="ident">INY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.JMP"><code class="name flex">
<span>def <span class="ident">JMP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.JSR"><code class="name flex">
<span>def <span class="ident">JSR</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.LDA"><code class="name flex">
<span>def <span class="ident">LDA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.LDX"><code class="name flex">
<span>def <span class="ident">LDX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.LDY"><code class="name flex">
<span>def <span class="ident">LDY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.LSR"><code class="name flex">
<span>def <span class="ident">LSR</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.NOP"><code class="name flex">
<span>def <span class="ident">NOP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ORA"><code class="name flex">
<span>def <span class="ident">ORA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.PHA"><code class="name flex">
<span>def <span class="ident">PHA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.PHP"><code class="name flex">
<span>def <span class="ident">PHP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.PLA"><code class="name flex">
<span>def <span class="ident">PLA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.PLP"><code class="name flex">
<span>def <span class="ident">PLP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ROL"><code class="name flex">
<span>def <span class="ident">ROL</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ROR"><code class="name flex">
<span>def <span class="ident">ROR</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.RTI"><code class="name flex">
<span>def <span class="ident">RTI</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.RTS"><code class="name flex">
<span>def <span class="ident">RTS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SBC"><code class="name flex">
<span>def <span class="ident">SBC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SEC"><code class="name flex">
<span>def <span class="ident">SEC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SED"><code class="name flex">
<span>def <span class="ident">SED</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SEI"><code class="name flex">
<span>def <span class="ident">SEI</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.STA"><code class="name flex">
<span>def <span class="ident">STA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.STX"><code class="name flex">
<span>def <span class="ident">STX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.STY"><code class="name flex">
<span>def <span class="ident">STY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TAX"><code class="name flex">
<span>def <span class="ident">TAX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TAY"><code class="name flex">
<span>def <span class="ident">TAY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TSX"><code class="name flex">
<span>def <span class="ident">TSX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TXA"><code class="name flex">
<span>def <span class="ident">TXA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TXS"><code class="name flex">
<span>def <span class="ident">TXS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TYA"><code class="name flex">
<span>def <span class="ident">TYA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.adc"><code class="name flex">
<span>def <span class="ident">adc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.andr"><code class="name flex">
<span>def <span class="ident">andr</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.asl"><code class="name flex">
<span>def <span class="ident">asl</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.assemble_prg"><code class="name flex">
<span>def <span class="ident">assemble_prg</span></span>(<span>assembler:<a title="shazzam.Assembler.Assembler" href="Assembler.html#shazzam.Assembler.Assembler">Assembler</a>, start_address:int, cruncher:<a title="shazzam.Cruncher.Cruncher" href="Cruncher.html#shazzam.Cruncher.Cruncher">Cruncher</a>=None) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Assemble listing</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>assembler</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>start_address</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>cruncher</code></strong> :&ensp;<code>None</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assemble_prg(assembler: Assembler, start_address: int, cruncher: Cruncher = None) -&gt; None:
    &#34;&#34;&#34;Assemble listing

    Args:
        assembler ([type]): [description]
        start_address (int): [description]
        cruncher (None): [description]
    &#34;&#34;&#34;
    global _PROGRAM

    output_file = assembler.assemble_prg(g._PROGRAM, start_address)

    if cruncher is not None:
        try:
            cruncher.crunch_prg(output_file)
        except AttributeError as e:
            g.logger.error(f&#34;The cruncher class {cruncher.__class__} needs to implement crunch_prg()!&#34;)
            g.logger.error(e)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.assemble_segment"><code class="name flex">
<span>def <span class="ident">assemble_segment</span></span>(<span>assembler:<a title="shazzam.Assembler.Assembler" href="Assembler.html#shazzam.Assembler.Assembler">Assembler</a>) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Assemble segment</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>assembler</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>cruncher</code></strong> :&ensp;<code>None</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assemble_segment(assembler: Assembler) -&gt; None:
    &#34;&#34;&#34;Assemble segment

    Args:
        assembler ([type]): [description]
        cruncher (None): [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT, _PROGRAM

    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    output_file = assembler.assemble_segment(g._PROGRAM, g._CURRENT_CONTEXT)

    return output_file</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>value:Any) ><a title="shazzam.Address.Address" href="Address.html#shazzam.Address.Address">Address</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value)
    elif isinstance(value, int):
        return Address(value=value)
    else:
        raise ValueError(&#34;Address must be an int or a non empty string&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bcc"><code class="name flex">
<span>def <span class="ident">bcc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bcs"><code class="name flex">
<span>def <span class="ident">bcs</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.beq"><code class="name flex">
<span>def <span class="ident">beq</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bit"><code class="name flex">
<span>def <span class="ident">bit</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bmi"><code class="name flex">
<span>def <span class="ident">bmi</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bne"><code class="name flex">
<span>def <span class="ident">bne</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bpl"><code class="name flex">
<span>def <span class="ident">bpl</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.brk"><code class="name flex">
<span>def <span class="ident">brk</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bvc"><code class="name flex">
<span>def <span class="ident">bvc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bvs"><code class="name flex">
<span>def <span class="ident">bvs</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.byte"><code class="name flex">
<span>def <span class="ident">byte</span></span>(<span>value:Any) >bytearray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def byte(value: Any) -&gt; bytearray:

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    bcode = None
    if isinstance(value, str):
        if value.startswith(&#39;&gt;&#39;):
            return g._CURRENT_CONTEXT.add_byte(Immediate(name=value[1:], high_byte=True))
        elif value.startswith(&#39;&lt;&#39;):
            return g._CURRENT_CONTEXT.add_byte(Immediate(name=value[1:], high_byte=False))
        else:
            g.logger.warning(f&#34;Low byte (&lt;) or High byte (&gt;) not specified. Considering this is a character string&#34;)

            ret_array = []
            for v in value:
                ret_array.append(g._CURRENT_CONTEXT.add_byte(Immediate(value=ord(v))))

            return ret_array

    elif isinstance(value, int):
        return g._CURRENT_CONTEXT.add_byte(Immediate(value=value))

    elif isinstance(value, list):
        ret_array = []
        for v in value:
            ret_array.append(g._CURRENT_CONTEXT.add_byte(Immediate(value=v)))
        return bytearray(ret_array)
    else:
        raise ValueError(&#34;Immediate must be an int or a string&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.clc"><code class="name flex">
<span>def <span class="ident">clc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.cld"><code class="name flex">
<span>def <span class="ident">cld</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.cli"><code class="name flex">
<span>def <span class="ident">cli</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.clv"><code class="name flex">
<span>def <span class="ident">clv</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.cpx"><code class="name flex">
<span>def <span class="ident">cpx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.cpy"><code class="name flex">
<span>def <span class="ident">cpy</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.dec"><code class="name flex">
<span>def <span class="ident">dec</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.dex"><code class="name flex">
<span>def <span class="ident">dex</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.dey"><code class="name flex">
<span>def <span class="ident">dey</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.eor"><code class="name flex">
<span>def <span class="ident">eor</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.gen_code"><code class="name flex">
<span>def <span class="ident">gen_code</span></span>(<span>header:str=None, prefs:<a title="shazzam.defs.Alias" href="defs.html#shazzam.defs.Alias">Alias</a>=None) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>header</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_code(header: str = None, prefs: Alias = None) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        header (str, optional): [description]. Defaults to None.
    &#34;&#34;&#34;
    global _PROGRAM

    overlaps = _check_segments_ovelap()

    if header is None:
        header  = &#34;; Generated code using Shazzam py64gen\n&#34;
        header += &#34;; Copyright (C) 2021 TRSi\n&#34;
        header += &#34;; \n&#34;
        header += &#34;; https://github.com/shazz/shazzam\n\n&#34;

    if prefs:
        g.logger.debug(f&#34;Setting assembler pref: {prefs}&#34;)
        set_prefs(default_code_segment=prefs.default_code_segment, code_format=prefs.code, comments_format=prefs.comments, directive_prefix=prefs.directive)

    for segment in g._PROGRAM.segments:

        g.logger.debug(f&#34;generating code for segment {segment.name} from {g._PROGRAM.segments}&#34;)
        segment.change_format()
        code = segment.gen_code()

        if code:
            os.makedirs(f&#34;generated/{g._PROGRAM.name}&#34;, exist_ok = True)
            with open(f&#34;generated/{g._PROGRAM.name}/{segment.name}.asm&#34;, &#34;w&#34;) as f:
                f.writelines(header)
                f.writelines(code)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.gen_irqloader_script"><code class="name flex">
<span>def <span class="ident">gen_irqloader_script</span></span>(<span>irqloader, parts_definition:Dict)</span>
</code></dt>
<dd>
<div class="desc"><p>gen_irqloader_script</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>irqloader</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>parts_definition</code></strong> :&ensp;<code>Dict</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_irqloader_script(irqloader, parts_definition: Dict):
    &#34;&#34;&#34;gen_irqloader_script

    Args:
        irqloader ([type]): [description]
        parts_definition (Dict): [description]

    Raises:
        NotImplementedError: [description]
    &#34;&#34;&#34;
    global _PROGRAM

    for segment in _PROGRAM:

        if code:
            raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.gen_listing"><code class="name flex">
<span>def <span class="ident">gen_listing</span></span>(<span>header:str=None) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary] gen_listing</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>header</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_listing(header: str = None) -&gt; None:
    &#34;&#34;&#34;[summary] gen_listing

    Args:
        header (str, optional): [description]. Defaults to None.
    &#34;&#34;&#34;
    global _PROGRAM

    if header is None:
        header  = &#34;; Generated listing using Shazzam py64gen\n&#34;
        header += &#34;; Copyright (C) 2021 TRSi\n&#34;
        header += &#34;; \n&#34;
        header += &#34;; https://github.com/shazz/shazzam\n\n&#34;

    prefs = Alias( {
            &#34;default_code_segment&#34;: &#34;CODE&#34;,
            &#34;code&#34;: [CodeFormat.USE_HEX, CodeFormat.BYTECODE, CodeFormat.ADDRESS, CodeFormat.SHOW_LABELS],
            &#34;comments&#34;: CommentsFormat.USE_SEMICOLON,
            &#34;directive&#34;: DirectiveFormat.USE_DOT
        })
    set_prefs(default_code_segment=prefs.default_code_segment, code_format=prefs.code, comments_format=prefs.comments, directive_prefix=prefs.directive)

    for segment in g._PROGRAM.segments:

        segment.change_format()
        code = segment.gen_code()

        if code:
            os.makedirs(f&#34;generated/{g._PROGRAM.name}&#34;, exist_ok = True)
            with open(f&#34;generated/{g._PROGRAM.name}/{segment.name}.lst&#34;, &#34;w&#34;) as f:
                f.writelines(header)
                f.writelines(code)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>func, program_name:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(func, program_name: str) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        func ([type]): [description]
    &#34;&#34;&#34;
    global _PROGRAM
    g._PROGRAM.set_name(program_name)

    for i in reloading(range(10)):
        src = dill.source.getsource(func.__dict__[&#39;__inner__&#39;])
        # src = dill.source.getsource(func)
        h = hashlib.md5(src.encode()).hexdigest()

        if func.__name__ not in _funcs:
            _funcs[func.__name__] = h
            func()
        else:
            if _funcs[func.__name__] != h:
                _funcs[func.__name__] = h
                func()

        sleep(1.0)
    generate(func, program_name)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.get_anonymous_label"><code class="name flex">
<span>def <span class="ident">get_anonymous_label</span></span>(<span>name:str) >str</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_anonymous_label(name: str) -&gt; str:
    &#34;&#34;&#34;[summary]

    Args:
        name (str): [description]

    Raises:
        RuntimeError: [description]

    Returns:
        str: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    return g._CURRENT_CONTEXT.get_anonymous_label(name)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.get_current_address"><code class="name flex">
<span>def <span class="ident">get_current_address</span></span>(<span>) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_address() -&gt; int:

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    return g._CURRENT_CONTEXT.next_position</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.get_segment_addresses"><code class="name flex">
<span>def <span class="ident">get_segment_addresses</span></span>(<span>name:str) >int</span>
</code></dt>
<dd>
<div class="desc"><p>get_segment_start_address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_segment_addresses(name: str) -&gt; int:
    &#34;&#34;&#34;get_segment_start_address

    Args:
        name (str): [description]

    Raises:
        ValueError: [description]

    Returns:
        int: [description]
    &#34;&#34;&#34;
    global _PROGRAM

    # import threading
    # x = threading.Thread(target=_watch_segment, args=(name,))

    #TODO: how to make this works if a segment is defined after this call ?
    for segment in g._PROGRAM.segments:

        if segment.name.upper() == name.upper():
            return Alias({
                &#34;start_address&#34;: segment.start_adr,
                &#34;end_address&#34;: segment.end_adr
            })

    raise ValueError(f&#34;Segment {name} not (yet?) found!&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.imm"><code class="name flex">
<span>def <span class="ident">imm</span></span>(<span>value:Any) ><a title="shazzam.Immediate.Immediate" href="Immediate.html#shazzam.Immediate.Immediate">Immediate</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imm(value: Any) -&gt; Immediate:
    if isinstance(value, str):
        if value.startswith(&#39;&gt;&#39;):
            return Immediate(name=value[1:], high_byte=True)
        elif value.startswith(&#39;&lt;&#39;):
            return Immediate(name=value[1:], high_byte=False)
        else:
            raise ValueError(f&#34;Low byte (&lt;) or High byte (&gt;) must be specified. Not {value}&#34;)

    elif isinstance(value, int):
        return Immediate(value=value)
    else:
        raise ValueError(&#34;Immediate must be an int or a string&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.inc"><code class="name flex">
<span>def <span class="ident">inc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.incbin"><code class="name flex">
<span>def <span class="ident">incbin</span></span>(<span>data:bytearray) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytearray</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incbin(data: bytearray) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        data (bytearray): [description]

    Raises:
        RuntimeError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    if data is not None:
        if not isinstance(data, bytearray):
            raise ValueError(f&#34;incbin argument muust be a bytearray and not a {type(data)}&#34;)

        for b in data:
            g._CURRENT_CONTEXT.add_byte(Immediate(value=b))</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ind_at"><code class="name flex">
<span>def <span class="ident">ind_at</span></span>(<span>value:Any) ><a title="shazzam.Address.Address" href="Address.html#shazzam.Address.Address">Address</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ind_at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value, indirect=True)
    elif isinstance(value, int):
        return Address(value=value, indirect=True)
    else:
        raise ValueError(&#34;Address must be an int or a non empty string&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.inx"><code class="name flex">
<span>def <span class="ident">inx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.iny"><code class="name flex">
<span>def <span class="ident">iny</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.jmp"><code class="name flex">
<span>def <span class="ident">jmp</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.jsr"><code class="name flex">
<span>def <span class="ident">jsr</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>name:str, is_global:bool=False) ><a title="shazzam.Address.Address" href="Address.html#shazzam.Address.Address">Address</a></span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label(name: str, is_global: bool = False) -&gt; Address:
    &#34;&#34;&#34;[summary]

    Args:
        name (str): [description]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    if name == None or len(name) == 0:
        raise ValueError(f&#34;Label cannot be empty&#34;)

    label: Address = g._CURRENT_CONTEXT.add_label(name)

    if is_global:
        g._PROGRAM.add_label(label)
        # TODO: generate include file? with globals addresses ?

    return label</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.lda"><code class="name flex">
<span>def <span class="ident">lda</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ldx"><code class="name flex">
<span>def <span class="ident">ldx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ldy"><code class="name flex">
<span>def <span class="ident">ldy</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.lsr"><code class="name flex">
<span>def <span class="ident">lsr</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.nop"><code class="name flex">
<span>def <span class="ident">nop</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ora"><code class="name flex">
<span>def <span class="ident">ora</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.pha"><code class="name flex">
<span>def <span class="ident">pha</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.php"><code class="name flex">
<span>def <span class="ident">php</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.pla"><code class="name flex">
<span>def <span class="ident">pla</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.plp"><code class="name flex">
<span>def <span class="ident">plp</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rasterline"><code class="name flex">
<span>def <span class="ident">rasterline</span></span>(<span>system:<a title="shazzam.defs.System" href="defs.html#shazzam.defs.System">System</a>=System.PAL, mode:<a title="shazzam.defs.DetectMode" href="defs.html#shazzam.defs.DetectMode">DetectMode</a>=DetectMode.MANUAL, nb_sprites:int=8, y_pos:int=0, y_scroll:int=0) ><a title="shazzam.Rasterline.Rasterline" href="Rasterline.html#shazzam.Rasterline.Rasterline">Rasterline</a></span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<code>System</code>, optional</dt>
<dd>[description]. Defaults to System.PAL.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>DetectMode</code>, optional</dt>
<dd>[description]. Defaults to DetectMode.MANUAL.</dd>
<dt><strong><code>nb_sprites</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 8.</dd>
<dt><strong><code>y_pos</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 0.</dd>
<dt><strong><code>y_scroll</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Rasterline</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[Rasterline]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def rasterline(system: System = System.PAL, mode: DetectMode = DetectMode.MANUAL, nb_sprites: int = 8, y_pos: int = 0, y_scroll: int = 0) -&gt; Rasterline:
    &#34;&#34;&#34;[summary]

    Args:
        system (System, optional): [description]. Defaults to System.PAL.
        mode (DetectMode, optional): [description]. Defaults to DetectMode.MANUAL.
        nb_sprites (int, optional): [description]. Defaults to 8.
        y_pos (int, optional): [description]. Defaults to 0.
        y_scroll (int, optional): [description]. Defaults to 0.

    Returns:
        Rasterline: [description]

    Yields:
        Iterator[Rasterline]: [description]
    &#34;&#34;&#34;
    global _CURRENT_RASTER, _PROGRAM, _CURRENT_CONTEXT

    line = Rasterline(system, mode, nb_sprites, y_pos, y_scroll)
    g._CURRENT_RASTER = line

    yield line

    # seg = _CURRENT_CONTEXT

    g._CURRENT_RASTER.close()
    g._CURRENT_RASTER = None</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rel_at"><code class="name flex">
<span>def <span class="ident">rel_at</span></span>(<span>value:Any) ><a title="shazzam.Address.Address" href="Address.html#shazzam.Address.Address">Address</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rel_at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value)
    elif isinstance(value, int):
        rel_address = (value - (get_current_address() + 2)) &amp; 0xff
        g.logger.debug(f&#34;Relative address: {value:04X} - ({get_current_address():04X}+2) = {rel_address:04X}&#34;)

        if rel_address &gt; 0xff:
            raise ValueError(f&#34;Relative address cannot be bigger than a byte: {get_current_address():04X} - {value:04X} = {rel_address:04X}&#34;)

        return Address(value=value, relative=rel_address)
    else:
        raise ValueError(&#34;Relative address must be an int or a non empty string&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rol"><code class="name flex">
<span>def <span class="ident">rol</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ror"><code class="name flex">
<span>def <span class="ident">ror</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rti"><code class="name flex">
<span>def <span class="ident">rti</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rts"><code class="name flex">
<span>def <span class="ident">rts</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sbc"><code class="name flex">
<span>def <span class="ident">sbc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sec"><code class="name flex">
<span>def <span class="ident">sec</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sed"><code class="name flex">
<span>def <span class="ident">sed</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.segment"><code class="name flex">
<span>def <span class="ident">segment</span></span>(<span>start_adr:int, name:str, use_relative_addressing:bool=False, check_address_dups:bool=True) ><a title="shazzam.Segment.Segment" href="Segment.html#shazzam.Segment.Segment">Segment</a></span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_adr</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>gen_files</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Segment</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[Segment]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def segment(start_adr: int, name: str, use_relative_addressing: bool = False, check_address_dups: bool = True) -&gt; Segment:
    &#34;&#34;&#34;[summary]

    Args:
        start_adr (int): [description]
        name (str): [description]
        gen_files (bool, optional): [description]. Defaults to True.

    Returns:
        Segment: [description]

    Yields:
        Iterator[Segment]: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT, _PROGRAM

    seg = Segment(start_adr=start_adr, name=name.upper(), use_relative_addressing=use_relative_addressing)
    g._CURRENT_CONTEXT = seg

    yield seg

    found = False
    for segment in g._PROGRAM.segments:

        # check segments with same base address
        if segment.start_adr == start_adr and segment.name != seg.name and check_address_dups:
            raise ValueError(f&#34;Multiple segments have the same start address {start_adr:04X}: {segment.name} and {seg.name}&#34;)

        # else
        if segment.start_adr == start_adr and segment.name == seg.name:
            found = True

            g.logger.debug(f&#34;Removing segment {segment.name} to PROGRAM&#34;)
            g._PROGRAM.segments.remove(segment)

            g.logger.debug(f&#34;Adding segment {segment.name} to PROGRAM&#34;)
            g._PROGRAM.segments.append(seg)

            break

    if not found:
        g.logger.debug(f&#34;Adding new segment {seg.name} to PROGRAM&#34;)
        g._PROGRAM.segments.append(seg)

    g._CURRENT_CONTEXT.close()
    g._CURRENT_CONTEXT = None</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sei"><code class="name flex">
<span>def <span class="ident">sei</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.set_prefs"><code class="name flex">
<span>def <span class="ident">set_prefs</span></span>(<span>default_code_segment:str, code_format:List[<a title="shazzam.defs.CodeFormat" href="defs.html#shazzam.defs.CodeFormat">CodeFormat</a>], comments_format:<a title="shazzam.defs.CommentsFormat" href="defs.html#shazzam.defs.CommentsFormat">CommentsFormat</a>, directive_prefix:<a title="shazzam.defs.DirectiveFormat" href="defs.html#shazzam.defs.DirectiveFormat">DirectiveFormat</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_prefs(default_code_segment: str, code_format: List[CodeFormat], comments_format: CommentsFormat, directive_prefix: DirectiveFormat):
    global _CODE_FORMAT, _COMMENTS_FORMAT, _DIRECTIVE_PREFIX

    g._CODE_FORMAT = code_format
    g._COMMENTS_FORMAT = comments_format
    g._DIRECTIVE_PREFIX = directive_prefix
    g._DEFAULT_CODE_SEGMENT = default_code_segment</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sta"><code class="name flex">
<span>def <span class="ident">sta</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.stx"><code class="name flex">
<span>def <span class="ident">stx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sty"><code class="name flex">
<span>def <span class="ident">sty</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.tax"><code class="name flex">
<span>def <span class="ident">tax</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.tay"><code class="name flex">
<span>def <span class="ident">tay</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.tsx"><code class="name flex">
<span>def <span class="ident">tsx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.txa"><code class="name flex">
<span>def <span class="ident">txa</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.txs"><code class="name flex">
<span>def <span class="ident">txs</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.tya"><code class="name flex">
<span>def <span class="ident">tya</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(f&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                adr = g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value :
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                adr = g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception as e:
        import inspect
        callerframerecord = inspect.stack()[1]    # 0 represents this line,  1 represents line at caller

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(info)

        raise

    raise NotImplementedError(f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.word"><code class="name flex">
<span>def <span class="ident">word</span></span>(<span>value:int, label:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def word(value: int, label: str) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        value (int): [description]
        label (str): [description]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(f&#34;No segment defined!&#34;)

    if value &gt; 0xffff:
        raise ValueError(f&#34;Value exceed word size: {value}&#34;)

    g._CURRENT_CONTEXT.add_word(value, label)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="shazzam" href="index.html">shazzam</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="shazzam.py64gen.ADC" href="#shazzam.py64gen.ADC">ADC</a></code></li>
<li><code><a title="shazzam.py64gen.AND" href="#shazzam.py64gen.AND">AND</a></code></li>
<li><code><a title="shazzam.py64gen.ASL" href="#shazzam.py64gen.ASL">ASL</a></code></li>
<li><code><a title="shazzam.py64gen.BCC" href="#shazzam.py64gen.BCC">BCC</a></code></li>
<li><code><a title="shazzam.py64gen.BCS" href="#shazzam.py64gen.BCS">BCS</a></code></li>
<li><code><a title="shazzam.py64gen.BEQ" href="#shazzam.py64gen.BEQ">BEQ</a></code></li>
<li><code><a title="shazzam.py64gen.BIT" href="#shazzam.py64gen.BIT">BIT</a></code></li>
<li><code><a title="shazzam.py64gen.BMI" href="#shazzam.py64gen.BMI">BMI</a></code></li>
<li><code><a title="shazzam.py64gen.BNE" href="#shazzam.py64gen.BNE">BNE</a></code></li>
<li><code><a title="shazzam.py64gen.BPL" href="#shazzam.py64gen.BPL">BPL</a></code></li>
<li><code><a title="shazzam.py64gen.BRK" href="#shazzam.py64gen.BRK">BRK</a></code></li>
<li><code><a title="shazzam.py64gen.BVC" href="#shazzam.py64gen.BVC">BVC</a></code></li>
<li><code><a title="shazzam.py64gen.BVS" href="#shazzam.py64gen.BVS">BVS</a></code></li>
<li><code><a title="shazzam.py64gen.CLC" href="#shazzam.py64gen.CLC">CLC</a></code></li>
<li><code><a title="shazzam.py64gen.CLD" href="#shazzam.py64gen.CLD">CLD</a></code></li>
<li><code><a title="shazzam.py64gen.CLI" href="#shazzam.py64gen.CLI">CLI</a></code></li>
<li><code><a title="shazzam.py64gen.CLV" href="#shazzam.py64gen.CLV">CLV</a></code></li>
<li><code><a title="shazzam.py64gen.CMP" href="#shazzam.py64gen.CMP">CMP</a></code></li>
<li><code><a title="shazzam.py64gen.CPX" href="#shazzam.py64gen.CPX">CPX</a></code></li>
<li><code><a title="shazzam.py64gen.CPY" href="#shazzam.py64gen.CPY">CPY</a></code></li>
<li><code><a title="shazzam.py64gen.DEC" href="#shazzam.py64gen.DEC">DEC</a></code></li>
<li><code><a title="shazzam.py64gen.DEX" href="#shazzam.py64gen.DEX">DEX</a></code></li>
<li><code><a title="shazzam.py64gen.DEY" href="#shazzam.py64gen.DEY">DEY</a></code></li>
<li><code><a title="shazzam.py64gen.EOR" href="#shazzam.py64gen.EOR">EOR</a></code></li>
<li><code><a title="shazzam.py64gen.INC" href="#shazzam.py64gen.INC">INC</a></code></li>
<li><code><a title="shazzam.py64gen.INX" href="#shazzam.py64gen.INX">INX</a></code></li>
<li><code><a title="shazzam.py64gen.INY" href="#shazzam.py64gen.INY">INY</a></code></li>
<li><code><a title="shazzam.py64gen.JMP" href="#shazzam.py64gen.JMP">JMP</a></code></li>
<li><code><a title="shazzam.py64gen.JSR" href="#shazzam.py64gen.JSR">JSR</a></code></li>
<li><code><a title="shazzam.py64gen.LDA" href="#shazzam.py64gen.LDA">LDA</a></code></li>
<li><code><a title="shazzam.py64gen.LDX" href="#shazzam.py64gen.LDX">LDX</a></code></li>
<li><code><a title="shazzam.py64gen.LDY" href="#shazzam.py64gen.LDY">LDY</a></code></li>
<li><code><a title="shazzam.py64gen.LSR" href="#shazzam.py64gen.LSR">LSR</a></code></li>
<li><code><a title="shazzam.py64gen.NOP" href="#shazzam.py64gen.NOP">NOP</a></code></li>
<li><code><a title="shazzam.py64gen.ORA" href="#shazzam.py64gen.ORA">ORA</a></code></li>
<li><code><a title="shazzam.py64gen.PHA" href="#shazzam.py64gen.PHA">PHA</a></code></li>
<li><code><a title="shazzam.py64gen.PHP" href="#shazzam.py64gen.PHP">PHP</a></code></li>
<li><code><a title="shazzam.py64gen.PLA" href="#shazzam.py64gen.PLA">PLA</a></code></li>
<li><code><a title="shazzam.py64gen.PLP" href="#shazzam.py64gen.PLP">PLP</a></code></li>
<li><code><a title="shazzam.py64gen.ROL" href="#shazzam.py64gen.ROL">ROL</a></code></li>
<li><code><a title="shazzam.py64gen.ROR" href="#shazzam.py64gen.ROR">ROR</a></code></li>
<li><code><a title="shazzam.py64gen.RTI" href="#shazzam.py64gen.RTI">RTI</a></code></li>
<li><code><a title="shazzam.py64gen.RTS" href="#shazzam.py64gen.RTS">RTS</a></code></li>
<li><code><a title="shazzam.py64gen.SBC" href="#shazzam.py64gen.SBC">SBC</a></code></li>
<li><code><a title="shazzam.py64gen.SEC" href="#shazzam.py64gen.SEC">SEC</a></code></li>
<li><code><a title="shazzam.py64gen.SED" href="#shazzam.py64gen.SED">SED</a></code></li>
<li><code><a title="shazzam.py64gen.SEI" href="#shazzam.py64gen.SEI">SEI</a></code></li>
<li><code><a title="shazzam.py64gen.STA" href="#shazzam.py64gen.STA">STA</a></code></li>
<li><code><a title="shazzam.py64gen.STX" href="#shazzam.py64gen.STX">STX</a></code></li>
<li><code><a title="shazzam.py64gen.STY" href="#shazzam.py64gen.STY">STY</a></code></li>
<li><code><a title="shazzam.py64gen.TAX" href="#shazzam.py64gen.TAX">TAX</a></code></li>
<li><code><a title="shazzam.py64gen.TAY" href="#shazzam.py64gen.TAY">TAY</a></code></li>
<li><code><a title="shazzam.py64gen.TSX" href="#shazzam.py64gen.TSX">TSX</a></code></li>
<li><code><a title="shazzam.py64gen.TXA" href="#shazzam.py64gen.TXA">TXA</a></code></li>
<li><code><a title="shazzam.py64gen.TXS" href="#shazzam.py64gen.TXS">TXS</a></code></li>
<li><code><a title="shazzam.py64gen.TYA" href="#shazzam.py64gen.TYA">TYA</a></code></li>
<li><code><a title="shazzam.py64gen.adc" href="#shazzam.py64gen.adc">adc</a></code></li>
<li><code><a title="shazzam.py64gen.andr" href="#shazzam.py64gen.andr">andr</a></code></li>
<li><code><a title="shazzam.py64gen.asl" href="#shazzam.py64gen.asl">asl</a></code></li>
<li><code><a title="shazzam.py64gen.assemble_prg" href="#shazzam.py64gen.assemble_prg">assemble_prg</a></code></li>
<li><code><a title="shazzam.py64gen.assemble_segment" href="#shazzam.py64gen.assemble_segment">assemble_segment</a></code></li>
<li><code><a title="shazzam.py64gen.at" href="#shazzam.py64gen.at">at</a></code></li>
<li><code><a title="shazzam.py64gen.bcc" href="#shazzam.py64gen.bcc">bcc</a></code></li>
<li><code><a title="shazzam.py64gen.bcs" href="#shazzam.py64gen.bcs">bcs</a></code></li>
<li><code><a title="shazzam.py64gen.beq" href="#shazzam.py64gen.beq">beq</a></code></li>
<li><code><a title="shazzam.py64gen.bit" href="#shazzam.py64gen.bit">bit</a></code></li>
<li><code><a title="shazzam.py64gen.bmi" href="#shazzam.py64gen.bmi">bmi</a></code></li>
<li><code><a title="shazzam.py64gen.bne" href="#shazzam.py64gen.bne">bne</a></code></li>
<li><code><a title="shazzam.py64gen.bpl" href="#shazzam.py64gen.bpl">bpl</a></code></li>
<li><code><a title="shazzam.py64gen.brk" href="#shazzam.py64gen.brk">brk</a></code></li>
<li><code><a title="shazzam.py64gen.bvc" href="#shazzam.py64gen.bvc">bvc</a></code></li>
<li><code><a title="shazzam.py64gen.bvs" href="#shazzam.py64gen.bvs">bvs</a></code></li>
<li><code><a title="shazzam.py64gen.byte" href="#shazzam.py64gen.byte">byte</a></code></li>
<li><code><a title="shazzam.py64gen.clc" href="#shazzam.py64gen.clc">clc</a></code></li>
<li><code><a title="shazzam.py64gen.cld" href="#shazzam.py64gen.cld">cld</a></code></li>
<li><code><a title="shazzam.py64gen.cli" href="#shazzam.py64gen.cli">cli</a></code></li>
<li><code><a title="shazzam.py64gen.clv" href="#shazzam.py64gen.clv">clv</a></code></li>
<li><code><a title="shazzam.py64gen.cmp" href="#shazzam.py64gen.cmp">cmp</a></code></li>
<li><code><a title="shazzam.py64gen.cpx" href="#shazzam.py64gen.cpx">cpx</a></code></li>
<li><code><a title="shazzam.py64gen.cpy" href="#shazzam.py64gen.cpy">cpy</a></code></li>
<li><code><a title="shazzam.py64gen.dec" href="#shazzam.py64gen.dec">dec</a></code></li>
<li><code><a title="shazzam.py64gen.dex" href="#shazzam.py64gen.dex">dex</a></code></li>
<li><code><a title="shazzam.py64gen.dey" href="#shazzam.py64gen.dey">dey</a></code></li>
<li><code><a title="shazzam.py64gen.eor" href="#shazzam.py64gen.eor">eor</a></code></li>
<li><code><a title="shazzam.py64gen.gen_code" href="#shazzam.py64gen.gen_code">gen_code</a></code></li>
<li><code><a title="shazzam.py64gen.gen_irqloader_script" href="#shazzam.py64gen.gen_irqloader_script">gen_irqloader_script</a></code></li>
<li><code><a title="shazzam.py64gen.gen_listing" href="#shazzam.py64gen.gen_listing">gen_listing</a></code></li>
<li><code><a title="shazzam.py64gen.generate" href="#shazzam.py64gen.generate">generate</a></code></li>
<li><code><a title="shazzam.py64gen.get_anonymous_label" href="#shazzam.py64gen.get_anonymous_label">get_anonymous_label</a></code></li>
<li><code><a title="shazzam.py64gen.get_current_address" href="#shazzam.py64gen.get_current_address">get_current_address</a></code></li>
<li><code><a title="shazzam.py64gen.get_segment_addresses" href="#shazzam.py64gen.get_segment_addresses">get_segment_addresses</a></code></li>
<li><code><a title="shazzam.py64gen.imm" href="#shazzam.py64gen.imm">imm</a></code></li>
<li><code><a title="shazzam.py64gen.inc" href="#shazzam.py64gen.inc">inc</a></code></li>
<li><code><a title="shazzam.py64gen.incbin" href="#shazzam.py64gen.incbin">incbin</a></code></li>
<li><code><a title="shazzam.py64gen.ind_at" href="#shazzam.py64gen.ind_at">ind_at</a></code></li>
<li><code><a title="shazzam.py64gen.inx" href="#shazzam.py64gen.inx">inx</a></code></li>
<li><code><a title="shazzam.py64gen.iny" href="#shazzam.py64gen.iny">iny</a></code></li>
<li><code><a title="shazzam.py64gen.jmp" href="#shazzam.py64gen.jmp">jmp</a></code></li>
<li><code><a title="shazzam.py64gen.jsr" href="#shazzam.py64gen.jsr">jsr</a></code></li>
<li><code><a title="shazzam.py64gen.label" href="#shazzam.py64gen.label">label</a></code></li>
<li><code><a title="shazzam.py64gen.lda" href="#shazzam.py64gen.lda">lda</a></code></li>
<li><code><a title="shazzam.py64gen.ldx" href="#shazzam.py64gen.ldx">ldx</a></code></li>
<li><code><a title="shazzam.py64gen.ldy" href="#shazzam.py64gen.ldy">ldy</a></code></li>
<li><code><a title="shazzam.py64gen.lsr" href="#shazzam.py64gen.lsr">lsr</a></code></li>
<li><code><a title="shazzam.py64gen.nop" href="#shazzam.py64gen.nop">nop</a></code></li>
<li><code><a title="shazzam.py64gen.ora" href="#shazzam.py64gen.ora">ora</a></code></li>
<li><code><a title="shazzam.py64gen.pha" href="#shazzam.py64gen.pha">pha</a></code></li>
<li><code><a title="shazzam.py64gen.php" href="#shazzam.py64gen.php">php</a></code></li>
<li><code><a title="shazzam.py64gen.pla" href="#shazzam.py64gen.pla">pla</a></code></li>
<li><code><a title="shazzam.py64gen.plp" href="#shazzam.py64gen.plp">plp</a></code></li>
<li><code><a title="shazzam.py64gen.rasterline" href="#shazzam.py64gen.rasterline">rasterline</a></code></li>
<li><code><a title="shazzam.py64gen.rel_at" href="#shazzam.py64gen.rel_at">rel_at</a></code></li>
<li><code><a title="shazzam.py64gen.rol" href="#shazzam.py64gen.rol">rol</a></code></li>
<li><code><a title="shazzam.py64gen.ror" href="#shazzam.py64gen.ror">ror</a></code></li>
<li><code><a title="shazzam.py64gen.rti" href="#shazzam.py64gen.rti">rti</a></code></li>
<li><code><a title="shazzam.py64gen.rts" href="#shazzam.py64gen.rts">rts</a></code></li>
<li><code><a title="shazzam.py64gen.sbc" href="#shazzam.py64gen.sbc">sbc</a></code></li>
<li><code><a title="shazzam.py64gen.sec" href="#shazzam.py64gen.sec">sec</a></code></li>
<li><code><a title="shazzam.py64gen.sed" href="#shazzam.py64gen.sed">sed</a></code></li>
<li><code><a title="shazzam.py64gen.segment" href="#shazzam.py64gen.segment">segment</a></code></li>
<li><code><a title="shazzam.py64gen.sei" href="#shazzam.py64gen.sei">sei</a></code></li>
<li><code><a title="shazzam.py64gen.set_prefs" href="#shazzam.py64gen.set_prefs">set_prefs</a></code></li>
<li><code><a title="shazzam.py64gen.sta" href="#shazzam.py64gen.sta">sta</a></code></li>
<li><code><a title="shazzam.py64gen.stx" href="#shazzam.py64gen.stx">stx</a></code></li>
<li><code><a title="shazzam.py64gen.sty" href="#shazzam.py64gen.sty">sty</a></code></li>
<li><code><a title="shazzam.py64gen.tax" href="#shazzam.py64gen.tax">tax</a></code></li>
<li><code><a title="shazzam.py64gen.tay" href="#shazzam.py64gen.tay">tay</a></code></li>
<li><code><a title="shazzam.py64gen.tsx" href="#shazzam.py64gen.tsx">tsx</a></code></li>
<li><code><a title="shazzam.py64gen.txa" href="#shazzam.py64gen.txa">txa</a></code></li>
<li><code><a title="shazzam.py64gen.txs" href="#shazzam.py64gen.txs">txs</a></code></li>
<li><code><a title="shazzam.py64gen.tya" href="#shazzam.py64gen.tya">tya</a></code></li>
<li><code><a title="shazzam.py64gen.word" href="#shazzam.py64gen.word">word</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>