<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>shazzam.py64gen API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>shazzam.py64gen</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from time import sleep
from contextlib import contextmanager
import hashlib
import os
import dill

from reloading import reloading

import shazzam.globals as g
from shazzam.Instruction import Instruction
from shazzam.defs import CodeFormat, CommentsFormat, DirectiveFormat, System, DetectMode, Alias, DirectiveDelimiter
from shazzam.defs import RegisterACC, RegisterX, RegisterY
from shazzam.Rasterline import Rasterline
from shazzam.Segment import Segment, SegmentType
from shazzam.Address import Address
from shazzam.Immediate import Immediate
from shazzam.Cruncher import Cruncher
from shazzam.Assembler import Assembler
from shazzam.Emu6502 import Emu6502

from shazzam.optimizer.SegmentOptimizer import SegmentOptimizer, SegmentOptimizerType
from shazzam.optimizer.C64Mode import C64Mode
from shazzam.optimizer.Part import Part
from shazzam.optimizer.MemorySegment import MemorySegment

import enum
from typing import List, Any, Dict


# ---------------------------------------------------------------------
# py64gen public functions
# ---------------------------------------------------------------------
def set_prefs(default_code_segment: str, code_format: List[CodeFormat], comments_format: CommentsFormat, directive_prefix: DirectiveFormat, directive_delimiter: DirectiveDelimiter):
    global _CODE_FORMAT, _COMMENTS_FORMAT, _DIRECTIVE_PREFIX

    g._CODE_FORMAT = code_format
    g._COMMENTS_FORMAT = comments_format
    g._DIRECTIVE_PREFIX = directive_prefix
    g._DEFAULT_CODE_SEGMENT = default_code_segment
    g._DIRECTIVE_DELIMITER = directive_delimiter


@contextmanager
def segment(start_adr: int, name: str, use_relative_addressing: bool = False, check_address_dups: bool = True, fixed_address: bool = False, segment_type: SegmentType = SegmentType.CODE, group: int = None) -&gt; Segment:
    &#34;&#34;&#34;[summary]

    Args:
        start_adr (int): [description]
        name (str): [description]
        gen_files (bool, optional): [description]. Defaults to True.

    Returns:
        Segment: [description]

    Yields:
        Iterator[Segment]: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT, _PROGRAM

    seg = Segment(start_adr=start_adr, name=name.upper(), use_relative_addressing=use_relative_addressing, fixed_address=fixed_address, segment_type=segment_type, group=group)
    g._CURRENT_CONTEXT = seg

    yield seg

    found = False
    for segment in g._PROGRAM.segments:

        # check segments with same base address
        if segment.start_adr == start_adr and segment.name != seg.name and check_address_dups:
            raise ValueError(f&#34;Multiple segments have the same start address {start_adr:04X}: {segment.name} and {seg.name}&#34;)

        # else
        if segment.start_adr == start_adr and segment.name == seg.name:
            found = True

            g.logger.debug(f&#34;Removing segment {segment.name} to PROGRAM&#34;)
            g._PROGRAM.segments.remove(segment)

            g.logger.debug(f&#34;Adding segment {segment.name} to PROGRAM&#34;)
            g._PROGRAM.segments.append(seg)
            break

    if not found:
        g.logger.debug(f&#34;Adding new segment {seg.name} to PROGRAM&#34;)
        g._PROGRAM.segments.append(seg)

    g._CURRENT_CONTEXT.close()
    g._CURRENT_CONTEXT = None


@contextmanager
def rasterline(system: System = System.PAL, mode: DetectMode = DetectMode.MANUAL, nb_sprites: int = 8, y_pos: int = 0, y_scroll: int = 0) -&gt; Rasterline:
    &#34;&#34;&#34;[summary]

    Args:
        system (System, optional): [description]. Defaults to System.PAL.
        mode (DetectMode, optional): [description]. Defaults to DetectMode.MANUAL.
        nb_sprites (int, optional): [description]. Defaults to 8.
        y_pos (int, optional): [description]. Defaults to 0.
        y_scroll (int, optional): [description]. Defaults to 0.

    Returns:
        Rasterline: [description]

    Yields:
        Iterator[Rasterline]: [description]
    &#34;&#34;&#34;
    global _CURRENT_RASTER, _PROGRAM, _CURRENT_CONTEXT

    line = Rasterline(system, mode, nb_sprites, y_pos, y_scroll)
    g._CURRENT_RASTER = line

    yield line

    # seg = _CURRENT_CONTEXT

    g._CURRENT_RASTER.close()
    g._CURRENT_RASTER = None


def gen_code(assembler: Assembler, header: str = None, gen_listing: bool = True, format_listing: Alias = None) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        header (str, optional): [description]. Defaults to None.
        format_code (Alias, optional): [description]. Defaults to None.
        gen_listing (bool, optional): [description]. Defaults to True.
        format_listing (Alias, optional): [description]. Defaults to None.
    &#34;&#34;&#34;
    global _PROGRAM

    _check_segments_overlap()

    if header is None:
        header  = &#34;; Generated code using Shazzam py64gen\n&#34;
        header += &#34;; DO NOT EDIT, MODIFICATIONS WILL BE LOST\n&#34;
        header += &#34;; Copyright (C) 2021 TRSi\n&#34;
        header += &#34;; \n&#34;
        header += &#34;; https://github.com/shazz/shazzam\n\n&#34;


    prefs = assembler.get_code_format()
    g.logger.debug(f&#34;Setting assembler pref: {prefs}&#34;)
    set_prefs(
        default_code_segment=assembler.get_code_segment(),
        code_format=prefs.code,
        comments_format=prefs.comments,
        directive_prefix=prefs.directive,
        directive_delimiter=prefs.delimiter
    )

    for segment in g._PROGRAM.segments:

        g.logger.debug(f&#34;generating code for segment {segment.name} from {g._PROGRAM.segments}&#34;)
        segment.change_format()
        code = segment.gen_code()

        if code:
            os.makedirs(f&#34;generated/{g._PROGRAM.name}&#34;, exist_ok=True)
            with open(f&#34;generated/{g._PROGRAM.name}/{segment.name}.asm&#34;, &#34;w&#34;) as f:
                f.writelines(header)
                f.writelines(assembler.segments_definition_gen(g._PROGRAM.segments))
                f.writelines(code)

    if gen_listing:
        if format_listing is None:
            format_listing = Alias({
                &#34;default_code_segment&#34;: &#34;CODE&#34;,
                &#34;code&#34;: [CodeFormat.USE_HEX, CodeFormat.BYTECODE, CodeFormat.CYCLES, CodeFormat.ADDRESS, CodeFormat.SHOW_LABELS],
                &#34;comments&#34;: CommentsFormat.USE_SEMICOLON,
                &#34;directive&#34;: DirectiveFormat.USE_DOT,
                &#34;delimiter&#34;: DirectiveDelimiter.NO_DELIMITER
            })

        g.logger.debug(f&#34;Setting listing format: {format_listing}&#34;)
        set_prefs(
            default_code_segment=format_listing.default_code_segment,
            code_format=format_listing.code,
            comments_format=format_listing.comments,
            directive_prefix=format_listing.directive,
            directive_delimiter=format_listing.delimiter
        )

        for segment in g._PROGRAM.segments:

            segment.change_format()
            code = segment.gen_code(listing=True)

            if code:
                os.makedirs(f&#34;generated/{g._PROGRAM.name}&#34;, exist_ok=True)
                with open(f&#34;generated/{g._PROGRAM.name}/{segment.name}.lst&#34;, &#34;w&#34;) as f:
                    f.writelines(header)
                    f.writelines(code)


def assemble_segment(assembler: Assembler) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        assembler (Assembler): [description]

    Raises:
        RuntimeError: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT, _PROGRAM

    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    output_file = assembler.assemble_segment(g._PROGRAM, g._CURRENT_CONTEXT)

    return output_file


def assemble_prg(assembler: Assembler, start_address: int, cruncher: Cruncher = None) -&gt; None:
    &#34;&#34;&#34;Assemble listing

    Args:
        assembler ([type]): [description]
        start_address (int): [description]
        cruncher (None): [description]
    &#34;&#34;&#34;
    global _PROGRAM

    output_file = assembler.assemble_prg(g._PROGRAM, start_address)

    if cruncher is not None:
        try:
            cruncher.crunch_prg(output_file)
        except AttributeError as e:
            g.logger.error(
                f&#34;The cruncher class {cruncher.__class__} needs to implement crunch_prg()!&#34;)
            g.logger.error(e)


def get_segment_addresses(name: str) -&gt; int:
    &#34;&#34;&#34;get_segment_start_address

    Args:
        name (str): [description]

    Raises:
        ValueError: [description]

    Returns:
        int: [description]
    &#34;&#34;&#34;
    global _PROGRAM

    # import threading
    # x = threading.Thread(target=_watch_segment, args=(name,))

    # TODO: how to make this works if a segment is defined after this call ?
    for segment in g._PROGRAM.segments:

        if segment.name.upper() == name.upper():
            return Alias({
                &#34;start_address&#34;: segment.start_adr,
                &#34;end_address&#34;: segment.end_adr
            })

    raise ValueError(f&#34;Segment {name} not (yet?) found!&#34;)

# def _watch_segment(name):
#     import time
#     print(f&#34;Looking for segment {name}&#34;)

#     not_found = True

#     while not_found:
#         for segment in g._PROGRAM.segments:
#             if segment.name.upper() == name.upper():
#                 info = Alias({
#                     &#34;start_address&#34;: segment.start_adr,
#                     &#34;end_address&#34;: segment.end_adr
#                 })
#                 not_found = False
#                 break
#         time.sleep(1)
#     return info


def gen_irqloader_script(irqloader, parts_definition: Dict):
    &#34;&#34;&#34;gen_irqloader_script

    Args:
        irqloader ([type]): [description]
        parts_definition (Dict): [description]

    Raises:
        NotImplementedError: [description]
    &#34;&#34;&#34;
    global _PROGRAM
    raise NotImplementedError()

def emulate_program(entry_point_address: Any, stop_address: int = None, cycles_count_start: int = None, cycles_count_end: int = None, debug_mode: bool = False):
    &#34;&#34;&#34;[summary]

    Args:
        entry_point_address (Any): [description]
        debug_mode (bool, optional): [description]. Defaults to False.

    Raises:
        ValueError: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    global _PROGRAM

    # support global label only
    if isinstance(entry_point_address, str):
        g.logger.debug(f&#34;Looking for label {entry_point_address}&#34;)

        if entry_point_address in g._PROGRAM.global_labels and g._PROGRAM.global_labels[entry_point_address].value:
            entry_point_address = g._PROGRAM.global_labels[entry_point_address].value
        else:
            raise ValueError(f&#34;Global label &#39;{entry_point_address}&#39; not found&#34;)

    g.logger.debug(f&#34;Emulation start address: {entry_point_address:04X}&#34;)
    emu = Emu6502()
    ram = []

    # get boundaries
    sorted_adr = sorted([segment.start_adr for segment in g._PROGRAM.segments])
    start_address = sorted_adr[0]
    end_address = _get_segment_by_address(sorted_adr[-1], g._PROGRAM.segments)

    # get bytecode in increasing order
    for adr in sorted_adr:
        seg = _get_segment_by_address(adr, g._PROGRAM.segments)
        ram.append(seg)

    g.logger.info(f&#34;Calling Emulation from ${entry_point_address:04X}&#34;)
    cpu_state, mmu_state, cycles_used = emu.load_and_run(segments=ram, entry_address=entry_point_address, stop_address=stop_address, cycles_count_start=cycles_count_start, cycles_count_end=cycles_count_end, debug_mode=debug_mode)

    return cpu_state, mmu_state, cycles_used


def optimize_segments(specific_memory_org: List = None, bank_setup: C64Mode = C64Mode.IO_VISIBLE, optimizer_type: SegmentOptimizerType = SegmentOptimizerType.BFD):
    &#34;&#34;&#34;[summary]

    Args:
        specific_memory_org (List, optional): [description]. Defaults to None.
        bank_setup (C64Mode, optional): [description]. Defaults to C64Mode.IO_VISIBLE.
        optimizer_type (SegmentOptimizerType, optional): [description]. Defaults to SegmentOptimizerType.BFD.

    Raises:
        ValueError: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    global _PROGRAM

    optimizer = SegmentOptimizer()
    optimizer.select_bank(bank_setup)

    if specific_memory_org and len(specific_memory_org) &gt; 0:
        for location in specific_memory_org:
            optimizer.add_memory_segment(location.start_address, location.end_address, location.type)
    else:
        optimizer.add_memory_segment(0x0200, 0x3FFF, MemorySegment.SegmentType.UserRAM)
        optimizer.add_memory_segment(0x4000, 0x7FFF, MemorySegment.SegmentType.UserRAM)
        optimizer.add_memory_segment(0x8000, 0xBFFF, MemorySegment.SegmentType.UserRAM)
        optimizer.add_memory_segment(0xC000, 0xCFFF, MemorySegment.SegmentType.UserRAM)
        optimizer.add_memory_segment(0xD000, 0xDFFF, MemorySegment.SegmentType.IO)
        optimizer.add_memory_segment(0xE000, 0xFFFF, MemorySegment.SegmentType.UserRAM)

    for segment in g._PROGRAM.segments:
        optimizer.add_code_segment(size=segment.size, name=segment.name, part_type=segment.segment_type, fixed_address=segment.fixed_start_address, group=segment.group)

    if optimizer_type is SegmentOptimizerType.FF:
        results = optimizer.run_first_fit()
    elif optimizer_type is SegmentOptimizerType.NF:
        results = optimizer.run_next_fit()
    elif optimizer_type is SegmentOptimizerType.BF:
        results = optimizer.run_best_fit()
    elif optimizer_type is SegmentOptimizerType.FFD:
        results = optimizer.run_first_fit_decreasing()
    elif optimizer_type is SegmentOptimizerType.NFD:
        results = optimizer.run_next_fit_decreasing()
    elif optimizer_type is SegmentOptimizerType.BFD:
        results = optimizer.run_best_fit_decreasing()
    else:
        raise ValueError(f&#34;Unknown optimizer: {optimizer_type}&#34;)

    return results

# ---------------------------------------------------------------------
# Assembler directives
# ---------------------------------------------------------------------


def at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value)
    elif isinstance(value, int):
        return Address(value=value)
    else:
        raise ValueError(&#34;Address must be an int or a non empty string&#34;)


def ind_at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value, indirect=True)
    elif isinstance(value, int):
        return Address(value=value, indirect=True)
    else:
        raise ValueError(&#34;Address must be an int or a non empty string&#34;)


def rel_at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value)
    elif isinstance(value, int):
        rel_address = (value - (get_current_address() + 2)) &amp; 0xff
        g.logger.debug(
            f&#34;Relative address: {value:04X} - ({get_current_address():04X}+2) = {rel_address:04X}&#34;)

        if rel_address &gt; 0xff:
            raise ValueError(
                f&#34;Relative address cannot be bigger than a byte: {get_current_address():04X} - {value:04X} = {rel_address:04X}&#34;)

        return Address(value=value, relative=rel_address)
    else:
        raise ValueError(
            &#34;Relative address must be an int or a non empty string&#34;)


def imm(value: Any) -&gt; Immediate:
    if isinstance(value, str):
        if value.startswith(&#39;&gt;&#39;):
            return Immediate(name=value[1:], high_byte=True)
        elif value.startswith(&#39;&lt;&#39;):
            return Immediate(name=value[1:], high_byte=False)
        else:
            raise ValueError(
                f&#34;Low byte (&lt;) or High byte (&gt;) must be specified. Not {value}&#34;)

    elif isinstance(value, int):
        return Immediate(value=value)
    else:
        raise ValueError(&#34;Immediate must be an int or a string&#34;)


def label(name: str, is_global: bool = False) -&gt; Address:
    &#34;&#34;&#34;[summary]

    Args:
        name (str): [description]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    if name is None or len(name) == 0:
        raise ValueError(&#34;Label cannot be empty&#34;)

    label: Address = g._CURRENT_CONTEXT.add_label(name)

    if is_global:
        g._PROGRAM.add_label(label)
        # TODO: generate include file? with globals addresses ?

    return label

def get_anonymous_label(name: str) -&gt; str:
    &#34;&#34;&#34;[summary]

    Args:
        name (str): [description]

    Raises:
        RuntimeError: [description]

    Returns:
        str: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    return g._CURRENT_CONTEXT.get_anonymous_label(name)


def byte(value: Any) -&gt; bytearray:

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    if isinstance(value, str):
        if value.startswith(&#39;&gt;&#39;):
            return g._CURRENT_CONTEXT.add_byte(Immediate(name=value[1:], high_byte=True))
        elif value.startswith(&#39;&lt;&#39;):
            return g._CURRENT_CONTEXT.add_byte(Immediate(name=value[1:], high_byte=False))
        else:
            g.logger.warning(
                &#34;Low byte (&lt;) or High byte (&gt;) not specified. Considering this is a character string&#34;)

            ret_array = []
            for v in value:
                ret_array.append(g._CURRENT_CONTEXT.add_byte(
                    Immediate(value=ord(v))))

            return ret_array

    elif isinstance(value, int):
        return g._CURRENT_CONTEXT.add_byte(Immediate(value=value))

    elif isinstance(value, list):
        ret_array = []
        for v in value:
            # ret_array.append(g._CURRENT_CONTEXT.add_byte(Immediate(value=v)))
            ret_array.append(byte(v))
        return ret_array
    else:
        raise ValueError(&#34;Immediate must be an int or a string&#34;)


def word(value: int) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        value (int): [description]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    if value &gt; 0xffff:
        raise ValueError(f&#34;Value exceed word size: {value}&#34;)

    byte([value &gt;&gt; 8, value &amp; 0xff])

def incbin(data: bytearray) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        data (bytearray): [description]

    Raises:
        RuntimeError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    if data is not None:
        if not (isinstance(data, bytearray) or isinstance(data, bytes)):
            raise ValueError(f&#34;incbin argument must be a bytearray and not a {type(data)}&#34;)

        g.logger.info(f&#34;Incbin {len(data)} bytes of data&#34;)
        for b in data:
            g._CURRENT_CONTEXT.add_byte(Immediate(value=b))

def align(value: int) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        value (int): [description]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    if isinstance(value, int) and value in range(0, 0xffff):
        g._CURRENT_CONTEXT.align(value)
    else:
        raise ValueError(f&#34;Alignment should be on a positive integer value&#34;)

def get_current_address() -&gt; int:

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    return g._CURRENT_CONTEXT.next_position

def get_label_address(label: str) -&gt; int:

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    if isinstance(label, str):
        if label in g._CURRENT_CONTEXT.labels:
            adr = g._CURRENT_CONTEXT.labels[label]
            if adr.value is not None:
                return adr.value
            else:
                raise ValueError(f&#34;label {label} not yet resolved&#34;)
        else:
            raise ValueError(f&#34;label {label} not found&#34;)
    else:
        return label

# -----------------------------------------------------------
# Private functions
# -----------------------------------------------------------
def _check_segments_overlap(code_segment: str = &#34;CODE&#34;) -&gt; None:

    intervals = []
    for segment in g._PROGRAM.segments:
        if segment.name == code_segment:
            # adding basic header 13 bytes
            intervals.append((segment.start_adr, segment.end_adr+13))
        else:
            intervals.append((segment.start_adr, segment.end_adr))

    intervals.sort()
    g.logger.info(
        f&#34;Checking overlapping intervals: {[(hex(interval[0]), hex(interval[1])) for interval in intervals]}&#34;)

    for i in range(1, len(intervals)):
        if intervals[i][0] &lt;= intervals[i-1][1]:
            raise ValueError(
                f&#34;The segments {g._PROGRAM.segments[i-1].name} and {g._PROGRAM.segments[i].name} overlap!&#34;)

def _get_segment_by_address(address: int, segments: List[Segment]) -&gt; Segment:
        &#34;&#34;&#34;_get_segment_by_address

        Args:
            address (int): [description]
            segments (List[Segment]): [description]

        Raises:
            ValueError: [description]

        Returns:
            Segment: [description]
        &#34;&#34;&#34;
        for segment in segments:
            if segment.start_adr == address:
                return segment

        raise ValueError(f&#34;No Segment found starting at {address:04X}&#34;)

# ---------------------------------------------------------------------
# Utils
# ---------------------------------------------------------------------

_funcs = {}
def generate(func, program_name: str) -&gt; None:
    &#34;&#34;&#34;generate

    Args:
        func ([type]): [description]
        program_name (str): [description]

    Raises:
        RuntimeError: [description]
    &#34;&#34;&#34;
    global _PROGRAM
    g._PROGRAM.set_name(program_name)

    for i in reloading(range(10)):

        # check mnemonic mistakes like rts, nop...
        src_lines = dill.source.getsourcelines(func.__dict__[&#39;__inner__&#39;])[0]
        for line in src_lines:
            for opcode in Instruction.opcodes:
                if opcode[0] in line and len(line.strip()) == 3:
                    raise RuntimeError(f&#34;Mnemonic &#39;{opcode[0]}&#39;&#39; cannot be called without () ! Should be {opcode[0]}()&#34;)

        # check source has changed
        src = dill.source.getsource(func.__dict__[&#39;__inner__&#39;])

        # src = dill.source.getsource(func)
        h = hashlib.md5(src.encode()).hexdigest()

        if func.__name__ not in _funcs:
            _funcs[func.__name__] = h
            func()
        else:
            if _funcs[func.__name__] != h:
                _funcs[func.__name__] = h
                func()

        sleep(1.0)
    generate(func, program_name)


def _create_a_function(*args, **kwargs):
    &#34;&#34;&#34;[summary]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
        NotImplementedError: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    mnemonic = kwargs[&#39;mnemonic&#39;]
    g.logger.debug(f&#39;creating wrapper for {mnemonic}&#39;)
    modes = []

    opcode_found = False
    for opcode in Instruction.opcodes:
        if opcode[0] == mnemonic:
            modes.append(opcode[1])
            opcode_found = True

    if not opcode_found:
        raise ValueError(f&#34;Opcode {mnemonic} doesn&#39;t exist!&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Opcode can&#39;t have more than 2 operands!&#34;)

    def function_template(*args, **kwargs):

        global _CURRENT_CONTEXT
        if g._CURRENT_CONTEXT is None:
            raise RuntimeError(&#34;No segment defined!&#34;)

        address = None
        immediate = None
        index = None

        if len(args) &gt; 0:
            if isinstance(args[0], Address):
                address = args[0]
            elif isinstance(args[0], Immediate):
                immediate = args[0]
            elif isinstance(args[0], enum.EnumMeta):
                index = args[0]
            else:
                raise ValueError(
                    f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

        if len(args) == 2:
            index = args[1]
            if not isinstance(index, enum.EnumMeta):
                raise ValueError(
                    f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

        if len(args) &gt; 2:
            raise ValueError(&#34;Too many arguments!&#34;)

        g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

        try:
            if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

            if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

            if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
                if address.value is not None:
                    if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                    elif address.value &gt; 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
                else:
                    g._CURRENT_CONTEXT.need_label(address.name)
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

            if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
                if address.value is not None:
                    if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                    elif address.value &gt; 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
                else:
                    g._CURRENT_CONTEXT.need_label(address.name)
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

            if &#39;abs&#39; in modes and index is None and address and not address.indirect:
                if address.value is not None:
                    if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                    elif address.value &gt;= 0x100:
                        return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
                else:
                    g._CURRENT_CONTEXT.need_label(address.name)
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

            if &#39;rel&#39; in modes:
                if address.relative is not None:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
                else:
                    g._CURRENT_CONTEXT.need_label(address.name)
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

            if &#39;imm&#39; in modes and immediate is not None:
                if immediate.value is None:
                    g._CURRENT_CONTEXT.need_label(immediate.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

            if &#39;imp&#39; in modes:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

            if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
                if address.value and address.value &lt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

            if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
                if address.value and address.value &lt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

            if &#39;acc&#39; in modes and index is RegisterACC:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

            if &#39;ind&#39; in modes:
                if address.value:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
                else:
                    g._CURRENT_CONTEXT.need_label(address.name)
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
        except Exception:
            import inspect
            # 0 represents this line,  1 represents line at caller
            callerframerecord = inspect.stack()[1]

            frame = callerframerecord[0]
            info = inspect.getframeinfo(frame)
            print(f&#34;Error: {info}&#34;)

            raise

        raise NotImplementedError(
            f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)

    return function_template

# ---------------------------------------------------------------------
# Opcodes wrappers
# ---------------------------------------------------------------------


g.initialize()

adc = ADC = _create_a_function(mnemonic=&#34;adc&#34;)
alr = ALR = _create_a_function(mnemonic=&#34;alr&#34;)
anc = ANC = _create_a_function(mnemonic=&#34;anc&#34;)
andr= AND = _create_a_function(mnemonic=&#34;and&#34;)
arr = ARR = _create_a_function(mnemonic=&#34;arr&#34;)
asl = ASL = _create_a_function(mnemonic=&#34;asl&#34;)
bcc = BCC = _create_a_function(mnemonic=&#34;bcc&#34;)
bcs = BCS = _create_a_function(mnemonic=&#34;bcs&#34;)
beq = BEQ = _create_a_function(mnemonic=&#34;beq&#34;)
bit = BIT = _create_a_function(mnemonic=&#34;bit&#34;)
bmi = BMI = _create_a_function(mnemonic=&#34;bmi&#34;)
bne = BNE = _create_a_function(mnemonic=&#34;bne&#34;)
bpl = BPL = _create_a_function(mnemonic=&#34;bpl&#34;)
brk = BRK = _create_a_function(mnemonic=&#34;brk&#34;)
bvc = BVC = _create_a_function(mnemonic=&#34;bvc&#34;)
bvs = BVS = _create_a_function(mnemonic=&#34;bvs&#34;)
clc = CLC = _create_a_function(mnemonic=&#34;clc&#34;)
cld = CLD = _create_a_function(mnemonic=&#34;cld&#34;)
cli = CLI = _create_a_function(mnemonic=&#34;cli&#34;)
clv = CLV = _create_a_function(mnemonic=&#34;clv&#34;)
cmp = CMP = _create_a_function(mnemonic=&#34;cmp&#34;)
cpx = CPX = _create_a_function(mnemonic=&#34;cpx&#34;)
cpy = CPY = _create_a_function(mnemonic=&#34;cpy&#34;)
dcp = DCP = _create_a_function(mnemonic=&#34;dcp&#34;)
dec = DEC = _create_a_function(mnemonic=&#34;dec&#34;)
dex = DEX = _create_a_function(mnemonic=&#34;dex&#34;)
dey = DEY = _create_a_function(mnemonic=&#34;dey&#34;)
eor = EOR = _create_a_function(mnemonic=&#34;eor&#34;)
inc = INC = _create_a_function(mnemonic=&#34;inc&#34;)
inx = INX = _create_a_function(mnemonic=&#34;inx&#34;)
isc = ISC = _create_a_function(mnemonic=&#34;isc&#34;)
iny = INY = _create_a_function(mnemonic=&#34;iny&#34;)
jmp = JMP = _create_a_function(mnemonic=&#34;jmp&#34;)
jsr = JSR = _create_a_function(mnemonic=&#34;jsr&#34;)
lax = LAX = _create_a_function(mnemonic=&#34;lax&#34;)
lda = LDA = _create_a_function(mnemonic=&#34;lda&#34;)
ldx = LDX = _create_a_function(mnemonic=&#34;ldx&#34;)
ldy = LDY = _create_a_function(mnemonic=&#34;ldy&#34;)
lsr = LSR = _create_a_function(mnemonic=&#34;lsr&#34;)
nop = NOP = _create_a_function(mnemonic=&#34;nop&#34;)
ora = ORA = _create_a_function(mnemonic=&#34;ora&#34;)
pha = PHA = _create_a_function(mnemonic=&#34;pha&#34;)
php = PHP = _create_a_function(mnemonic=&#34;php&#34;)
pla = PLA = _create_a_function(mnemonic=&#34;pla&#34;)
plp = PLP = _create_a_function(mnemonic=&#34;plp&#34;)
rla = RLA = _create_a_function(mnemonic=&#34;rla&#34;)
rol = ROL = _create_a_function(mnemonic=&#34;rol&#34;)
ror = ROR = _create_a_function(mnemonic=&#34;ror&#34;)
rra = RRA = _create_a_function(mnemonic=&#34;rra&#34;)
rti = RTI = _create_a_function(mnemonic=&#34;rti&#34;)
rts = RTS = _create_a_function(mnemonic=&#34;rts&#34;)
sax = SAX = _create_a_function(mnemonic=&#34;sax&#34;)
sbc = SBC = _create_a_function(mnemonic=&#34;sbc&#34;)
sbx = SBX = _create_a_function(mnemonic=&#34;sbx&#34;)
sec = SEC = _create_a_function(mnemonic=&#34;sec&#34;)
sed = SED = _create_a_function(mnemonic=&#34;sed&#34;)
sei = SEI = _create_a_function(mnemonic=&#34;sei&#34;)
slo = SLO = _create_a_function(mnemonic=&#34;slo&#34;)
sre = SRE = _create_a_function(mnemonic=&#34;sre&#34;)
sta = STA = _create_a_function(mnemonic=&#34;sta&#34;)
stx = STX = _create_a_function(mnemonic=&#34;stx&#34;)
sty = STY = _create_a_function(mnemonic=&#34;sty&#34;)
tax = TAX = _create_a_function(mnemonic=&#34;tax&#34;)
tay = TAY = _create_a_function(mnemonic=&#34;tay&#34;)
tsx = TSX = _create_a_function(mnemonic=&#34;tsx&#34;)
txa = TXA = _create_a_function(mnemonic=&#34;txa&#34;)
txs = TXS = _create_a_function(mnemonic=&#34;txs&#34;)
tya = TYA = _create_a_function(mnemonic=&#34;tya&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="shazzam.py64gen.ADC"><code class="name flex">
<span>def <span class="ident">ADC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ALR"><code class="name flex">
<span>def <span class="ident">ALR</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ANC"><code class="name flex">
<span>def <span class="ident">ANC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.AND"><code class="name flex">
<span>def <span class="ident">AND</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ARR"><code class="name flex">
<span>def <span class="ident">ARR</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ASL"><code class="name flex">
<span>def <span class="ident">ASL</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BCC"><code class="name flex">
<span>def <span class="ident">BCC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BCS"><code class="name flex">
<span>def <span class="ident">BCS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BEQ"><code class="name flex">
<span>def <span class="ident">BEQ</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BIT"><code class="name flex">
<span>def <span class="ident">BIT</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BMI"><code class="name flex">
<span>def <span class="ident">BMI</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BNE"><code class="name flex">
<span>def <span class="ident">BNE</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BPL"><code class="name flex">
<span>def <span class="ident">BPL</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BRK"><code class="name flex">
<span>def <span class="ident">BRK</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BVC"><code class="name flex">
<span>def <span class="ident">BVC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.BVS"><code class="name flex">
<span>def <span class="ident">BVS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CLC"><code class="name flex">
<span>def <span class="ident">CLC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CLD"><code class="name flex">
<span>def <span class="ident">CLD</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CLI"><code class="name flex">
<span>def <span class="ident">CLI</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CLV"><code class="name flex">
<span>def <span class="ident">CLV</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CMP"><code class="name flex">
<span>def <span class="ident">CMP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CPX"><code class="name flex">
<span>def <span class="ident">CPX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.CPY"><code class="name flex">
<span>def <span class="ident">CPY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.DCP"><code class="name flex">
<span>def <span class="ident">DCP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.DEC"><code class="name flex">
<span>def <span class="ident">DEC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.DEX"><code class="name flex">
<span>def <span class="ident">DEX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.DEY"><code class="name flex">
<span>def <span class="ident">DEY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.EOR"><code class="name flex">
<span>def <span class="ident">EOR</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.INC"><code class="name flex">
<span>def <span class="ident">INC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.INX"><code class="name flex">
<span>def <span class="ident">INX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.INY"><code class="name flex">
<span>def <span class="ident">INY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ISC"><code class="name flex">
<span>def <span class="ident">ISC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.JMP"><code class="name flex">
<span>def <span class="ident">JMP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.JSR"><code class="name flex">
<span>def <span class="ident">JSR</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.LAX"><code class="name flex">
<span>def <span class="ident">LAX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.LDA"><code class="name flex">
<span>def <span class="ident">LDA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.LDX"><code class="name flex">
<span>def <span class="ident">LDX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.LDY"><code class="name flex">
<span>def <span class="ident">LDY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.LSR"><code class="name flex">
<span>def <span class="ident">LSR</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.NOP"><code class="name flex">
<span>def <span class="ident">NOP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ORA"><code class="name flex">
<span>def <span class="ident">ORA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.PHA"><code class="name flex">
<span>def <span class="ident">PHA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.PHP"><code class="name flex">
<span>def <span class="ident">PHP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.PLA"><code class="name flex">
<span>def <span class="ident">PLA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.PLP"><code class="name flex">
<span>def <span class="ident">PLP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.RLA"><code class="name flex">
<span>def <span class="ident">RLA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ROL"><code class="name flex">
<span>def <span class="ident">ROL</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ROR"><code class="name flex">
<span>def <span class="ident">ROR</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.RRA"><code class="name flex">
<span>def <span class="ident">RRA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.RTI"><code class="name flex">
<span>def <span class="ident">RTI</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.RTS"><code class="name flex">
<span>def <span class="ident">RTS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SAX"><code class="name flex">
<span>def <span class="ident">SAX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SBC"><code class="name flex">
<span>def <span class="ident">SBC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SBX"><code class="name flex">
<span>def <span class="ident">SBX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SEC"><code class="name flex">
<span>def <span class="ident">SEC</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SED"><code class="name flex">
<span>def <span class="ident">SED</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SEI"><code class="name flex">
<span>def <span class="ident">SEI</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SLO"><code class="name flex">
<span>def <span class="ident">SLO</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.SRE"><code class="name flex">
<span>def <span class="ident">SRE</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.STA"><code class="name flex">
<span>def <span class="ident">STA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.STX"><code class="name flex">
<span>def <span class="ident">STX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.STY"><code class="name flex">
<span>def <span class="ident">STY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TAX"><code class="name flex">
<span>def <span class="ident">TAX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TAY"><code class="name flex">
<span>def <span class="ident">TAY</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TSX"><code class="name flex">
<span>def <span class="ident">TSX</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TXA"><code class="name flex">
<span>def <span class="ident">TXA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TXS"><code class="name flex">
<span>def <span class="ident">TXS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.TYA"><code class="name flex">
<span>def <span class="ident">TYA</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.adc"><code class="name flex">
<span>def <span class="ident">adc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>value: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align(value: int) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        value (int): [description]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    if isinstance(value, int) and value in range(0, 0xffff):
        g._CURRENT_CONTEXT.align(value)
    else:
        raise ValueError(f&#34;Alignment should be on a positive integer value&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.alr"><code class="name flex">
<span>def <span class="ident">alr</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.anc"><code class="name flex">
<span>def <span class="ident">anc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.andr"><code class="name flex">
<span>def <span class="ident">andr</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.arr"><code class="name flex">
<span>def <span class="ident">arr</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.asl"><code class="name flex">
<span>def <span class="ident">asl</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.assemble_prg"><code class="name flex">
<span>def <span class="ident">assemble_prg</span></span>(<span>assembler: <a title="shazzam.Assembler.Assembler" href="Assembler.html#shazzam.Assembler.Assembler">Assembler</a>, start_address: int, cruncher: <a title="shazzam.Cruncher.Cruncher" href="Cruncher.html#shazzam.Cruncher.Cruncher">Cruncher</a> = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Assemble listing</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>assembler</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>start_address</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>cruncher</code></strong> :&ensp;<code>None</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assemble_prg(assembler: Assembler, start_address: int, cruncher: Cruncher = None) -&gt; None:
    &#34;&#34;&#34;Assemble listing

    Args:
        assembler ([type]): [description]
        start_address (int): [description]
        cruncher (None): [description]
    &#34;&#34;&#34;
    global _PROGRAM

    output_file = assembler.assemble_prg(g._PROGRAM, start_address)

    if cruncher is not None:
        try:
            cruncher.crunch_prg(output_file)
        except AttributeError as e:
            g.logger.error(
                f&#34;The cruncher class {cruncher.__class__} needs to implement crunch_prg()!&#34;)
            g.logger.error(e)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.assemble_segment"><code class="name flex">
<span>def <span class="ident">assemble_segment</span></span>(<span>assembler: <a title="shazzam.Assembler.Assembler" href="Assembler.html#shazzam.Assembler.Assembler">Assembler</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>assembler</code></strong> :&ensp;<code>Assembler</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assemble_segment(assembler: Assembler) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        assembler (Assembler): [description]

    Raises:
        RuntimeError: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT, _PROGRAM

    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    output_file = assembler.assemble_segment(g._PROGRAM, g._CURRENT_CONTEXT)

    return output_file</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>value: Any) ‑> <a title="shazzam.Address.Address" href="Address.html#shazzam.Address.Address">Address</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value)
    elif isinstance(value, int):
        return Address(value=value)
    else:
        raise ValueError(&#34;Address must be an int or a non empty string&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bcc"><code class="name flex">
<span>def <span class="ident">bcc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bcs"><code class="name flex">
<span>def <span class="ident">bcs</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.beq"><code class="name flex">
<span>def <span class="ident">beq</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bit"><code class="name flex">
<span>def <span class="ident">bit</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bmi"><code class="name flex">
<span>def <span class="ident">bmi</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bne"><code class="name flex">
<span>def <span class="ident">bne</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bpl"><code class="name flex">
<span>def <span class="ident">bpl</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.brk"><code class="name flex">
<span>def <span class="ident">brk</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bvc"><code class="name flex">
<span>def <span class="ident">bvc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.bvs"><code class="name flex">
<span>def <span class="ident">bvs</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.byte"><code class="name flex">
<span>def <span class="ident">byte</span></span>(<span>value: Any) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def byte(value: Any) -&gt; bytearray:

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    if isinstance(value, str):
        if value.startswith(&#39;&gt;&#39;):
            return g._CURRENT_CONTEXT.add_byte(Immediate(name=value[1:], high_byte=True))
        elif value.startswith(&#39;&lt;&#39;):
            return g._CURRENT_CONTEXT.add_byte(Immediate(name=value[1:], high_byte=False))
        else:
            g.logger.warning(
                &#34;Low byte (&lt;) or High byte (&gt;) not specified. Considering this is a character string&#34;)

            ret_array = []
            for v in value:
                ret_array.append(g._CURRENT_CONTEXT.add_byte(
                    Immediate(value=ord(v))))

            return ret_array

    elif isinstance(value, int):
        return g._CURRENT_CONTEXT.add_byte(Immediate(value=value))

    elif isinstance(value, list):
        ret_array = []
        for v in value:
            # ret_array.append(g._CURRENT_CONTEXT.add_byte(Immediate(value=v)))
            ret_array.append(byte(v))
        return ret_array
    else:
        raise ValueError(&#34;Immediate must be an int or a string&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.clc"><code class="name flex">
<span>def <span class="ident">clc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.cld"><code class="name flex">
<span>def <span class="ident">cld</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.cli"><code class="name flex">
<span>def <span class="ident">cli</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.clv"><code class="name flex">
<span>def <span class="ident">clv</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.cpx"><code class="name flex">
<span>def <span class="ident">cpx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.cpy"><code class="name flex">
<span>def <span class="ident">cpy</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.dcp"><code class="name flex">
<span>def <span class="ident">dcp</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.dec"><code class="name flex">
<span>def <span class="ident">dec</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.dex"><code class="name flex">
<span>def <span class="ident">dex</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.dey"><code class="name flex">
<span>def <span class="ident">dey</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.emulate_program"><code class="name flex">
<span>def <span class="ident">emulate_program</span></span>(<span>entry_point_address: Any, stop_address: int = None, cycles_count_start: int = None, cycles_count_end: int = None, debug_mode: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_point_address</code></strong> :&ensp;<code>Any</code></dt>
<dd>[description]</dd>
<dt><strong><code>debug_mode</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emulate_program(entry_point_address: Any, stop_address: int = None, cycles_count_start: int = None, cycles_count_end: int = None, debug_mode: bool = False):
    &#34;&#34;&#34;[summary]

    Args:
        entry_point_address (Any): [description]
        debug_mode (bool, optional): [description]. Defaults to False.

    Raises:
        ValueError: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    global _PROGRAM

    # support global label only
    if isinstance(entry_point_address, str):
        g.logger.debug(f&#34;Looking for label {entry_point_address}&#34;)

        if entry_point_address in g._PROGRAM.global_labels and g._PROGRAM.global_labels[entry_point_address].value:
            entry_point_address = g._PROGRAM.global_labels[entry_point_address].value
        else:
            raise ValueError(f&#34;Global label &#39;{entry_point_address}&#39; not found&#34;)

    g.logger.debug(f&#34;Emulation start address: {entry_point_address:04X}&#34;)
    emu = Emu6502()
    ram = []

    # get boundaries
    sorted_adr = sorted([segment.start_adr for segment in g._PROGRAM.segments])
    start_address = sorted_adr[0]
    end_address = _get_segment_by_address(sorted_adr[-1], g._PROGRAM.segments)

    # get bytecode in increasing order
    for adr in sorted_adr:
        seg = _get_segment_by_address(adr, g._PROGRAM.segments)
        ram.append(seg)

    g.logger.info(f&#34;Calling Emulation from ${entry_point_address:04X}&#34;)
    cpu_state, mmu_state, cycles_used = emu.load_and_run(segments=ram, entry_address=entry_point_address, stop_address=stop_address, cycles_count_start=cycles_count_start, cycles_count_end=cycles_count_end, debug_mode=debug_mode)

    return cpu_state, mmu_state, cycles_used</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.eor"><code class="name flex">
<span>def <span class="ident">eor</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.gen_code"><code class="name flex">
<span>def <span class="ident">gen_code</span></span>(<span>assembler: <a title="shazzam.Assembler.Assembler" href="Assembler.html#shazzam.Assembler.Assembler">Assembler</a>, header: str = None, gen_listing: bool = True, format_listing: <a title="shazzam.defs.Alias" href="defs.html#shazzam.defs.Alias">Alias</a> = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>header</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>format_code</code></strong> :&ensp;<code>Alias</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>gen_listing</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to True.</dd>
<dt><strong><code>format_listing</code></strong> :&ensp;<code>Alias</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_code(assembler: Assembler, header: str = None, gen_listing: bool = True, format_listing: Alias = None) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        header (str, optional): [description]. Defaults to None.
        format_code (Alias, optional): [description]. Defaults to None.
        gen_listing (bool, optional): [description]. Defaults to True.
        format_listing (Alias, optional): [description]. Defaults to None.
    &#34;&#34;&#34;
    global _PROGRAM

    _check_segments_overlap()

    if header is None:
        header  = &#34;; Generated code using Shazzam py64gen\n&#34;
        header += &#34;; DO NOT EDIT, MODIFICATIONS WILL BE LOST\n&#34;
        header += &#34;; Copyright (C) 2021 TRSi\n&#34;
        header += &#34;; \n&#34;
        header += &#34;; https://github.com/shazz/shazzam\n\n&#34;


    prefs = assembler.get_code_format()
    g.logger.debug(f&#34;Setting assembler pref: {prefs}&#34;)
    set_prefs(
        default_code_segment=assembler.get_code_segment(),
        code_format=prefs.code,
        comments_format=prefs.comments,
        directive_prefix=prefs.directive,
        directive_delimiter=prefs.delimiter
    )

    for segment in g._PROGRAM.segments:

        g.logger.debug(f&#34;generating code for segment {segment.name} from {g._PROGRAM.segments}&#34;)
        segment.change_format()
        code = segment.gen_code()

        if code:
            os.makedirs(f&#34;generated/{g._PROGRAM.name}&#34;, exist_ok=True)
            with open(f&#34;generated/{g._PROGRAM.name}/{segment.name}.asm&#34;, &#34;w&#34;) as f:
                f.writelines(header)
                f.writelines(assembler.segments_definition_gen(g._PROGRAM.segments))
                f.writelines(code)

    if gen_listing:
        if format_listing is None:
            format_listing = Alias({
                &#34;default_code_segment&#34;: &#34;CODE&#34;,
                &#34;code&#34;: [CodeFormat.USE_HEX, CodeFormat.BYTECODE, CodeFormat.CYCLES, CodeFormat.ADDRESS, CodeFormat.SHOW_LABELS],
                &#34;comments&#34;: CommentsFormat.USE_SEMICOLON,
                &#34;directive&#34;: DirectiveFormat.USE_DOT,
                &#34;delimiter&#34;: DirectiveDelimiter.NO_DELIMITER
            })

        g.logger.debug(f&#34;Setting listing format: {format_listing}&#34;)
        set_prefs(
            default_code_segment=format_listing.default_code_segment,
            code_format=format_listing.code,
            comments_format=format_listing.comments,
            directive_prefix=format_listing.directive,
            directive_delimiter=format_listing.delimiter
        )

        for segment in g._PROGRAM.segments:

            segment.change_format()
            code = segment.gen_code(listing=True)

            if code:
                os.makedirs(f&#34;generated/{g._PROGRAM.name}&#34;, exist_ok=True)
                with open(f&#34;generated/{g._PROGRAM.name}/{segment.name}.lst&#34;, &#34;w&#34;) as f:
                    f.writelines(header)
                    f.writelines(code)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.gen_irqloader_script"><code class="name flex">
<span>def <span class="ident">gen_irqloader_script</span></span>(<span>irqloader, parts_definition: Dict)</span>
</code></dt>
<dd>
<div class="desc"><p>gen_irqloader_script</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>irqloader</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>parts_definition</code></strong> :&ensp;<code>Dict</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_irqloader_script(irqloader, parts_definition: Dict):
    &#34;&#34;&#34;gen_irqloader_script

    Args:
        irqloader ([type]): [description]
        parts_definition (Dict): [description]

    Raises:
        NotImplementedError: [description]
    &#34;&#34;&#34;
    global _PROGRAM
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>func, program_name: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>generate</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>program_name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(func, program_name: str) -&gt; None:
    &#34;&#34;&#34;generate

    Args:
        func ([type]): [description]
        program_name (str): [description]

    Raises:
        RuntimeError: [description]
    &#34;&#34;&#34;
    global _PROGRAM
    g._PROGRAM.set_name(program_name)

    for i in reloading(range(10)):

        # check mnemonic mistakes like rts, nop...
        src_lines = dill.source.getsourcelines(func.__dict__[&#39;__inner__&#39;])[0]
        for line in src_lines:
            for opcode in Instruction.opcodes:
                if opcode[0] in line and len(line.strip()) == 3:
                    raise RuntimeError(f&#34;Mnemonic &#39;{opcode[0]}&#39;&#39; cannot be called without () ! Should be {opcode[0]}()&#34;)

        # check source has changed
        src = dill.source.getsource(func.__dict__[&#39;__inner__&#39;])

        # src = dill.source.getsource(func)
        h = hashlib.md5(src.encode()).hexdigest()

        if func.__name__ not in _funcs:
            _funcs[func.__name__] = h
            func()
        else:
            if _funcs[func.__name__] != h:
                _funcs[func.__name__] = h
                func()

        sleep(1.0)
    generate(func, program_name)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.get_anonymous_label"><code class="name flex">
<span>def <span class="ident">get_anonymous_label</span></span>(<span>name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_anonymous_label(name: str) -&gt; str:
    &#34;&#34;&#34;[summary]

    Args:
        name (str): [description]

    Raises:
        RuntimeError: [description]

    Returns:
        str: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    return g._CURRENT_CONTEXT.get_anonymous_label(name)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.get_current_address"><code class="name flex">
<span>def <span class="ident">get_current_address</span></span>(<span>) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_address() -&gt; int:

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    return g._CURRENT_CONTEXT.next_position</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.get_label_address"><code class="name flex">
<span>def <span class="ident">get_label_address</span></span>(<span>label: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_label_address(label: str) -&gt; int:

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    if isinstance(label, str):
        if label in g._CURRENT_CONTEXT.labels:
            adr = g._CURRENT_CONTEXT.labels[label]
            if adr.value is not None:
                return adr.value
            else:
                raise ValueError(f&#34;label {label} not yet resolved&#34;)
        else:
            raise ValueError(f&#34;label {label} not found&#34;)
    else:
        return label</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.get_segment_addresses"><code class="name flex">
<span>def <span class="ident">get_segment_addresses</span></span>(<span>name: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>get_segment_start_address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_segment_addresses(name: str) -&gt; int:
    &#34;&#34;&#34;get_segment_start_address

    Args:
        name (str): [description]

    Raises:
        ValueError: [description]

    Returns:
        int: [description]
    &#34;&#34;&#34;
    global _PROGRAM

    # import threading
    # x = threading.Thread(target=_watch_segment, args=(name,))

    # TODO: how to make this works if a segment is defined after this call ?
    for segment in g._PROGRAM.segments:

        if segment.name.upper() == name.upper():
            return Alias({
                &#34;start_address&#34;: segment.start_adr,
                &#34;end_address&#34;: segment.end_adr
            })

    raise ValueError(f&#34;Segment {name} not (yet?) found!&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.imm"><code class="name flex">
<span>def <span class="ident">imm</span></span>(<span>value: Any) ‑> <a title="shazzam.Immediate.Immediate" href="Immediate.html#shazzam.Immediate.Immediate">Immediate</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imm(value: Any) -&gt; Immediate:
    if isinstance(value, str):
        if value.startswith(&#39;&gt;&#39;):
            return Immediate(name=value[1:], high_byte=True)
        elif value.startswith(&#39;&lt;&#39;):
            return Immediate(name=value[1:], high_byte=False)
        else:
            raise ValueError(
                f&#34;Low byte (&lt;) or High byte (&gt;) must be specified. Not {value}&#34;)

    elif isinstance(value, int):
        return Immediate(value=value)
    else:
        raise ValueError(&#34;Immediate must be an int or a string&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.inc"><code class="name flex">
<span>def <span class="ident">inc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.incbin"><code class="name flex">
<span>def <span class="ident">incbin</span></span>(<span>data: bytearray) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytearray</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incbin(data: bytearray) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        data (bytearray): [description]

    Raises:
        RuntimeError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    if data is not None:
        if not (isinstance(data, bytearray) or isinstance(data, bytes)):
            raise ValueError(f&#34;incbin argument must be a bytearray and not a {type(data)}&#34;)

        g.logger.info(f&#34;Incbin {len(data)} bytes of data&#34;)
        for b in data:
            g._CURRENT_CONTEXT.add_byte(Immediate(value=b))</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ind_at"><code class="name flex">
<span>def <span class="ident">ind_at</span></span>(<span>value: Any) ‑> <a title="shazzam.Address.Address" href="Address.html#shazzam.Address.Address">Address</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ind_at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value, indirect=True)
    elif isinstance(value, int):
        return Address(value=value, indirect=True)
    else:
        raise ValueError(&#34;Address must be an int or a non empty string&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.inx"><code class="name flex">
<span>def <span class="ident">inx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.iny"><code class="name flex">
<span>def <span class="ident">iny</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.isc"><code class="name flex">
<span>def <span class="ident">isc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.jmp"><code class="name flex">
<span>def <span class="ident">jmp</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.jsr"><code class="name flex">
<span>def <span class="ident">jsr</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>name: str, is_global: bool = False) ‑> <a title="shazzam.Address.Address" href="Address.html#shazzam.Address.Address">Address</a></span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label(name: str, is_global: bool = False) -&gt; Address:
    &#34;&#34;&#34;[summary]

    Args:
        name (str): [description]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    if name is None or len(name) == 0:
        raise ValueError(&#34;Label cannot be empty&#34;)

    label: Address = g._CURRENT_CONTEXT.add_label(name)

    if is_global:
        g._PROGRAM.add_label(label)
        # TODO: generate include file? with globals addresses ?

    return label</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.lax"><code class="name flex">
<span>def <span class="ident">lax</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.lda"><code class="name flex">
<span>def <span class="ident">lda</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ldx"><code class="name flex">
<span>def <span class="ident">ldx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ldy"><code class="name flex">
<span>def <span class="ident">ldy</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.lsr"><code class="name flex">
<span>def <span class="ident">lsr</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.nop"><code class="name flex">
<span>def <span class="ident">nop</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.optimize_segments"><code class="name flex">
<span>def <span class="ident">optimize_segments</span></span>(<span>specific_memory_org: List = None, bank_setup: <a title="shazzam.optimizer.C64Mode.C64Mode" href="optimizer/C64Mode.html#shazzam.optimizer.C64Mode.C64Mode">C64Mode</a> = C64Mode.IO_VISIBLE, optimizer_type: <a title="shazzam.optimizer.SegmentOptimizer.SegmentOptimizerType" href="optimizer/SegmentOptimizer.html#shazzam.optimizer.SegmentOptimizer.SegmentOptimizerType">SegmentOptimizerType</a> = SegmentOptimizerType.BFD)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>specific_memory_org</code></strong> :&ensp;<code>List</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>bank_setup</code></strong> :&ensp;<code>C64Mode</code>, optional</dt>
<dd>[description]. Defaults to C64Mode.IO_VISIBLE.</dd>
<dt><strong><code>optimizer_type</code></strong> :&ensp;<code>SegmentOptimizerType</code>, optional</dt>
<dd>[description]. Defaults to SegmentOptimizerType.BFD.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize_segments(specific_memory_org: List = None, bank_setup: C64Mode = C64Mode.IO_VISIBLE, optimizer_type: SegmentOptimizerType = SegmentOptimizerType.BFD):
    &#34;&#34;&#34;[summary]

    Args:
        specific_memory_org (List, optional): [description]. Defaults to None.
        bank_setup (C64Mode, optional): [description]. Defaults to C64Mode.IO_VISIBLE.
        optimizer_type (SegmentOptimizerType, optional): [description]. Defaults to SegmentOptimizerType.BFD.

    Raises:
        ValueError: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    global _PROGRAM

    optimizer = SegmentOptimizer()
    optimizer.select_bank(bank_setup)

    if specific_memory_org and len(specific_memory_org) &gt; 0:
        for location in specific_memory_org:
            optimizer.add_memory_segment(location.start_address, location.end_address, location.type)
    else:
        optimizer.add_memory_segment(0x0200, 0x3FFF, MemorySegment.SegmentType.UserRAM)
        optimizer.add_memory_segment(0x4000, 0x7FFF, MemorySegment.SegmentType.UserRAM)
        optimizer.add_memory_segment(0x8000, 0xBFFF, MemorySegment.SegmentType.UserRAM)
        optimizer.add_memory_segment(0xC000, 0xCFFF, MemorySegment.SegmentType.UserRAM)
        optimizer.add_memory_segment(0xD000, 0xDFFF, MemorySegment.SegmentType.IO)
        optimizer.add_memory_segment(0xE000, 0xFFFF, MemorySegment.SegmentType.UserRAM)

    for segment in g._PROGRAM.segments:
        optimizer.add_code_segment(size=segment.size, name=segment.name, part_type=segment.segment_type, fixed_address=segment.fixed_start_address, group=segment.group)

    if optimizer_type is SegmentOptimizerType.FF:
        results = optimizer.run_first_fit()
    elif optimizer_type is SegmentOptimizerType.NF:
        results = optimizer.run_next_fit()
    elif optimizer_type is SegmentOptimizerType.BF:
        results = optimizer.run_best_fit()
    elif optimizer_type is SegmentOptimizerType.FFD:
        results = optimizer.run_first_fit_decreasing()
    elif optimizer_type is SegmentOptimizerType.NFD:
        results = optimizer.run_next_fit_decreasing()
    elif optimizer_type is SegmentOptimizerType.BFD:
        results = optimizer.run_best_fit_decreasing()
    else:
        raise ValueError(f&#34;Unknown optimizer: {optimizer_type}&#34;)

    return results</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ora"><code class="name flex">
<span>def <span class="ident">ora</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.pha"><code class="name flex">
<span>def <span class="ident">pha</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.php"><code class="name flex">
<span>def <span class="ident">php</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.pla"><code class="name flex">
<span>def <span class="ident">pla</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.plp"><code class="name flex">
<span>def <span class="ident">plp</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rasterline"><code class="name flex">
<span>def <span class="ident">rasterline</span></span>(<span>system: <a title="shazzam.defs.System" href="defs.html#shazzam.defs.System">System</a> = System.PAL, mode: <a title="shazzam.defs.DetectMode" href="defs.html#shazzam.defs.DetectMode">DetectMode</a> = DetectMode.MANUAL, nb_sprites: int = 8, y_pos: int = 0, y_scroll: int = 0) ‑> <a title="shazzam.Rasterline.Rasterline" href="Rasterline.html#shazzam.Rasterline.Rasterline">Rasterline</a></span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<code>System</code>, optional</dt>
<dd>[description]. Defaults to System.PAL.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>DetectMode</code>, optional</dt>
<dd>[description]. Defaults to DetectMode.MANUAL.</dd>
<dt><strong><code>nb_sprites</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 8.</dd>
<dt><strong><code>y_pos</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 0.</dd>
<dt><strong><code>y_scroll</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Rasterline</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[Rasterline]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def rasterline(system: System = System.PAL, mode: DetectMode = DetectMode.MANUAL, nb_sprites: int = 8, y_pos: int = 0, y_scroll: int = 0) -&gt; Rasterline:
    &#34;&#34;&#34;[summary]

    Args:
        system (System, optional): [description]. Defaults to System.PAL.
        mode (DetectMode, optional): [description]. Defaults to DetectMode.MANUAL.
        nb_sprites (int, optional): [description]. Defaults to 8.
        y_pos (int, optional): [description]. Defaults to 0.
        y_scroll (int, optional): [description]. Defaults to 0.

    Returns:
        Rasterline: [description]

    Yields:
        Iterator[Rasterline]: [description]
    &#34;&#34;&#34;
    global _CURRENT_RASTER, _PROGRAM, _CURRENT_CONTEXT

    line = Rasterline(system, mode, nb_sprites, y_pos, y_scroll)
    g._CURRENT_RASTER = line

    yield line

    # seg = _CURRENT_CONTEXT

    g._CURRENT_RASTER.close()
    g._CURRENT_RASTER = None</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rel_at"><code class="name flex">
<span>def <span class="ident">rel_at</span></span>(<span>value: Any) ‑> <a title="shazzam.Address.Address" href="Address.html#shazzam.Address.Address">Address</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rel_at(value: Any) -&gt; Address:
    if isinstance(value, str) and value != &#34;&#34;:
        return Address(name=value)
    elif isinstance(value, int):
        rel_address = (value - (get_current_address() + 2)) &amp; 0xff
        g.logger.debug(
            f&#34;Relative address: {value:04X} - ({get_current_address():04X}+2) = {rel_address:04X}&#34;)

        if rel_address &gt; 0xff:
            raise ValueError(
                f&#34;Relative address cannot be bigger than a byte: {get_current_address():04X} - {value:04X} = {rel_address:04X}&#34;)

        return Address(value=value, relative=rel_address)
    else:
        raise ValueError(
            &#34;Relative address must be an int or a non empty string&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rla"><code class="name flex">
<span>def <span class="ident">rla</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rol"><code class="name flex">
<span>def <span class="ident">rol</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.ror"><code class="name flex">
<span>def <span class="ident">ror</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rra"><code class="name flex">
<span>def <span class="ident">rra</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rti"><code class="name flex">
<span>def <span class="ident">rti</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.rts"><code class="name flex">
<span>def <span class="ident">rts</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sax"><code class="name flex">
<span>def <span class="ident">sax</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sbc"><code class="name flex">
<span>def <span class="ident">sbc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sbx"><code class="name flex">
<span>def <span class="ident">sbx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sec"><code class="name flex">
<span>def <span class="ident">sec</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sed"><code class="name flex">
<span>def <span class="ident">sed</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.segment"><code class="name flex">
<span>def <span class="ident">segment</span></span>(<span>start_adr: int, name: str, use_relative_addressing: bool = False, check_address_dups: bool = True, fixed_address: bool = False, segment_type: <a title="shazzam.Segment.SegmentType" href="Segment.html#shazzam.Segment.SegmentType">SegmentType</a> = SegmentType.CODE, group: int = None) ‑> <a title="shazzam.Segment.Segment" href="Segment.html#shazzam.Segment.Segment">Segment</a></span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_adr</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>gen_files</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Segment</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[Segment]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def segment(start_adr: int, name: str, use_relative_addressing: bool = False, check_address_dups: bool = True, fixed_address: bool = False, segment_type: SegmentType = SegmentType.CODE, group: int = None) -&gt; Segment:
    &#34;&#34;&#34;[summary]

    Args:
        start_adr (int): [description]
        name (str): [description]
        gen_files (bool, optional): [description]. Defaults to True.

    Returns:
        Segment: [description]

    Yields:
        Iterator[Segment]: [description]
    &#34;&#34;&#34;
    global _CURRENT_CONTEXT, _PROGRAM

    seg = Segment(start_adr=start_adr, name=name.upper(), use_relative_addressing=use_relative_addressing, fixed_address=fixed_address, segment_type=segment_type, group=group)
    g._CURRENT_CONTEXT = seg

    yield seg

    found = False
    for segment in g._PROGRAM.segments:

        # check segments with same base address
        if segment.start_adr == start_adr and segment.name != seg.name and check_address_dups:
            raise ValueError(f&#34;Multiple segments have the same start address {start_adr:04X}: {segment.name} and {seg.name}&#34;)

        # else
        if segment.start_adr == start_adr and segment.name == seg.name:
            found = True

            g.logger.debug(f&#34;Removing segment {segment.name} to PROGRAM&#34;)
            g._PROGRAM.segments.remove(segment)

            g.logger.debug(f&#34;Adding segment {segment.name} to PROGRAM&#34;)
            g._PROGRAM.segments.append(seg)
            break

    if not found:
        g.logger.debug(f&#34;Adding new segment {seg.name} to PROGRAM&#34;)
        g._PROGRAM.segments.append(seg)

    g._CURRENT_CONTEXT.close()
    g._CURRENT_CONTEXT = None</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sei"><code class="name flex">
<span>def <span class="ident">sei</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.set_prefs"><code class="name flex">
<span>def <span class="ident">set_prefs</span></span>(<span>default_code_segment: str, code_format: List[<a title="shazzam.defs.CodeFormat" href="defs.html#shazzam.defs.CodeFormat">CodeFormat</a>], comments_format: <a title="shazzam.defs.CommentsFormat" href="defs.html#shazzam.defs.CommentsFormat">CommentsFormat</a>, directive_prefix: <a title="shazzam.defs.DirectiveFormat" href="defs.html#shazzam.defs.DirectiveFormat">DirectiveFormat</a>, directive_delimiter: <a title="shazzam.defs.DirectiveDelimiter" href="defs.html#shazzam.defs.DirectiveDelimiter">DirectiveDelimiter</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_prefs(default_code_segment: str, code_format: List[CodeFormat], comments_format: CommentsFormat, directive_prefix: DirectiveFormat, directive_delimiter: DirectiveDelimiter):
    global _CODE_FORMAT, _COMMENTS_FORMAT, _DIRECTIVE_PREFIX

    g._CODE_FORMAT = code_format
    g._COMMENTS_FORMAT = comments_format
    g._DIRECTIVE_PREFIX = directive_prefix
    g._DEFAULT_CODE_SEGMENT = default_code_segment
    g._DIRECTIVE_DELIMITER = directive_delimiter</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.slo"><code class="name flex">
<span>def <span class="ident">slo</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sre"><code class="name flex">
<span>def <span class="ident">sre</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sta"><code class="name flex">
<span>def <span class="ident">sta</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.stx"><code class="name flex">
<span>def <span class="ident">stx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.sty"><code class="name flex">
<span>def <span class="ident">sty</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.tax"><code class="name flex">
<span>def <span class="ident">tax</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.tay"><code class="name flex">
<span>def <span class="ident">tay</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.tsx"><code class="name flex">
<span>def <span class="ident">tsx</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.txa"><code class="name flex">
<span>def <span class="ident">txa</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.txs"><code class="name flex">
<span>def <span class="ident">txs</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.tya"><code class="name flex">
<span>def <span class="ident">tya</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def function_template(*args, **kwargs):

    global _CURRENT_CONTEXT
    if g._CURRENT_CONTEXT is None:
        raise RuntimeError(&#34;No segment defined!&#34;)

    address = None
    immediate = None
    index = None

    if len(args) &gt; 0:
        if isinstance(args[0], Address):
            address = args[0]
        elif isinstance(args[0], Immediate):
            immediate = args[0]
        elif isinstance(args[0], enum.EnumMeta):
            index = args[0]
        else:
            raise ValueError(
                f&#34;1st operand must be an Address or an Immediate, not a {type(args[0])}&#34;)

    if len(args) == 2:
        index = args[1]
        if not isinstance(index, enum.EnumMeta):
            raise ValueError(
                f&#34;2nd operand must be a Register and not a {type(index)}&#34;)

    if len(args) &gt; 2:
        raise ValueError(&#34;Too many arguments!&#34;)

    g.logger.debug(f&#34;Adding conditions for modes: {modes}&#34;)

    try:
        if &#39;zpx&#39; in modes and index is RegisterX and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))

        if &#39;zpy&#39; in modes and index is RegisterY and address.value and not address.indirect and address.value &lt; 0x100:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))

        if &#39;abx&#39; in modes and index is RegisterX and not address.indirect:
            if address.value is not None:
                if &#39;zpx&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpx&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abx&#39;, address=address))

        if &#39;aby&#39; in modes and index is RegisterY and not address.indirect:
            if address.value is not None:
                if &#39;zpy&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpy&#39;, address=address))
                elif address.value &gt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;aby&#39;, address=address))

        if &#39;abs&#39; in modes and index is None and address and not address.indirect:
            if address.value is not None:
                if &#39;zpg&#39; in modes and address.value &lt; 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;zpg&#39;, address=address))
                elif address.value &gt;= 0x100:
                    return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;abs&#39;, address=address))

        if &#39;rel&#39; in modes:
            if address.relative is not None:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;rel&#39;, address=address))

        if &#39;imm&#39; in modes and immediate is not None:
            if immediate.value is None:
                g._CURRENT_CONTEXT.need_label(immediate.name)
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imm&#39;, immediate=immediate))

        if &#39;imp&#39; in modes:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;imp&#39;))

        if &#39;iix&#39; in modes and index is RegisterX and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iix&#39;, address=address))

        if &#39;iiy&#39; in modes and index is RegisterY and address and address.indirect:
            if address.value and address.value &lt;= 0x100:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;iiy&#39;, address=address))

        if &#39;acc&#39; in modes and index is RegisterACC:
            return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;acc&#39;))

        if &#39;ind&#39; in modes:
            if address.value:
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
            else:
                g._CURRENT_CONTEXT.need_label(address.name)
                return g._CURRENT_CONTEXT.add_instruction(Instruction(mnemonic, &#39;ind&#39;, address=address))
    except Exception:
        import inspect
        # 0 represents this line,  1 represents line at caller
        callerframerecord = inspect.stack()[1]

        frame = callerframerecord[0]
        info = inspect.getframeinfo(frame)
        print(f&#34;Error: {info}&#34;)

        raise

    raise NotImplementedError(
        f&#34;No condition for {mnemonic} and args: {args}. Possible modes: {modes}&#34;)</code></pre>
</details>
</dd>
<dt id="shazzam.py64gen.word"><code class="name flex">
<span>def <span class="ident">word</span></span>(<span>value: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>[description]</dd>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def word(value: int) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        value (int): [description]

    Raises:
        RuntimeError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    if value &gt; 0xffff:
        raise ValueError(f&#34;Value exceed word size: {value}&#34;)

    byte([value &gt;&gt; 8, value &amp; 0xff])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="shazzam" href="index.html">shazzam</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="shazzam.py64gen.ADC" href="#shazzam.py64gen.ADC">ADC</a></code></li>
<li><code><a title="shazzam.py64gen.ALR" href="#shazzam.py64gen.ALR">ALR</a></code></li>
<li><code><a title="shazzam.py64gen.ANC" href="#shazzam.py64gen.ANC">ANC</a></code></li>
<li><code><a title="shazzam.py64gen.AND" href="#shazzam.py64gen.AND">AND</a></code></li>
<li><code><a title="shazzam.py64gen.ARR" href="#shazzam.py64gen.ARR">ARR</a></code></li>
<li><code><a title="shazzam.py64gen.ASL" href="#shazzam.py64gen.ASL">ASL</a></code></li>
<li><code><a title="shazzam.py64gen.BCC" href="#shazzam.py64gen.BCC">BCC</a></code></li>
<li><code><a title="shazzam.py64gen.BCS" href="#shazzam.py64gen.BCS">BCS</a></code></li>
<li><code><a title="shazzam.py64gen.BEQ" href="#shazzam.py64gen.BEQ">BEQ</a></code></li>
<li><code><a title="shazzam.py64gen.BIT" href="#shazzam.py64gen.BIT">BIT</a></code></li>
<li><code><a title="shazzam.py64gen.BMI" href="#shazzam.py64gen.BMI">BMI</a></code></li>
<li><code><a title="shazzam.py64gen.BNE" href="#shazzam.py64gen.BNE">BNE</a></code></li>
<li><code><a title="shazzam.py64gen.BPL" href="#shazzam.py64gen.BPL">BPL</a></code></li>
<li><code><a title="shazzam.py64gen.BRK" href="#shazzam.py64gen.BRK">BRK</a></code></li>
<li><code><a title="shazzam.py64gen.BVC" href="#shazzam.py64gen.BVC">BVC</a></code></li>
<li><code><a title="shazzam.py64gen.BVS" href="#shazzam.py64gen.BVS">BVS</a></code></li>
<li><code><a title="shazzam.py64gen.CLC" href="#shazzam.py64gen.CLC">CLC</a></code></li>
<li><code><a title="shazzam.py64gen.CLD" href="#shazzam.py64gen.CLD">CLD</a></code></li>
<li><code><a title="shazzam.py64gen.CLI" href="#shazzam.py64gen.CLI">CLI</a></code></li>
<li><code><a title="shazzam.py64gen.CLV" href="#shazzam.py64gen.CLV">CLV</a></code></li>
<li><code><a title="shazzam.py64gen.CMP" href="#shazzam.py64gen.CMP">CMP</a></code></li>
<li><code><a title="shazzam.py64gen.CPX" href="#shazzam.py64gen.CPX">CPX</a></code></li>
<li><code><a title="shazzam.py64gen.CPY" href="#shazzam.py64gen.CPY">CPY</a></code></li>
<li><code><a title="shazzam.py64gen.DCP" href="#shazzam.py64gen.DCP">DCP</a></code></li>
<li><code><a title="shazzam.py64gen.DEC" href="#shazzam.py64gen.DEC">DEC</a></code></li>
<li><code><a title="shazzam.py64gen.DEX" href="#shazzam.py64gen.DEX">DEX</a></code></li>
<li><code><a title="shazzam.py64gen.DEY" href="#shazzam.py64gen.DEY">DEY</a></code></li>
<li><code><a title="shazzam.py64gen.EOR" href="#shazzam.py64gen.EOR">EOR</a></code></li>
<li><code><a title="shazzam.py64gen.INC" href="#shazzam.py64gen.INC">INC</a></code></li>
<li><code><a title="shazzam.py64gen.INX" href="#shazzam.py64gen.INX">INX</a></code></li>
<li><code><a title="shazzam.py64gen.INY" href="#shazzam.py64gen.INY">INY</a></code></li>
<li><code><a title="shazzam.py64gen.ISC" href="#shazzam.py64gen.ISC">ISC</a></code></li>
<li><code><a title="shazzam.py64gen.JMP" href="#shazzam.py64gen.JMP">JMP</a></code></li>
<li><code><a title="shazzam.py64gen.JSR" href="#shazzam.py64gen.JSR">JSR</a></code></li>
<li><code><a title="shazzam.py64gen.LAX" href="#shazzam.py64gen.LAX">LAX</a></code></li>
<li><code><a title="shazzam.py64gen.LDA" href="#shazzam.py64gen.LDA">LDA</a></code></li>
<li><code><a title="shazzam.py64gen.LDX" href="#shazzam.py64gen.LDX">LDX</a></code></li>
<li><code><a title="shazzam.py64gen.LDY" href="#shazzam.py64gen.LDY">LDY</a></code></li>
<li><code><a title="shazzam.py64gen.LSR" href="#shazzam.py64gen.LSR">LSR</a></code></li>
<li><code><a title="shazzam.py64gen.NOP" href="#shazzam.py64gen.NOP">NOP</a></code></li>
<li><code><a title="shazzam.py64gen.ORA" href="#shazzam.py64gen.ORA">ORA</a></code></li>
<li><code><a title="shazzam.py64gen.PHA" href="#shazzam.py64gen.PHA">PHA</a></code></li>
<li><code><a title="shazzam.py64gen.PHP" href="#shazzam.py64gen.PHP">PHP</a></code></li>
<li><code><a title="shazzam.py64gen.PLA" href="#shazzam.py64gen.PLA">PLA</a></code></li>
<li><code><a title="shazzam.py64gen.PLP" href="#shazzam.py64gen.PLP">PLP</a></code></li>
<li><code><a title="shazzam.py64gen.RLA" href="#shazzam.py64gen.RLA">RLA</a></code></li>
<li><code><a title="shazzam.py64gen.ROL" href="#shazzam.py64gen.ROL">ROL</a></code></li>
<li><code><a title="shazzam.py64gen.ROR" href="#shazzam.py64gen.ROR">ROR</a></code></li>
<li><code><a title="shazzam.py64gen.RRA" href="#shazzam.py64gen.RRA">RRA</a></code></li>
<li><code><a title="shazzam.py64gen.RTI" href="#shazzam.py64gen.RTI">RTI</a></code></li>
<li><code><a title="shazzam.py64gen.RTS" href="#shazzam.py64gen.RTS">RTS</a></code></li>
<li><code><a title="shazzam.py64gen.SAX" href="#shazzam.py64gen.SAX">SAX</a></code></li>
<li><code><a title="shazzam.py64gen.SBC" href="#shazzam.py64gen.SBC">SBC</a></code></li>
<li><code><a title="shazzam.py64gen.SBX" href="#shazzam.py64gen.SBX">SBX</a></code></li>
<li><code><a title="shazzam.py64gen.SEC" href="#shazzam.py64gen.SEC">SEC</a></code></li>
<li><code><a title="shazzam.py64gen.SED" href="#shazzam.py64gen.SED">SED</a></code></li>
<li><code><a title="shazzam.py64gen.SEI" href="#shazzam.py64gen.SEI">SEI</a></code></li>
<li><code><a title="shazzam.py64gen.SLO" href="#shazzam.py64gen.SLO">SLO</a></code></li>
<li><code><a title="shazzam.py64gen.SRE" href="#shazzam.py64gen.SRE">SRE</a></code></li>
<li><code><a title="shazzam.py64gen.STA" href="#shazzam.py64gen.STA">STA</a></code></li>
<li><code><a title="shazzam.py64gen.STX" href="#shazzam.py64gen.STX">STX</a></code></li>
<li><code><a title="shazzam.py64gen.STY" href="#shazzam.py64gen.STY">STY</a></code></li>
<li><code><a title="shazzam.py64gen.TAX" href="#shazzam.py64gen.TAX">TAX</a></code></li>
<li><code><a title="shazzam.py64gen.TAY" href="#shazzam.py64gen.TAY">TAY</a></code></li>
<li><code><a title="shazzam.py64gen.TSX" href="#shazzam.py64gen.TSX">TSX</a></code></li>
<li><code><a title="shazzam.py64gen.TXA" href="#shazzam.py64gen.TXA">TXA</a></code></li>
<li><code><a title="shazzam.py64gen.TXS" href="#shazzam.py64gen.TXS">TXS</a></code></li>
<li><code><a title="shazzam.py64gen.TYA" href="#shazzam.py64gen.TYA">TYA</a></code></li>
<li><code><a title="shazzam.py64gen.adc" href="#shazzam.py64gen.adc">adc</a></code></li>
<li><code><a title="shazzam.py64gen.align" href="#shazzam.py64gen.align">align</a></code></li>
<li><code><a title="shazzam.py64gen.alr" href="#shazzam.py64gen.alr">alr</a></code></li>
<li><code><a title="shazzam.py64gen.anc" href="#shazzam.py64gen.anc">anc</a></code></li>
<li><code><a title="shazzam.py64gen.andr" href="#shazzam.py64gen.andr">andr</a></code></li>
<li><code><a title="shazzam.py64gen.arr" href="#shazzam.py64gen.arr">arr</a></code></li>
<li><code><a title="shazzam.py64gen.asl" href="#shazzam.py64gen.asl">asl</a></code></li>
<li><code><a title="shazzam.py64gen.assemble_prg" href="#shazzam.py64gen.assemble_prg">assemble_prg</a></code></li>
<li><code><a title="shazzam.py64gen.assemble_segment" href="#shazzam.py64gen.assemble_segment">assemble_segment</a></code></li>
<li><code><a title="shazzam.py64gen.at" href="#shazzam.py64gen.at">at</a></code></li>
<li><code><a title="shazzam.py64gen.bcc" href="#shazzam.py64gen.bcc">bcc</a></code></li>
<li><code><a title="shazzam.py64gen.bcs" href="#shazzam.py64gen.bcs">bcs</a></code></li>
<li><code><a title="shazzam.py64gen.beq" href="#shazzam.py64gen.beq">beq</a></code></li>
<li><code><a title="shazzam.py64gen.bit" href="#shazzam.py64gen.bit">bit</a></code></li>
<li><code><a title="shazzam.py64gen.bmi" href="#shazzam.py64gen.bmi">bmi</a></code></li>
<li><code><a title="shazzam.py64gen.bne" href="#shazzam.py64gen.bne">bne</a></code></li>
<li><code><a title="shazzam.py64gen.bpl" href="#shazzam.py64gen.bpl">bpl</a></code></li>
<li><code><a title="shazzam.py64gen.brk" href="#shazzam.py64gen.brk">brk</a></code></li>
<li><code><a title="shazzam.py64gen.bvc" href="#shazzam.py64gen.bvc">bvc</a></code></li>
<li><code><a title="shazzam.py64gen.bvs" href="#shazzam.py64gen.bvs">bvs</a></code></li>
<li><code><a title="shazzam.py64gen.byte" href="#shazzam.py64gen.byte">byte</a></code></li>
<li><code><a title="shazzam.py64gen.clc" href="#shazzam.py64gen.clc">clc</a></code></li>
<li><code><a title="shazzam.py64gen.cld" href="#shazzam.py64gen.cld">cld</a></code></li>
<li><code><a title="shazzam.py64gen.cli" href="#shazzam.py64gen.cli">cli</a></code></li>
<li><code><a title="shazzam.py64gen.clv" href="#shazzam.py64gen.clv">clv</a></code></li>
<li><code><a title="shazzam.py64gen.cmp" href="#shazzam.py64gen.cmp">cmp</a></code></li>
<li><code><a title="shazzam.py64gen.cpx" href="#shazzam.py64gen.cpx">cpx</a></code></li>
<li><code><a title="shazzam.py64gen.cpy" href="#shazzam.py64gen.cpy">cpy</a></code></li>
<li><code><a title="shazzam.py64gen.dcp" href="#shazzam.py64gen.dcp">dcp</a></code></li>
<li><code><a title="shazzam.py64gen.dec" href="#shazzam.py64gen.dec">dec</a></code></li>
<li><code><a title="shazzam.py64gen.dex" href="#shazzam.py64gen.dex">dex</a></code></li>
<li><code><a title="shazzam.py64gen.dey" href="#shazzam.py64gen.dey">dey</a></code></li>
<li><code><a title="shazzam.py64gen.emulate_program" href="#shazzam.py64gen.emulate_program">emulate_program</a></code></li>
<li><code><a title="shazzam.py64gen.eor" href="#shazzam.py64gen.eor">eor</a></code></li>
<li><code><a title="shazzam.py64gen.gen_code" href="#shazzam.py64gen.gen_code">gen_code</a></code></li>
<li><code><a title="shazzam.py64gen.gen_irqloader_script" href="#shazzam.py64gen.gen_irqloader_script">gen_irqloader_script</a></code></li>
<li><code><a title="shazzam.py64gen.generate" href="#shazzam.py64gen.generate">generate</a></code></li>
<li><code><a title="shazzam.py64gen.get_anonymous_label" href="#shazzam.py64gen.get_anonymous_label">get_anonymous_label</a></code></li>
<li><code><a title="shazzam.py64gen.get_current_address" href="#shazzam.py64gen.get_current_address">get_current_address</a></code></li>
<li><code><a title="shazzam.py64gen.get_label_address" href="#shazzam.py64gen.get_label_address">get_label_address</a></code></li>
<li><code><a title="shazzam.py64gen.get_segment_addresses" href="#shazzam.py64gen.get_segment_addresses">get_segment_addresses</a></code></li>
<li><code><a title="shazzam.py64gen.imm" href="#shazzam.py64gen.imm">imm</a></code></li>
<li><code><a title="shazzam.py64gen.inc" href="#shazzam.py64gen.inc">inc</a></code></li>
<li><code><a title="shazzam.py64gen.incbin" href="#shazzam.py64gen.incbin">incbin</a></code></li>
<li><code><a title="shazzam.py64gen.ind_at" href="#shazzam.py64gen.ind_at">ind_at</a></code></li>
<li><code><a title="shazzam.py64gen.inx" href="#shazzam.py64gen.inx">inx</a></code></li>
<li><code><a title="shazzam.py64gen.iny" href="#shazzam.py64gen.iny">iny</a></code></li>
<li><code><a title="shazzam.py64gen.isc" href="#shazzam.py64gen.isc">isc</a></code></li>
<li><code><a title="shazzam.py64gen.jmp" href="#shazzam.py64gen.jmp">jmp</a></code></li>
<li><code><a title="shazzam.py64gen.jsr" href="#shazzam.py64gen.jsr">jsr</a></code></li>
<li><code><a title="shazzam.py64gen.label" href="#shazzam.py64gen.label">label</a></code></li>
<li><code><a title="shazzam.py64gen.lax" href="#shazzam.py64gen.lax">lax</a></code></li>
<li><code><a title="shazzam.py64gen.lda" href="#shazzam.py64gen.lda">lda</a></code></li>
<li><code><a title="shazzam.py64gen.ldx" href="#shazzam.py64gen.ldx">ldx</a></code></li>
<li><code><a title="shazzam.py64gen.ldy" href="#shazzam.py64gen.ldy">ldy</a></code></li>
<li><code><a title="shazzam.py64gen.lsr" href="#shazzam.py64gen.lsr">lsr</a></code></li>
<li><code><a title="shazzam.py64gen.nop" href="#shazzam.py64gen.nop">nop</a></code></li>
<li><code><a title="shazzam.py64gen.optimize_segments" href="#shazzam.py64gen.optimize_segments">optimize_segments</a></code></li>
<li><code><a title="shazzam.py64gen.ora" href="#shazzam.py64gen.ora">ora</a></code></li>
<li><code><a title="shazzam.py64gen.pha" href="#shazzam.py64gen.pha">pha</a></code></li>
<li><code><a title="shazzam.py64gen.php" href="#shazzam.py64gen.php">php</a></code></li>
<li><code><a title="shazzam.py64gen.pla" href="#shazzam.py64gen.pla">pla</a></code></li>
<li><code><a title="shazzam.py64gen.plp" href="#shazzam.py64gen.plp">plp</a></code></li>
<li><code><a title="shazzam.py64gen.rasterline" href="#shazzam.py64gen.rasterline">rasterline</a></code></li>
<li><code><a title="shazzam.py64gen.rel_at" href="#shazzam.py64gen.rel_at">rel_at</a></code></li>
<li><code><a title="shazzam.py64gen.rla" href="#shazzam.py64gen.rla">rla</a></code></li>
<li><code><a title="shazzam.py64gen.rol" href="#shazzam.py64gen.rol">rol</a></code></li>
<li><code><a title="shazzam.py64gen.ror" href="#shazzam.py64gen.ror">ror</a></code></li>
<li><code><a title="shazzam.py64gen.rra" href="#shazzam.py64gen.rra">rra</a></code></li>
<li><code><a title="shazzam.py64gen.rti" href="#shazzam.py64gen.rti">rti</a></code></li>
<li><code><a title="shazzam.py64gen.rts" href="#shazzam.py64gen.rts">rts</a></code></li>
<li><code><a title="shazzam.py64gen.sax" href="#shazzam.py64gen.sax">sax</a></code></li>
<li><code><a title="shazzam.py64gen.sbc" href="#shazzam.py64gen.sbc">sbc</a></code></li>
<li><code><a title="shazzam.py64gen.sbx" href="#shazzam.py64gen.sbx">sbx</a></code></li>
<li><code><a title="shazzam.py64gen.sec" href="#shazzam.py64gen.sec">sec</a></code></li>
<li><code><a title="shazzam.py64gen.sed" href="#shazzam.py64gen.sed">sed</a></code></li>
<li><code><a title="shazzam.py64gen.segment" href="#shazzam.py64gen.segment">segment</a></code></li>
<li><code><a title="shazzam.py64gen.sei" href="#shazzam.py64gen.sei">sei</a></code></li>
<li><code><a title="shazzam.py64gen.set_prefs" href="#shazzam.py64gen.set_prefs">set_prefs</a></code></li>
<li><code><a title="shazzam.py64gen.slo" href="#shazzam.py64gen.slo">slo</a></code></li>
<li><code><a title="shazzam.py64gen.sre" href="#shazzam.py64gen.sre">sre</a></code></li>
<li><code><a title="shazzam.py64gen.sta" href="#shazzam.py64gen.sta">sta</a></code></li>
<li><code><a title="shazzam.py64gen.stx" href="#shazzam.py64gen.stx">stx</a></code></li>
<li><code><a title="shazzam.py64gen.sty" href="#shazzam.py64gen.sty">sty</a></code></li>
<li><code><a title="shazzam.py64gen.tax" href="#shazzam.py64gen.tax">tax</a></code></li>
<li><code><a title="shazzam.py64gen.tay" href="#shazzam.py64gen.tay">tay</a></code></li>
<li><code><a title="shazzam.py64gen.tsx" href="#shazzam.py64gen.tsx">tsx</a></code></li>
<li><code><a title="shazzam.py64gen.txa" href="#shazzam.py64gen.txa">txa</a></code></li>
<li><code><a title="shazzam.py64gen.txs" href="#shazzam.py64gen.txs">txs</a></code></li>
<li><code><a title="shazzam.py64gen.tya" href="#shazzam.py64gen.tya">tya</a></code></li>
<li><code><a title="shazzam.py64gen.word" href="#shazzam.py64gen.word">word</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>