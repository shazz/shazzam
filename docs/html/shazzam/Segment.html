<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>shazzam.Segment API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>shazzam.Segment</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import shazzam.globals as g
from shazzam.defs import CommentsFormat, DirectiveFormat, CodeFormat, Alias
from shazzam.Instruction import Instruction
from shazzam.Address import Address
from shazzam.ByteData import ByteData
from shazzam.Rasterline import Rasterline
from shazzam.Emu6502 import Emu6502
from shazzam.Immediate import Immediate

from enum import Enum
import binascii
from typing import List
import io
import logging

# ---------------------------------------------------------------------
# internal utils
# ---------------------------------------------------------------------


def _insert(source_str, insert_str, pos):
    &#34;&#34;&#34;[summary]

    Args:
        source_str ([type]): [description]
        insert_str ([type]): [description]
        pos ([type]): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    return source_str[:pos] + insert_str + source_str[pos:len(source_str)-len(insert_str)]

# ---------------------------------------------------------------------
# Segment class
# ---------------------------------------------------------------------
class SegmentType(Enum):
    CODE = 0
    REGISTERS = 1
    SPRITE = 2
    CHARACTERS = 3
    SCREEN_MEM = 4
    BITMAP = 5
    GENERIC_DATA = 6


class Segment():
    &#34;&#34;&#34;Segment class&#34;&#34;&#34;
    comments_chars = {
        CommentsFormat.USE_SEMICOLON: &#39;;&#39;,
        CommentsFormat.USE_SHARP: &#34;#&#34;,
        CommentsFormat.USE_SLASH: &#34;//&#34;
    }

    directive_prefix = {
        DirectiveFormat.NO_PREFIX: &#39;&#39;,
        DirectiveFormat.USE_DOT: &#39;.&#39;,
        DirectiveFormat.USE_EXCLAMATION: &#39;!&#39;
    }

    def __init__(self, start_adr: int, name: str,
                code_format: List[CodeFormat] = None, comments_format: CommentsFormat = None,
                directive_prefix: DirectiveFormat = None, use_relative_addressing: bool = False,
                fixed_address: bool = False, segment_type: SegmentType = SegmentType.CODE, group: int = None):
        &#34;&#34;&#34;[summary]

        Args:
            start_adr (int): [description]
            name (str): [description]
            code_format (List[CodeFormat], optional): [description]. Defaults to None.
            comments_format (CommentsFormat, optional): [description]. Defaults to CommentsFormat.USE_SEMICOLON.
            directive_prefix (DirectiveFormat, optional): [description]. Defaults to DirectiveFormat.USE_DOT.
        &#34;&#34;&#34;
        self.logger = logging.getLogger(&#34;shazzam&#34;)
        self.start_adr = start_adr
        self.end_adr = start_adr
        self.fixed_start_address = start_adr if fixed_address else None
        self.instructions = {}
        self.next_position = start_adr
        self.name = name
        self.total_cycles_used = 0
        self.labels = {}
        self.required_labels = {}
        self.use_relative_addressing = use_relative_addressing
        self.segment_type = segment_type
        self.group = group

        if code_format is None:
            code_format = g._CODE_FORMAT
        if comments_format is None:
            comments_format = g._COMMENTS_FORMAT
        if directive_prefix is None:
            directive_prefix = g._DIRECTIVE_PREFIX

        self.logger.debug(&#34;Prefs: {code_format} / {comments_format} / {directive_prefix}&#34;)

        self.show_address = True if CodeFormat.ADDRESS in code_format else False
        self.show_bytecode = True if CodeFormat.BYTECODE in code_format else False
        self.show_cycles = True if CodeFormat.CYCLES in code_format else False
        self.use_uppercase = True if CodeFormat.UPPERCASE in code_format else False
        self.use_hex = True if CodeFormat.USE_HEX in code_format else False
        self.show_labels = True if CodeFormat.SHOW_LABELS in code_format else False

        self.comment_char = Segment.comments_chars[comments_format]
        self.directive_prefix = Segment.directive_prefix[directive_prefix]

        self.rasterlines = {}
        self.anonymous_labels = {}

    @property
    def size(self):
        return self.end_adr - self.start_adr

    def change_format(self):
        &#34;&#34;&#34;change_format&#34;&#34;&#34;
        code_format = g._CODE_FORMAT
        comments_format = g._COMMENTS_FORMAT
        directive_prefix = g._DIRECTIVE_PREFIX

        self.logger.debug(f&#34;Reset Prefs: {code_format} / {comments_format} / {directive_prefix}&#34;)

        self.show_address = True if CodeFormat.ADDRESS in code_format else False
        self.show_bytecode = True if CodeFormat.BYTECODE in code_format else False
        self.show_cycles = True if CodeFormat.CYCLES in code_format else False
        self.use_uppercase = True if CodeFormat.UPPERCASE in code_format else False
        self.use_hex = True if CodeFormat.USE_HEX in code_format else False
        self.show_labels = True if CodeFormat.SHOW_LABELS in code_format else False

    def close(self) -&gt; None:
        &#34;&#34;&#34;[summary]&#34;&#34;&#34;
        self.end_adr = self.next_position

    def add_instruction(self, instr: Instruction) -&gt; bytearray:
        &#34;&#34;&#34;[summary]

        Args:
            instr (Instruction): [description]

        Returns:
            bytearray: [description]
        &#34;&#34;&#34;
        self.instructions[self.next_position] = instr
        self.next_position += instr.get_size()
        self.total_cycles_used += instr.get_cycle_count()
        instr.end_address = self.next_position

        # check size, relative addresses,...
        instr.check_constraints()

        if g._CURRENT_RASTER is not None:
            self.logger.debug(f&#34;Adding {instr} to rasterline&#34;)
            g._CURRENT_RASTER.add_cycles(instr.get_cycle_count())

        try:
            bcode = self.get_bytecode(instr)
            instr.bytecode = bcode
        except Exception as e:
            g.logger.debug(
                f&#34;bytecode cannot be generated yet, will be resolve later! [{e}]&#34;)

        return instr

    def add_byte(self, immediate: Immediate) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            immediate (Immediate): [description]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        data = ByteData(immediate)
        self.instructions[self.next_position] = data
        self.next_position += 1
        self.logger.debug(
            f&#34;added byte {immediate.value} at {self.next_position-1:04X}, next pos is not {self.next_position:04X}&#34;)

        return self.get_bytecode(data)

    def add_label(self, name: str) -&gt; Address:
        &#34;&#34;&#34;Add segment label

        Args:
            name (str): [description]

        Raises:
            ValueError: [description]

        Returns:
            Address: [description]
        &#34;&#34;&#34;
        if name in self.labels:
            raise ValueError(
                f&#34;Label {name} already defined in segment at {self.labels[name]}&#34;)

        self.labels[name] = Address(name=name, value=self.next_position)

        return self.labels[name]

    def get_label(self, name: str) -&gt; Address:
        &#34;&#34;&#34;get_label

        Args:
            name (str): [description]

        Raises:
            ValueError: [description]

        Returns:
            Address: [description]
        &#34;&#34;&#34;
        if name not in self.labels:
            self.logger.warning(f&#34;label &#39;{name}&#39; cannot be found in segment&#34;)
            raise ValueError(f&#34;Cannot find label &#39;{name}&#39; in segment&#34;)

        return self.labels[name]

    def need_label(self, name: str, relative: bool = False) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            label (str): [description]
            relative (bool, optional): [description]. Defaults to False.
        &#34;&#34;&#34;
        self.required_labels[name] = {
            &#34;from&#34;: self.next_position,
            &#34;relative&#34;: relative
        }

    def get_segment_bytecode(self) -&gt; bytearray:
        &#34;&#34;&#34;get_segment_bytecode

        Returns:
            bytearray: [description]
        &#34;&#34;&#34;
        self.resolve_labels()

        bytecode = bytearray([])
        for adr, instr in self.instructions.items():
            bcode = self.get_bytecode(instr)
            bytecode += bcode

        return bytecode

    def get_bytecode(self, instr: Instruction) -&gt; bytearray:
        &#34;&#34;&#34;[summary]

        Args:
            instr (Instruction): [description]

        Returns:
            bytearray: [description]
        &#34;&#34;&#34;
        ope = instr.get_operand()
        op = instr.get_opcode()

        if ope is not None:
            if instr.get_size() == 2+1:
                self.logger.debug(
                    f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:04X}&#34;)
                data = [op, ope &amp; 0xff, (ope &gt;&gt; 8) &amp; 0xff]
            else:
                self.logger.debug(
                    f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:02X}&#34;)
                data = [op, ope &amp; 0xff]
        else:
            self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X}&#34;)
            data = [instr.get_opcode()]

        self.logger.debug(f&#34;Got bytecode for {instr}: {data}&#34;)

        return bytearray(data)

    def resolve_labels(self) -&gt; None:
        &#34;&#34;&#34;Replace all instructions with their absolute address.

        Raises:
            ValueError: [description]
            ValueError: [description]
        &#34;&#34;&#34;
        # move end of segment labels
        for label, adr in self.labels.items():
            if adr.value == self.end_adr:
                adr.value = max(list(self.instructions.keys()))
                self.logger.info(f&#34;Label {label} moved to address ${adr.value:04X}&#34;)

        # check labels
        self.logger.debug(f&#34;Required labels: {self.required_labels}&#34;)
        for label, params in self.required_labels.items():

            if (label not in self.labels) and (label not in g._PROGRAM.global_labels):
                self.logger.debug(&#34;global labels:&#34;, g._PROGRAM.global_labels)
                raise ValueError(
                    f&#34;Label {label} is used but not defined locally or globally!&#34;)

            if params[&#39;relative&#39;] and abs(params[&#39;from&#39;] - self.labels[label].address) &gt; 255:
                raise ValueError(
                    f&#34;Label {label} branch at {params[&#39;from&#39;]} is more than 1 bytes!&#34;)

        # resolve labels now!
        for adr, instr in self.instructions.items():
            self.logger.debug(f&#34;Checking label for {instr} at {adr:04X}&#34;)

            if instr.immediate and instr.immediate.name:
                self.logger.debug(
                    f&#34;-&gt; immediate label name: {instr.immediate.name}&#34;)

                if instr.immediate.name in self.labels:

                    val = self.labels[instr.immediate.name].value &amp; 0xff if not instr.immediate.high_byte else (
                        self.labels[instr.immediate.name].value &gt;&gt; 8) &amp; 0xff

                    instr.immediate.value = val
                    instr.immediate.name = self.labels[instr.immediate.name].name

                elif instr.immediate.name in g._PROGRAM.global_labels:
                    val = g._PROGRAM.global_labels[instr.immediate.name].value &amp; 0xff if not instr.immediate.high_byte else (
                        g._PROGRAM.global_labels[instr.immediate.name].value &gt;&gt; 8) &amp; 0xff

                    instr.immediate.value = val
                    instr.immediate.name = g._PROGRAM.global_labels[instr.immediate.name].name
                else:
                    raise ValueError(
                        f&#34;Label {label} cannot be resolved locally or globally!&#34;)

            elif instr.address and instr.address.name:
                self.logger.debug(
                    f&#34;-&gt; address label name: {instr.address.name}&#34;)
                if instr.address.name in self.labels:

                    if instr.mode == &#39;rel&#39;:
                        self.logger.debug(
                            f&#34;label address: {self.labels[instr.address.name].value}&#34;)
                        instr.address.value = self.labels[instr.address.name].value
                        if adr &lt; self.labels[instr.address.name].value:
                            instr.address.relative = self.labels[instr.address.name].value - adr - instr.get_size(
                            )
                        else:
                            instr.address.relative = adr - \
                                self.labels[instr.address.name].value - \
                                instr.get_size()

                        self.logger.debug(
                            f&#34;Use relative addressing to label {instr.address.name} at {self.labels[instr.address.name].value:04X} from {adr:04X}&#34;)
                    else:
                        instr.address.value = self.labels[instr.address.name].value
                        instr.address.name = self.labels[instr.address.name].name

                elif instr.address.name in g._PROGRAM.global_labels:
                    instr.address.value = g._PROGRAM.global_labels[instr.address.name].value
                    instr.address.name = g._PROGRAM.global_labels[instr.address.name].name
                else:
                    raise ValueError(
                        f&#34;Label {label} cannot be resolved locally or globally!&#34;)

                self.logger.debug(
                    f&#34;Label {instr.address.name} replaced by absolute address {instr.address.value:04X}&#34;)

    def gen_code(self, listing: bool = False) -&gt; None:
        &#34;&#34;&#34;Generates assembly code.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        self.resolve_labels()

        code = []

        # add globals import/export
        locals_labels = list(self.labels.keys())
        globals_labels = list(g._PROGRAM.global_labels.keys())

        for label in globals_labels:
            if label not in locals_labels:
                code.append(f&#39;\t\t{self.directive_prefix}import {label}\n&#39;)
            else:
                code.append(f&#39;\t\t{self.directive_prefix}export {label}\n&#39;)

        code.append(&#39;\n&#39;)

        # add segment directive
        code.append(f&#39;\t\t{self.directive_prefix}segment &#34;{self.name}&#34;\n&#39;)

        # get longest label

        if len(locals_labels) &gt; 0:
            label_size = max(10, len(max(locals_labels)) + 8)
        else:
            label_size = 10

        self.logger.debug(f&#34;Label size: {label_size}&#34;)

        if listing:

            self.logger.debug(&#34;Generating listing&#34;)
            listing_template_index = {
                &#34;address&#34;: 0,
                &#34;bytecode&#34;: 8 if self.show_address else 0,
                &#34;label&#34;: 40 if self.show_bytecode else 8 if self.show_address else 0,
                &#34;instruction&#34;: 40+label_size if self.show_bytecode else 8+label_size if self.show_address else label_size,
                &#34;cycles&#34;: 40+label_size+20 if self.show_bytecode else 38+label_size+20 if self.show_address else label_size+20,
            }

            remaining_bytes_to_process = 0
            for adr, instr in self.instructions.items():

                instr.show_labels = False

                if self.use_uppercase:
                    instr.use_upper = True
                if self.use_hex:
                    instr.use_hex = True

                label = [k for k, v in self.labels.items() if v.value == adr]

                # substract start address if relative addressing
                address_offset = self.start_adr if self.use_relative_addressing else 0

                if isinstance(instr, ByteData):
                    if remaining_bytes_to_process != 0:
                        remaining_bytes_to_process -= 1
                    else:
                        prefix = self.directive_prefix

                        nb_bytes = 0
                        nolabel = True
                        try:
                            while adr+nb_bytes in self.instructions and nolabel and isinstance(self.instructions[adr+nb_bytes], ByteData):
                                nb_bytes += 1
                                nolabel = len([k for k, v in self.labels.items() if v.value == adr+nb_bytes]) == 0
                        except KeyError:
                            self.logger.error(f&#34;Could not find address {adr+nb_bytes} (${adr+nb_bytes:04X}) in {self.instructions.keys()}&#34;)
                            raise


                        remaining_bytes_to_process = nb_bytes - 1
                        self.logger.debug(f&#34;{nb_bytes} bytes of data before instruction&#34;)
                        if nb_bytes &gt; 8:

                            # manage the remaining bytes if not a multiple of 8
                            nb_rows = nb_bytes // 8 + 1 if nb_bytes % 8 != 0 else nb_bytes // 8

                            for row in range(nb_rows):

                                r_label = [k for k, v in self.labels.items() if v.value == adr+(row*8)]
                                s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                                s_address = f&#34;{adr+(row*8)-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                                bcode = &#34;&#34;
                                for b in range(min(8, nb_bytes-(8*row))):
                                    bytedata = self.instructions[adr+(row*8)+b]
                                    g_bcode = self.get_bytecode(bytedata)
                                    bcode += str(binascii.hexlify(g_bcode)
                                                 )[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                                bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                                bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                                line = &#39; &#39;*100
                                if self.show_address:
                                    line = _insert(line, s_address, listing_template_index[&#34;address&#34;])
                                if self.show_bytecode:
                                    line = _insert(line, bcode1, listing_template_index[&#34;bytecode&#34;])

                                line = _insert(line, s_label, listing_template_index[&#34;label&#34;])
                                line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, listing_template_index[&#34;instruction&#34;])
                                line.strip()
                                line += &#39;\n&#39;

                                code.append(line)
                        else:
                            s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;

                            r_label = [k for k, v in self.labels.items() if v.value == adr]
                            s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                            bcode = &#34;&#34;
                            for b in range(nb_bytes):
                                bytedata = self.instructions[adr+b]
                                g_bcode = self.get_bytecode(bytedata)
                                bcode += str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                            bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                            bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                            line = &#39; &#39;*100
                            if self.show_address:
                                line = _insert(line, s_address, listing_template_index[&#34;address&#34;])
                            if self.show_bytecode:
                                line = _insert(line, bcode1, listing_template_index[&#34;bytecode&#34;])

                            line = _insert(line, s_label, listing_template_index[&#34;label&#34;])
                            line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, listing_template_index[&#34;instruction&#34;])
                            line.strip()
                            line += &#39;\n&#39;

                            code.append(line)
                else:
                    s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;

                    if len(label) &gt; 1:
                        self.logger.warning(f&#34;Mutiple labels ({label}) for the same address {adr:04X}&#34;)

                    s_label = f&#34;{label[0]}:&#34; if label else &#34;&#34;
                    g_bcode = self.get_bytecode(instr)

                    # remove leading &#39;b and trailing &#39;. Ex: bytearray(b&#39;\xa9\x0b&#39;) A90B
                    bcode = str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()
                    bcode = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                    s_bytecode = f&#34;{bcode}&#34; if self.show_bytecode else &#34;&#34;

                    cycles = instr.get_cycle_count()
                    bytes_used = instr.get_size()
                    s_cycles = f&#34;{self.comment_char} #{cycles} - {bytes_used}&#34; if self.show_cycles and cycles &gt; 0 else &#34;&#34;

                    prefix = self.directive_prefix if isinstance(instr, ByteData) else &#39;&#39;

                    line = &#39; &#39;*100
                    line = _insert(line, s_address, listing_template_index[&#34;address&#34;])
                    line = _insert(line, s_bytecode, listing_template_index[&#34;bytecode&#34;])
                    line = _insert(line, s_label, listing_template_index[&#34;label&#34;])
                    line = _insert(line, f&#34;{prefix}{instr}&#34;, listing_template_index[&#34;instruction&#34;])
                    line = _insert(line, s_cycles, listing_template_index[&#34;cycles&#34;])
                    line.strip()
                    line += &#39;\n&#39;

                    code.append(line)

        else:
            self.logger.debug(&#34;Generating assembly code&#34;)
            code_template_index = {
                &#34;label&#34;: 0,
                &#34;instruction&#34;: label_size,
                &#34;cycles&#34;: label_size+30,
            }

            remaining_bytes_to_process = 0
            for adr, instr in self.instructions.items():

                instr.show_labels = True

                if self.use_uppercase:
                    instr.use_upper = True
                if self.use_hex:
                    instr.use_hex = True

                label = [k for k, v in self.labels.items() if v.value == adr]

                # substract start address if relative addressing
                address_offset = self.start_adr if self.use_relative_addressing else 0

                if isinstance(instr, ByteData):
                    if remaining_bytes_to_process != 0:
                        remaining_bytes_to_process -= 1
                    else:
                        self.logger.debug(f&#34;Starting processing bytes at ${adr:04X}&#34;)
                        prefix = self.directive_prefix
                        nb_bytes = 0
                        nolabel = True
                        try:
                            while adr+nb_bytes in self.instructions and nolabel and isinstance(self.instructions[adr+nb_bytes], ByteData):
                                nb_bytes += 1
                                nolabel = len([k for k, v in self.labels.items() if v.value == adr+nb_bytes]) == 0
                        except KeyError:
                            self.logger.error(f&#34;Could not find address {adr+nb_bytes} (${adr+nb_bytes:04X}) in {self.instructions.keys()}&#34;)
                            raise

                        remaining_bytes_to_process = nb_bytes - 1
                        self.logger.debug(f&#34;{nb_bytes} bytes ({remaining_bytes_to_process}) of data before instruction&#34;)
                        if nb_bytes &gt; 8:

                            # manage the remaining bytes if not a multiple of 8
                            nb_rows = nb_bytes // 8 + 1 if nb_bytes % 8 != 0 else nb_bytes // 8

                            for row in range(nb_rows):

                                r_label = [k for k, v in self.labels.items() if v.value == adr+(row*8)]
                                self.logger.debug(f&#34;labels found at {adr+(row*8):04X} : {r_label}&#34;)
                                s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                                bcode = &#34;&#34;
                                for b in range(min(8, nb_bytes-(8*row))):
                                    bytedata = self.instructions[adr+(row*8)+b]
                                    g_bcode = self.get_bytecode(bytedata)
                                    bcode += str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                                bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                                line = &#39; &#39;*100
                                line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                                line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                                line.strip()
                                line += &#39;\n&#39;

                                code.append(line)
                        else:
                            r_label = [k for k, v in self.labels.items() if v.value == adr]
                            self.logger.debug(f&#34;labels found at {adr:04X} : {r_label}&#34;)
                            s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                            bcode = &#34;&#34;
                            for b in range(nb_bytes):
                                bytedata = self.instructions[adr+b]
                                g_bcode = self.get_bytecode(bytedata)
                                bcode += str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                            bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                            line = &#39; &#39;*100
                            line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                            line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                            line.strip()
                            line += &#39;\n&#39;

                            code.append(line)
                else:
                    if len(label) &gt; 1:
                        self.logger.warning(f&#34;Mutiple labels ({label}) for the same address {adr:04X}&#34;)
                        for i in range(len(label)-1):
                            s_label = f&#34;{label[i]}:&#34;
                            line = &#39; &#39;*100
                            line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                            line.strip()
                            line += &#39;\n&#39;
                            code.append(line)

                    s_label = f&#34;{label[-1]}:&#34; if label else &#34;&#34;
                    cycles = instr.get_cycle_count()
                    bytes_used = instr.get_size()
                    s_cycles = f&#34;{self.comment_char} #{cycles} - {bytes_used}&#34; if self.show_cycles and cycles &gt; 0 else &#34;&#34;


                    prefix = self.directive_prefix if isinstance(instr, ByteData) else &#39;&#39;

                    line = &#39; &#39;*100
                    line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                    line = _insert(line, f&#34;{prefix}{instr}&#34;, code_template_index[&#34;instruction&#34;])
                    line = _insert(line, s_cycles, code_template_index[&#34;cycles&#34;])
                    line.strip()
                    line += &#39;\n&#39;

                    code.append(line)

        return code

    def emulate(self, start_address: int = None):
        &#34;&#34;&#34;Emulates the code from start_address .

        Args:
            start_address (int, optional): [description]. Defaults to None.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        self.resolve_labels()

        if start_address is None:
            start_address = self.start_adr

        emu = Emu6502()
        ram = io.BytesIO(self.get_segment_bytecode())

        self.logger.info(
            f&#34;Emulating from {self.start_adr:04X}, to {self.next_position:04X} starting at {start_address:04X}&#34;)

        cpu_state, mmu_state, cycles_used = emu.load_and_run(ram, self.start_adr, self.next_position, start_address)

        return cpu_state, mmu_state, cycles_used

    def get_last_instruction(self) -&gt; Instruction:
        &#34;&#34;&#34;[summary]

        Returns:
            Instruction: [description]
        &#34;&#34;&#34;
        self.logger.debug(
            f&#34;Instructions in the current segment: {list(self.instructions.keys())}&#34;)
        return self.instructions[list(self.instructions.keys())[-1]]

    def get_stats(self):
        &#34;&#34;&#34;[summary]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if len(self.instructions) == 0:
            return Alias({
                &#34;start_address&#34;: hex(self.start_adr),
            })

        last_instr = self.get_last_instruction()
        return Alias({
            &#34;size&#34;: self.next_position - self.start_adr,
            &#34;cycles&#34;: self.total_cycles_used,
            &#34;instructions&#34;: len(self.instructions),
            &#34;start_address&#34;: hex(self.start_adr),
            &#34;current_address&#34;: hex(self.next_position),
            &#34;last_instruction&#34;: {
                &#34;code&#34;: str(last_instr),
                &#34;size&#34;: last_instr.get_size(),
                &#34;cycles&#34;: last_instr.get_cycle_count()
            }
        })

    def get_anonymous_label(self, prefix: str) -&gt; str:
        &#34;&#34;&#34;Generate an anonymous label, in a macro for example

        Args:
            prefix (str): [description]

        Returns:
            str: [description]
        &#34;&#34;&#34;
        if prefix not in self.anonymous_labels:
            self.anonymous_labels[prefix] = 0
        else:
            self.anonymous_labels[prefix] += 1

        return f&#34;_{prefix}_{self.anonymous_labels[prefix]}&#34;

    # def checksum(self) -&gt; int:
    #     return reduce(lambda x,y : hashlib.md5((x+y).encode()).hexdigest(), [item.hash() for item in self.instructions.values()])

    def add_rasterline(self, index: int, rasterline: Rasterline) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            index (int): [description]
            rasterline (Rasterline): [description]
        &#34;&#34;&#34;
        self.rasterlines[index] = rasterline</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="shazzam.Segment.Segment"><code class="flex name class">
<span>class <span class="ident">Segment</span></span>
<span>(</span><span>start_adr: int, name: str, code_format: List[<a title="shazzam.defs.CodeFormat" href="defs.html#shazzam.defs.CodeFormat">CodeFormat</a>] = None, comments_format: <a title="shazzam.defs.CommentsFormat" href="defs.html#shazzam.defs.CommentsFormat">CommentsFormat</a> = None, directive_prefix: <a title="shazzam.defs.DirectiveFormat" href="defs.html#shazzam.defs.DirectiveFormat">DirectiveFormat</a> = None, use_relative_addressing: bool = False, fixed_address: bool = False, segment_type: <a title="shazzam.Segment.SegmentType" href="#shazzam.Segment.SegmentType">SegmentType</a> = SegmentType.CODE, group: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Segment class</p>
<p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_adr</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>code_format</code></strong> :&ensp;<code>List[CodeFormat]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>comments_format</code></strong> :&ensp;<code>CommentsFormat</code>, optional</dt>
<dd>[description]. Defaults to CommentsFormat.USE_SEMICOLON.</dd>
<dt><strong><code>directive_prefix</code></strong> :&ensp;<code>DirectiveFormat</code>, optional</dt>
<dd>[description]. Defaults to DirectiveFormat.USE_DOT.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Segment():
    &#34;&#34;&#34;Segment class&#34;&#34;&#34;
    comments_chars = {
        CommentsFormat.USE_SEMICOLON: &#39;;&#39;,
        CommentsFormat.USE_SHARP: &#34;#&#34;,
        CommentsFormat.USE_SLASH: &#34;//&#34;
    }

    directive_prefix = {
        DirectiveFormat.NO_PREFIX: &#39;&#39;,
        DirectiveFormat.USE_DOT: &#39;.&#39;,
        DirectiveFormat.USE_EXCLAMATION: &#39;!&#39;
    }

    def __init__(self, start_adr: int, name: str,
                code_format: List[CodeFormat] = None, comments_format: CommentsFormat = None,
                directive_prefix: DirectiveFormat = None, use_relative_addressing: bool = False,
                fixed_address: bool = False, segment_type: SegmentType = SegmentType.CODE, group: int = None):
        &#34;&#34;&#34;[summary]

        Args:
            start_adr (int): [description]
            name (str): [description]
            code_format (List[CodeFormat], optional): [description]. Defaults to None.
            comments_format (CommentsFormat, optional): [description]. Defaults to CommentsFormat.USE_SEMICOLON.
            directive_prefix (DirectiveFormat, optional): [description]. Defaults to DirectiveFormat.USE_DOT.
        &#34;&#34;&#34;
        self.logger = logging.getLogger(&#34;shazzam&#34;)
        self.start_adr = start_adr
        self.end_adr = start_adr
        self.fixed_start_address = start_adr if fixed_address else None
        self.instructions = {}
        self.next_position = start_adr
        self.name = name
        self.total_cycles_used = 0
        self.labels = {}
        self.required_labels = {}
        self.use_relative_addressing = use_relative_addressing
        self.segment_type = segment_type
        self.group = group

        if code_format is None:
            code_format = g._CODE_FORMAT
        if comments_format is None:
            comments_format = g._COMMENTS_FORMAT
        if directive_prefix is None:
            directive_prefix = g._DIRECTIVE_PREFIX

        self.logger.debug(&#34;Prefs: {code_format} / {comments_format} / {directive_prefix}&#34;)

        self.show_address = True if CodeFormat.ADDRESS in code_format else False
        self.show_bytecode = True if CodeFormat.BYTECODE in code_format else False
        self.show_cycles = True if CodeFormat.CYCLES in code_format else False
        self.use_uppercase = True if CodeFormat.UPPERCASE in code_format else False
        self.use_hex = True if CodeFormat.USE_HEX in code_format else False
        self.show_labels = True if CodeFormat.SHOW_LABELS in code_format else False

        self.comment_char = Segment.comments_chars[comments_format]
        self.directive_prefix = Segment.directive_prefix[directive_prefix]

        self.rasterlines = {}
        self.anonymous_labels = {}

    @property
    def size(self):
        return self.end_adr - self.start_adr

    def change_format(self):
        &#34;&#34;&#34;change_format&#34;&#34;&#34;
        code_format = g._CODE_FORMAT
        comments_format = g._COMMENTS_FORMAT
        directive_prefix = g._DIRECTIVE_PREFIX

        self.logger.debug(f&#34;Reset Prefs: {code_format} / {comments_format} / {directive_prefix}&#34;)

        self.show_address = True if CodeFormat.ADDRESS in code_format else False
        self.show_bytecode = True if CodeFormat.BYTECODE in code_format else False
        self.show_cycles = True if CodeFormat.CYCLES in code_format else False
        self.use_uppercase = True if CodeFormat.UPPERCASE in code_format else False
        self.use_hex = True if CodeFormat.USE_HEX in code_format else False
        self.show_labels = True if CodeFormat.SHOW_LABELS in code_format else False

    def close(self) -&gt; None:
        &#34;&#34;&#34;[summary]&#34;&#34;&#34;
        self.end_adr = self.next_position

    def add_instruction(self, instr: Instruction) -&gt; bytearray:
        &#34;&#34;&#34;[summary]

        Args:
            instr (Instruction): [description]

        Returns:
            bytearray: [description]
        &#34;&#34;&#34;
        self.instructions[self.next_position] = instr
        self.next_position += instr.get_size()
        self.total_cycles_used += instr.get_cycle_count()
        instr.end_address = self.next_position

        # check size, relative addresses,...
        instr.check_constraints()

        if g._CURRENT_RASTER is not None:
            self.logger.debug(f&#34;Adding {instr} to rasterline&#34;)
            g._CURRENT_RASTER.add_cycles(instr.get_cycle_count())

        try:
            bcode = self.get_bytecode(instr)
            instr.bytecode = bcode
        except Exception as e:
            g.logger.debug(
                f&#34;bytecode cannot be generated yet, will be resolve later! [{e}]&#34;)

        return instr

    def add_byte(self, immediate: Immediate) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            immediate (Immediate): [description]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        data = ByteData(immediate)
        self.instructions[self.next_position] = data
        self.next_position += 1
        self.logger.debug(
            f&#34;added byte {immediate.value} at {self.next_position-1:04X}, next pos is not {self.next_position:04X}&#34;)

        return self.get_bytecode(data)

    def add_label(self, name: str) -&gt; Address:
        &#34;&#34;&#34;Add segment label

        Args:
            name (str): [description]

        Raises:
            ValueError: [description]

        Returns:
            Address: [description]
        &#34;&#34;&#34;
        if name in self.labels:
            raise ValueError(
                f&#34;Label {name} already defined in segment at {self.labels[name]}&#34;)

        self.labels[name] = Address(name=name, value=self.next_position)

        return self.labels[name]

    def get_label(self, name: str) -&gt; Address:
        &#34;&#34;&#34;get_label

        Args:
            name (str): [description]

        Raises:
            ValueError: [description]

        Returns:
            Address: [description]
        &#34;&#34;&#34;
        if name not in self.labels:
            self.logger.warning(f&#34;label &#39;{name}&#39; cannot be found in segment&#34;)
            raise ValueError(f&#34;Cannot find label &#39;{name}&#39; in segment&#34;)

        return self.labels[name]

    def need_label(self, name: str, relative: bool = False) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            label (str): [description]
            relative (bool, optional): [description]. Defaults to False.
        &#34;&#34;&#34;
        self.required_labels[name] = {
            &#34;from&#34;: self.next_position,
            &#34;relative&#34;: relative
        }

    def get_segment_bytecode(self) -&gt; bytearray:
        &#34;&#34;&#34;get_segment_bytecode

        Returns:
            bytearray: [description]
        &#34;&#34;&#34;
        self.resolve_labels()

        bytecode = bytearray([])
        for adr, instr in self.instructions.items():
            bcode = self.get_bytecode(instr)
            bytecode += bcode

        return bytecode

    def get_bytecode(self, instr: Instruction) -&gt; bytearray:
        &#34;&#34;&#34;[summary]

        Args:
            instr (Instruction): [description]

        Returns:
            bytearray: [description]
        &#34;&#34;&#34;
        ope = instr.get_operand()
        op = instr.get_opcode()

        if ope is not None:
            if instr.get_size() == 2+1:
                self.logger.debug(
                    f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:04X}&#34;)
                data = [op, ope &amp; 0xff, (ope &gt;&gt; 8) &amp; 0xff]
            else:
                self.logger.debug(
                    f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:02X}&#34;)
                data = [op, ope &amp; 0xff]
        else:
            self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X}&#34;)
            data = [instr.get_opcode()]

        self.logger.debug(f&#34;Got bytecode for {instr}: {data}&#34;)

        return bytearray(data)

    def resolve_labels(self) -&gt; None:
        &#34;&#34;&#34;Replace all instructions with their absolute address.

        Raises:
            ValueError: [description]
            ValueError: [description]
        &#34;&#34;&#34;
        # move end of segment labels
        for label, adr in self.labels.items():
            if adr.value == self.end_adr:
                adr.value = max(list(self.instructions.keys()))
                self.logger.info(f&#34;Label {label} moved to address ${adr.value:04X}&#34;)

        # check labels
        self.logger.debug(f&#34;Required labels: {self.required_labels}&#34;)
        for label, params in self.required_labels.items():

            if (label not in self.labels) and (label not in g._PROGRAM.global_labels):
                self.logger.debug(&#34;global labels:&#34;, g._PROGRAM.global_labels)
                raise ValueError(
                    f&#34;Label {label} is used but not defined locally or globally!&#34;)

            if params[&#39;relative&#39;] and abs(params[&#39;from&#39;] - self.labels[label].address) &gt; 255:
                raise ValueError(
                    f&#34;Label {label} branch at {params[&#39;from&#39;]} is more than 1 bytes!&#34;)

        # resolve labels now!
        for adr, instr in self.instructions.items():
            self.logger.debug(f&#34;Checking label for {instr} at {adr:04X}&#34;)

            if instr.immediate and instr.immediate.name:
                self.logger.debug(
                    f&#34;-&gt; immediate label name: {instr.immediate.name}&#34;)

                if instr.immediate.name in self.labels:

                    val = self.labels[instr.immediate.name].value &amp; 0xff if not instr.immediate.high_byte else (
                        self.labels[instr.immediate.name].value &gt;&gt; 8) &amp; 0xff

                    instr.immediate.value = val
                    instr.immediate.name = self.labels[instr.immediate.name].name

                elif instr.immediate.name in g._PROGRAM.global_labels:
                    val = g._PROGRAM.global_labels[instr.immediate.name].value &amp; 0xff if not instr.immediate.high_byte else (
                        g._PROGRAM.global_labels[instr.immediate.name].value &gt;&gt; 8) &amp; 0xff

                    instr.immediate.value = val
                    instr.immediate.name = g._PROGRAM.global_labels[instr.immediate.name].name
                else:
                    raise ValueError(
                        f&#34;Label {label} cannot be resolved locally or globally!&#34;)

            elif instr.address and instr.address.name:
                self.logger.debug(
                    f&#34;-&gt; address label name: {instr.address.name}&#34;)
                if instr.address.name in self.labels:

                    if instr.mode == &#39;rel&#39;:
                        self.logger.debug(
                            f&#34;label address: {self.labels[instr.address.name].value}&#34;)
                        instr.address.value = self.labels[instr.address.name].value
                        if adr &lt; self.labels[instr.address.name].value:
                            instr.address.relative = self.labels[instr.address.name].value - adr - instr.get_size(
                            )
                        else:
                            instr.address.relative = adr - \
                                self.labels[instr.address.name].value - \
                                instr.get_size()

                        self.logger.debug(
                            f&#34;Use relative addressing to label {instr.address.name} at {self.labels[instr.address.name].value:04X} from {adr:04X}&#34;)
                    else:
                        instr.address.value = self.labels[instr.address.name].value
                        instr.address.name = self.labels[instr.address.name].name

                elif instr.address.name in g._PROGRAM.global_labels:
                    instr.address.value = g._PROGRAM.global_labels[instr.address.name].value
                    instr.address.name = g._PROGRAM.global_labels[instr.address.name].name
                else:
                    raise ValueError(
                        f&#34;Label {label} cannot be resolved locally or globally!&#34;)

                self.logger.debug(
                    f&#34;Label {instr.address.name} replaced by absolute address {instr.address.value:04X}&#34;)

    def gen_code(self, listing: bool = False) -&gt; None:
        &#34;&#34;&#34;Generates assembly code.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        self.resolve_labels()

        code = []

        # add globals import/export
        locals_labels = list(self.labels.keys())
        globals_labels = list(g._PROGRAM.global_labels.keys())

        for label in globals_labels:
            if label not in locals_labels:
                code.append(f&#39;\t\t{self.directive_prefix}import {label}\n&#39;)
            else:
                code.append(f&#39;\t\t{self.directive_prefix}export {label}\n&#39;)

        code.append(&#39;\n&#39;)

        # add segment directive
        code.append(f&#39;\t\t{self.directive_prefix}segment &#34;{self.name}&#34;\n&#39;)

        # get longest label

        if len(locals_labels) &gt; 0:
            label_size = max(10, len(max(locals_labels)) + 8)
        else:
            label_size = 10

        self.logger.debug(f&#34;Label size: {label_size}&#34;)

        if listing:

            self.logger.debug(&#34;Generating listing&#34;)
            listing_template_index = {
                &#34;address&#34;: 0,
                &#34;bytecode&#34;: 8 if self.show_address else 0,
                &#34;label&#34;: 40 if self.show_bytecode else 8 if self.show_address else 0,
                &#34;instruction&#34;: 40+label_size if self.show_bytecode else 8+label_size if self.show_address else label_size,
                &#34;cycles&#34;: 40+label_size+20 if self.show_bytecode else 38+label_size+20 if self.show_address else label_size+20,
            }

            remaining_bytes_to_process = 0
            for adr, instr in self.instructions.items():

                instr.show_labels = False

                if self.use_uppercase:
                    instr.use_upper = True
                if self.use_hex:
                    instr.use_hex = True

                label = [k for k, v in self.labels.items() if v.value == adr]

                # substract start address if relative addressing
                address_offset = self.start_adr if self.use_relative_addressing else 0

                if isinstance(instr, ByteData):
                    if remaining_bytes_to_process != 0:
                        remaining_bytes_to_process -= 1
                    else:
                        prefix = self.directive_prefix

                        nb_bytes = 0
                        nolabel = True
                        try:
                            while adr+nb_bytes in self.instructions and nolabel and isinstance(self.instructions[adr+nb_bytes], ByteData):
                                nb_bytes += 1
                                nolabel = len([k for k, v in self.labels.items() if v.value == adr+nb_bytes]) == 0
                        except KeyError:
                            self.logger.error(f&#34;Could not find address {adr+nb_bytes} (${adr+nb_bytes:04X}) in {self.instructions.keys()}&#34;)
                            raise


                        remaining_bytes_to_process = nb_bytes - 1
                        self.logger.debug(f&#34;{nb_bytes} bytes of data before instruction&#34;)
                        if nb_bytes &gt; 8:

                            # manage the remaining bytes if not a multiple of 8
                            nb_rows = nb_bytes // 8 + 1 if nb_bytes % 8 != 0 else nb_bytes // 8

                            for row in range(nb_rows):

                                r_label = [k for k, v in self.labels.items() if v.value == adr+(row*8)]
                                s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                                s_address = f&#34;{adr+(row*8)-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                                bcode = &#34;&#34;
                                for b in range(min(8, nb_bytes-(8*row))):
                                    bytedata = self.instructions[adr+(row*8)+b]
                                    g_bcode = self.get_bytecode(bytedata)
                                    bcode += str(binascii.hexlify(g_bcode)
                                                 )[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                                bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                                bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                                line = &#39; &#39;*100
                                if self.show_address:
                                    line = _insert(line, s_address, listing_template_index[&#34;address&#34;])
                                if self.show_bytecode:
                                    line = _insert(line, bcode1, listing_template_index[&#34;bytecode&#34;])

                                line = _insert(line, s_label, listing_template_index[&#34;label&#34;])
                                line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, listing_template_index[&#34;instruction&#34;])
                                line.strip()
                                line += &#39;\n&#39;

                                code.append(line)
                        else:
                            s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;

                            r_label = [k for k, v in self.labels.items() if v.value == adr]
                            s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                            bcode = &#34;&#34;
                            for b in range(nb_bytes):
                                bytedata = self.instructions[adr+b]
                                g_bcode = self.get_bytecode(bytedata)
                                bcode += str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                            bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                            bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                            line = &#39; &#39;*100
                            if self.show_address:
                                line = _insert(line, s_address, listing_template_index[&#34;address&#34;])
                            if self.show_bytecode:
                                line = _insert(line, bcode1, listing_template_index[&#34;bytecode&#34;])

                            line = _insert(line, s_label, listing_template_index[&#34;label&#34;])
                            line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, listing_template_index[&#34;instruction&#34;])
                            line.strip()
                            line += &#39;\n&#39;

                            code.append(line)
                else:
                    s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;

                    if len(label) &gt; 1:
                        self.logger.warning(f&#34;Mutiple labels ({label}) for the same address {adr:04X}&#34;)

                    s_label = f&#34;{label[0]}:&#34; if label else &#34;&#34;
                    g_bcode = self.get_bytecode(instr)

                    # remove leading &#39;b and trailing &#39;. Ex: bytearray(b&#39;\xa9\x0b&#39;) A90B
                    bcode = str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()
                    bcode = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                    s_bytecode = f&#34;{bcode}&#34; if self.show_bytecode else &#34;&#34;

                    cycles = instr.get_cycle_count()
                    bytes_used = instr.get_size()
                    s_cycles = f&#34;{self.comment_char} #{cycles} - {bytes_used}&#34; if self.show_cycles and cycles &gt; 0 else &#34;&#34;

                    prefix = self.directive_prefix if isinstance(instr, ByteData) else &#39;&#39;

                    line = &#39; &#39;*100
                    line = _insert(line, s_address, listing_template_index[&#34;address&#34;])
                    line = _insert(line, s_bytecode, listing_template_index[&#34;bytecode&#34;])
                    line = _insert(line, s_label, listing_template_index[&#34;label&#34;])
                    line = _insert(line, f&#34;{prefix}{instr}&#34;, listing_template_index[&#34;instruction&#34;])
                    line = _insert(line, s_cycles, listing_template_index[&#34;cycles&#34;])
                    line.strip()
                    line += &#39;\n&#39;

                    code.append(line)

        else:
            self.logger.debug(&#34;Generating assembly code&#34;)
            code_template_index = {
                &#34;label&#34;: 0,
                &#34;instruction&#34;: label_size,
                &#34;cycles&#34;: label_size+30,
            }

            remaining_bytes_to_process = 0
            for adr, instr in self.instructions.items():

                instr.show_labels = True

                if self.use_uppercase:
                    instr.use_upper = True
                if self.use_hex:
                    instr.use_hex = True

                label = [k for k, v in self.labels.items() if v.value == adr]

                # substract start address if relative addressing
                address_offset = self.start_adr if self.use_relative_addressing else 0

                if isinstance(instr, ByteData):
                    if remaining_bytes_to_process != 0:
                        remaining_bytes_to_process -= 1
                    else:
                        self.logger.debug(f&#34;Starting processing bytes at ${adr:04X}&#34;)
                        prefix = self.directive_prefix
                        nb_bytes = 0
                        nolabel = True
                        try:
                            while adr+nb_bytes in self.instructions and nolabel and isinstance(self.instructions[adr+nb_bytes], ByteData):
                                nb_bytes += 1
                                nolabel = len([k for k, v in self.labels.items() if v.value == adr+nb_bytes]) == 0
                        except KeyError:
                            self.logger.error(f&#34;Could not find address {adr+nb_bytes} (${adr+nb_bytes:04X}) in {self.instructions.keys()}&#34;)
                            raise

                        remaining_bytes_to_process = nb_bytes - 1
                        self.logger.debug(f&#34;{nb_bytes} bytes ({remaining_bytes_to_process}) of data before instruction&#34;)
                        if nb_bytes &gt; 8:

                            # manage the remaining bytes if not a multiple of 8
                            nb_rows = nb_bytes // 8 + 1 if nb_bytes % 8 != 0 else nb_bytes // 8

                            for row in range(nb_rows):

                                r_label = [k for k, v in self.labels.items() if v.value == adr+(row*8)]
                                self.logger.debug(f&#34;labels found at {adr+(row*8):04X} : {r_label}&#34;)
                                s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                                bcode = &#34;&#34;
                                for b in range(min(8, nb_bytes-(8*row))):
                                    bytedata = self.instructions[adr+(row*8)+b]
                                    g_bcode = self.get_bytecode(bytedata)
                                    bcode += str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                                bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                                line = &#39; &#39;*100
                                line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                                line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                                line.strip()
                                line += &#39;\n&#39;

                                code.append(line)
                        else:
                            r_label = [k for k, v in self.labels.items() if v.value == adr]
                            self.logger.debug(f&#34;labels found at {adr:04X} : {r_label}&#34;)
                            s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                            bcode = &#34;&#34;
                            for b in range(nb_bytes):
                                bytedata = self.instructions[adr+b]
                                g_bcode = self.get_bytecode(bytedata)
                                bcode += str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                            bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                            line = &#39; &#39;*100
                            line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                            line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                            line.strip()
                            line += &#39;\n&#39;

                            code.append(line)
                else:
                    if len(label) &gt; 1:
                        self.logger.warning(f&#34;Mutiple labels ({label}) for the same address {adr:04X}&#34;)
                        for i in range(len(label)-1):
                            s_label = f&#34;{label[i]}:&#34;
                            line = &#39; &#39;*100
                            line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                            line.strip()
                            line += &#39;\n&#39;
                            code.append(line)

                    s_label = f&#34;{label[-1]}:&#34; if label else &#34;&#34;
                    cycles = instr.get_cycle_count()
                    bytes_used = instr.get_size()
                    s_cycles = f&#34;{self.comment_char} #{cycles} - {bytes_used}&#34; if self.show_cycles and cycles &gt; 0 else &#34;&#34;


                    prefix = self.directive_prefix if isinstance(instr, ByteData) else &#39;&#39;

                    line = &#39; &#39;*100
                    line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                    line = _insert(line, f&#34;{prefix}{instr}&#34;, code_template_index[&#34;instruction&#34;])
                    line = _insert(line, s_cycles, code_template_index[&#34;cycles&#34;])
                    line.strip()
                    line += &#39;\n&#39;

                    code.append(line)

        return code

    def emulate(self, start_address: int = None):
        &#34;&#34;&#34;Emulates the code from start_address .

        Args:
            start_address (int, optional): [description]. Defaults to None.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        self.resolve_labels()

        if start_address is None:
            start_address = self.start_adr

        emu = Emu6502()
        ram = io.BytesIO(self.get_segment_bytecode())

        self.logger.info(
            f&#34;Emulating from {self.start_adr:04X}, to {self.next_position:04X} starting at {start_address:04X}&#34;)

        cpu_state, mmu_state, cycles_used = emu.load_and_run(ram, self.start_adr, self.next_position, start_address)

        return cpu_state, mmu_state, cycles_used

    def get_last_instruction(self) -&gt; Instruction:
        &#34;&#34;&#34;[summary]

        Returns:
            Instruction: [description]
        &#34;&#34;&#34;
        self.logger.debug(
            f&#34;Instructions in the current segment: {list(self.instructions.keys())}&#34;)
        return self.instructions[list(self.instructions.keys())[-1]]

    def get_stats(self):
        &#34;&#34;&#34;[summary]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if len(self.instructions) == 0:
            return Alias({
                &#34;start_address&#34;: hex(self.start_adr),
            })

        last_instr = self.get_last_instruction()
        return Alias({
            &#34;size&#34;: self.next_position - self.start_adr,
            &#34;cycles&#34;: self.total_cycles_used,
            &#34;instructions&#34;: len(self.instructions),
            &#34;start_address&#34;: hex(self.start_adr),
            &#34;current_address&#34;: hex(self.next_position),
            &#34;last_instruction&#34;: {
                &#34;code&#34;: str(last_instr),
                &#34;size&#34;: last_instr.get_size(),
                &#34;cycles&#34;: last_instr.get_cycle_count()
            }
        })

    def get_anonymous_label(self, prefix: str) -&gt; str:
        &#34;&#34;&#34;Generate an anonymous label, in a macro for example

        Args:
            prefix (str): [description]

        Returns:
            str: [description]
        &#34;&#34;&#34;
        if prefix not in self.anonymous_labels:
            self.anonymous_labels[prefix] = 0
        else:
            self.anonymous_labels[prefix] += 1

        return f&#34;_{prefix}_{self.anonymous_labels[prefix]}&#34;

    # def checksum(self) -&gt; int:
    #     return reduce(lambda x,y : hashlib.md5((x+y).encode()).hexdigest(), [item.hash() for item in self.instructions.values()])

    def add_rasterline(self, index: int, rasterline: Rasterline) -&gt; None:
        &#34;&#34;&#34;[summary]

        Args:
            index (int): [description]
            rasterline (Rasterline): [description]
        &#34;&#34;&#34;
        self.rasterlines[index] = rasterline</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="shazzam.Segment.Segment.comments_chars"><code class="name">var <span class="ident">comments_chars</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Segment.Segment.directive_prefix"><code class="name">var <span class="ident">directive_prefix</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="shazzam.Segment.Segment.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self.end_adr - self.start_adr</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="shazzam.Segment.Segment.add_byte"><code class="name flex">
<span>def <span class="ident">add_byte</span></span>(<span>self, immediate: <a title="shazzam.Immediate.Immediate" href="Immediate.html#shazzam.Immediate.Immediate">Immediate</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>immediate</code></strong> :&ensp;<code>Immediate</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_byte(self, immediate: Immediate) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        immediate (Immediate): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    data = ByteData(immediate)
    self.instructions[self.next_position] = data
    self.next_position += 1
    self.logger.debug(
        f&#34;added byte {immediate.value} at {self.next_position-1:04X}, next pos is not {self.next_position:04X}&#34;)

    return self.get_bytecode(data)</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.add_instruction"><code class="name flex">
<span>def <span class="ident">add_instruction</span></span>(<span>self, instr: <a title="shazzam.Instruction.Instruction" href="Instruction.html#shazzam.Instruction.Instruction">Instruction</a>) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instr</code></strong> :&ensp;<code>Instruction</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytearray</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_instruction(self, instr: Instruction) -&gt; bytearray:
    &#34;&#34;&#34;[summary]

    Args:
        instr (Instruction): [description]

    Returns:
        bytearray: [description]
    &#34;&#34;&#34;
    self.instructions[self.next_position] = instr
    self.next_position += instr.get_size()
    self.total_cycles_used += instr.get_cycle_count()
    instr.end_address = self.next_position

    # check size, relative addresses,...
    instr.check_constraints()

    if g._CURRENT_RASTER is not None:
        self.logger.debug(f&#34;Adding {instr} to rasterline&#34;)
        g._CURRENT_RASTER.add_cycles(instr.get_cycle_count())

    try:
        bcode = self.get_bytecode(instr)
        instr.bytecode = bcode
    except Exception as e:
        g.logger.debug(
            f&#34;bytecode cannot be generated yet, will be resolve later! [{e}]&#34;)

    return instr</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.add_label"><code class="name flex">
<span>def <span class="ident">add_label</span></span>(<span>self, name: str) ‑> <a title="shazzam.Address.Address" href="Address.html#shazzam.Address.Address">Address</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add segment label</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Address</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_label(self, name: str) -&gt; Address:
    &#34;&#34;&#34;Add segment label

    Args:
        name (str): [description]

    Raises:
        ValueError: [description]

    Returns:
        Address: [description]
    &#34;&#34;&#34;
    if name in self.labels:
        raise ValueError(
            f&#34;Label {name} already defined in segment at {self.labels[name]}&#34;)

    self.labels[name] = Address(name=name, value=self.next_position)

    return self.labels[name]</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.add_rasterline"><code class="name flex">
<span>def <span class="ident">add_rasterline</span></span>(<span>self, index: int, rasterline: <a title="shazzam.Rasterline.Rasterline" href="Rasterline.html#shazzam.Rasterline.Rasterline">Rasterline</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>rasterline</code></strong> :&ensp;<code>Rasterline</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_rasterline(self, index: int, rasterline: Rasterline) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        index (int): [description]
        rasterline (Rasterline): [description]
    &#34;&#34;&#34;
    self.rasterlines[index] = rasterline</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.change_format"><code class="name flex">
<span>def <span class="ident">change_format</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>change_format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_format(self):
    &#34;&#34;&#34;change_format&#34;&#34;&#34;
    code_format = g._CODE_FORMAT
    comments_format = g._COMMENTS_FORMAT
    directive_prefix = g._DIRECTIVE_PREFIX

    self.logger.debug(f&#34;Reset Prefs: {code_format} / {comments_format} / {directive_prefix}&#34;)

    self.show_address = True if CodeFormat.ADDRESS in code_format else False
    self.show_bytecode = True if CodeFormat.BYTECODE in code_format else False
    self.show_cycles = True if CodeFormat.CYCLES in code_format else False
    self.use_uppercase = True if CodeFormat.UPPERCASE in code_format else False
    self.use_hex = True if CodeFormat.USE_HEX in code_format else False
    self.show_labels = True if CodeFormat.SHOW_LABELS in code_format else False</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;[summary]&#34;&#34;&#34;
    self.end_adr = self.next_position</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.emulate"><code class="name flex">
<span>def <span class="ident">emulate</span></span>(<span>self, start_address: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Emulates the code from start_address .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_address</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emulate(self, start_address: int = None):
    &#34;&#34;&#34;Emulates the code from start_address .

    Args:
        start_address (int, optional): [description]. Defaults to None.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    self.resolve_labels()

    if start_address is None:
        start_address = self.start_adr

    emu = Emu6502()
    ram = io.BytesIO(self.get_segment_bytecode())

    self.logger.info(
        f&#34;Emulating from {self.start_adr:04X}, to {self.next_position:04X} starting at {start_address:04X}&#34;)

    cpu_state, mmu_state, cycles_used = emu.load_and_run(ram, self.start_adr, self.next_position, start_address)

    return cpu_state, mmu_state, cycles_used</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.gen_code"><code class="name flex">
<span>def <span class="ident">gen_code</span></span>(<span>self, listing: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Generates assembly code.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_code(self, listing: bool = False) -&gt; None:
    &#34;&#34;&#34;Generates assembly code.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    self.resolve_labels()

    code = []

    # add globals import/export
    locals_labels = list(self.labels.keys())
    globals_labels = list(g._PROGRAM.global_labels.keys())

    for label in globals_labels:
        if label not in locals_labels:
            code.append(f&#39;\t\t{self.directive_prefix}import {label}\n&#39;)
        else:
            code.append(f&#39;\t\t{self.directive_prefix}export {label}\n&#39;)

    code.append(&#39;\n&#39;)

    # add segment directive
    code.append(f&#39;\t\t{self.directive_prefix}segment &#34;{self.name}&#34;\n&#39;)

    # get longest label

    if len(locals_labels) &gt; 0:
        label_size = max(10, len(max(locals_labels)) + 8)
    else:
        label_size = 10

    self.logger.debug(f&#34;Label size: {label_size}&#34;)

    if listing:

        self.logger.debug(&#34;Generating listing&#34;)
        listing_template_index = {
            &#34;address&#34;: 0,
            &#34;bytecode&#34;: 8 if self.show_address else 0,
            &#34;label&#34;: 40 if self.show_bytecode else 8 if self.show_address else 0,
            &#34;instruction&#34;: 40+label_size if self.show_bytecode else 8+label_size if self.show_address else label_size,
            &#34;cycles&#34;: 40+label_size+20 if self.show_bytecode else 38+label_size+20 if self.show_address else label_size+20,
        }

        remaining_bytes_to_process = 0
        for adr, instr in self.instructions.items():

            instr.show_labels = False

            if self.use_uppercase:
                instr.use_upper = True
            if self.use_hex:
                instr.use_hex = True

            label = [k for k, v in self.labels.items() if v.value == adr]

            # substract start address if relative addressing
            address_offset = self.start_adr if self.use_relative_addressing else 0

            if isinstance(instr, ByteData):
                if remaining_bytes_to_process != 0:
                    remaining_bytes_to_process -= 1
                else:
                    prefix = self.directive_prefix

                    nb_bytes = 0
                    nolabel = True
                    try:
                        while adr+nb_bytes in self.instructions and nolabel and isinstance(self.instructions[adr+nb_bytes], ByteData):
                            nb_bytes += 1
                            nolabel = len([k for k, v in self.labels.items() if v.value == adr+nb_bytes]) == 0
                    except KeyError:
                        self.logger.error(f&#34;Could not find address {adr+nb_bytes} (${adr+nb_bytes:04X}) in {self.instructions.keys()}&#34;)
                        raise


                    remaining_bytes_to_process = nb_bytes - 1
                    self.logger.debug(f&#34;{nb_bytes} bytes of data before instruction&#34;)
                    if nb_bytes &gt; 8:

                        # manage the remaining bytes if not a multiple of 8
                        nb_rows = nb_bytes // 8 + 1 if nb_bytes % 8 != 0 else nb_bytes // 8

                        for row in range(nb_rows):

                            r_label = [k for k, v in self.labels.items() if v.value == adr+(row*8)]
                            s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                            s_address = f&#34;{adr+(row*8)-address_offset:04X}:&#34; if self.show_address else &#34;&#34;
                            bcode = &#34;&#34;
                            for b in range(min(8, nb_bytes-(8*row))):
                                bytedata = self.instructions[adr+(row*8)+b]
                                g_bcode = self.get_bytecode(bytedata)
                                bcode += str(binascii.hexlify(g_bcode)
                                             )[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                            bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                            bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                            line = &#39; &#39;*100
                            if self.show_address:
                                line = _insert(line, s_address, listing_template_index[&#34;address&#34;])
                            if self.show_bytecode:
                                line = _insert(line, bcode1, listing_template_index[&#34;bytecode&#34;])

                            line = _insert(line, s_label, listing_template_index[&#34;label&#34;])
                            line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, listing_template_index[&#34;instruction&#34;])
                            line.strip()
                            line += &#39;\n&#39;

                            code.append(line)
                    else:
                        s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;

                        r_label = [k for k, v in self.labels.items() if v.value == adr]
                        s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                        bcode = &#34;&#34;
                        for b in range(nb_bytes):
                            bytedata = self.instructions[adr+b]
                            g_bcode = self.get_bytecode(bytedata)
                            bcode += str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                        bcode1 = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))
                        bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                        line = &#39; &#39;*100
                        if self.show_address:
                            line = _insert(line, s_address, listing_template_index[&#34;address&#34;])
                        if self.show_bytecode:
                            line = _insert(line, bcode1, listing_template_index[&#34;bytecode&#34;])

                        line = _insert(line, s_label, listing_template_index[&#34;label&#34;])
                        line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, listing_template_index[&#34;instruction&#34;])
                        line.strip()
                        line += &#39;\n&#39;

                        code.append(line)
            else:
                s_address = f&#34;{adr-address_offset:04X}:&#34; if self.show_address else &#34;&#34;

                if len(label) &gt; 1:
                    self.logger.warning(f&#34;Mutiple labels ({label}) for the same address {adr:04X}&#34;)

                s_label = f&#34;{label[0]}:&#34; if label else &#34;&#34;
                g_bcode = self.get_bytecode(instr)

                # remove leading &#39;b and trailing &#39;. Ex: bytearray(b&#39;\xa9\x0b&#39;) A90B
                bcode = str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()
                bcode = &#34; &#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                s_bytecode = f&#34;{bcode}&#34; if self.show_bytecode else &#34;&#34;

                cycles = instr.get_cycle_count()
                bytes_used = instr.get_size()
                s_cycles = f&#34;{self.comment_char} #{cycles} - {bytes_used}&#34; if self.show_cycles and cycles &gt; 0 else &#34;&#34;

                prefix = self.directive_prefix if isinstance(instr, ByteData) else &#39;&#39;

                line = &#39; &#39;*100
                line = _insert(line, s_address, listing_template_index[&#34;address&#34;])
                line = _insert(line, s_bytecode, listing_template_index[&#34;bytecode&#34;])
                line = _insert(line, s_label, listing_template_index[&#34;label&#34;])
                line = _insert(line, f&#34;{prefix}{instr}&#34;, listing_template_index[&#34;instruction&#34;])
                line = _insert(line, s_cycles, listing_template_index[&#34;cycles&#34;])
                line.strip()
                line += &#39;\n&#39;

                code.append(line)

    else:
        self.logger.debug(&#34;Generating assembly code&#34;)
        code_template_index = {
            &#34;label&#34;: 0,
            &#34;instruction&#34;: label_size,
            &#34;cycles&#34;: label_size+30,
        }

        remaining_bytes_to_process = 0
        for adr, instr in self.instructions.items():

            instr.show_labels = True

            if self.use_uppercase:
                instr.use_upper = True
            if self.use_hex:
                instr.use_hex = True

            label = [k for k, v in self.labels.items() if v.value == adr]

            # substract start address if relative addressing
            address_offset = self.start_adr if self.use_relative_addressing else 0

            if isinstance(instr, ByteData):
                if remaining_bytes_to_process != 0:
                    remaining_bytes_to_process -= 1
                else:
                    self.logger.debug(f&#34;Starting processing bytes at ${adr:04X}&#34;)
                    prefix = self.directive_prefix
                    nb_bytes = 0
                    nolabel = True
                    try:
                        while adr+nb_bytes in self.instructions and nolabel and isinstance(self.instructions[adr+nb_bytes], ByteData):
                            nb_bytes += 1
                            nolabel = len([k for k, v in self.labels.items() if v.value == adr+nb_bytes]) == 0
                    except KeyError:
                        self.logger.error(f&#34;Could not find address {adr+nb_bytes} (${adr+nb_bytes:04X}) in {self.instructions.keys()}&#34;)
                        raise

                    remaining_bytes_to_process = nb_bytes - 1
                    self.logger.debug(f&#34;{nb_bytes} bytes ({remaining_bytes_to_process}) of data before instruction&#34;)
                    if nb_bytes &gt; 8:

                        # manage the remaining bytes if not a multiple of 8
                        nb_rows = nb_bytes // 8 + 1 if nb_bytes % 8 != 0 else nb_bytes // 8

                        for row in range(nb_rows):

                            r_label = [k for k, v in self.labels.items() if v.value == adr+(row*8)]
                            self.logger.debug(f&#34;labels found at {adr+(row*8):04X} : {r_label}&#34;)
                            s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                            bcode = &#34;&#34;
                            for b in range(min(8, nb_bytes-(8*row))):
                                bytedata = self.instructions[adr+(row*8)+b]
                                g_bcode = self.get_bytecode(bytedata)
                                bcode += str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                            bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                            line = &#39; &#39;*100
                            line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                            line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                            line.strip()
                            line += &#39;\n&#39;

                            code.append(line)
                    else:
                        r_label = [k for k, v in self.labels.items() if v.value == adr]
                        self.logger.debug(f&#34;labels found at {adr:04X} : {r_label}&#34;)
                        s_label = f&#34;{r_label[0]}:&#34; if r_label else &#34;&#34;

                        bcode = &#34;&#34;
                        for b in range(nb_bytes):
                            bytedata = self.instructions[adr+b]
                            g_bcode = self.get_bytecode(bytedata)
                            bcode += str(binascii.hexlify(g_bcode))[2:].replace(&#34;&#39;&#34;, &#34;&#34;).upper()

                        bcode2 = &#39;$&#39; + &#34;, $&#34;.join(bcode[i:i+2] for i in range(0, len(bcode), 2))

                        line = &#39; &#39;*100
                        line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                        line = _insert(line, f&#34;{prefix}byte {bcode2}&#34;, code_template_index[&#34;instruction&#34;])
                        line.strip()
                        line += &#39;\n&#39;

                        code.append(line)
            else:
                if len(label) &gt; 1:
                    self.logger.warning(f&#34;Mutiple labels ({label}) for the same address {adr:04X}&#34;)
                    for i in range(len(label)-1):
                        s_label = f&#34;{label[i]}:&#34;
                        line = &#39; &#39;*100
                        line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                        line.strip()
                        line += &#39;\n&#39;
                        code.append(line)

                s_label = f&#34;{label[-1]}:&#34; if label else &#34;&#34;
                cycles = instr.get_cycle_count()
                bytes_used = instr.get_size()
                s_cycles = f&#34;{self.comment_char} #{cycles} - {bytes_used}&#34; if self.show_cycles and cycles &gt; 0 else &#34;&#34;


                prefix = self.directive_prefix if isinstance(instr, ByteData) else &#39;&#39;

                line = &#39; &#39;*100
                line = _insert(line, s_label, code_template_index[&#34;label&#34;])
                line = _insert(line, f&#34;{prefix}{instr}&#34;, code_template_index[&#34;instruction&#34;])
                line = _insert(line, s_cycles, code_template_index[&#34;cycles&#34;])
                line.strip()
                line += &#39;\n&#39;

                code.append(line)

    return code</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_anonymous_label"><code class="name flex">
<span>def <span class="ident">get_anonymous_label</span></span>(<span>self, prefix: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an anonymous label, in a macro for example</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_anonymous_label(self, prefix: str) -&gt; str:
    &#34;&#34;&#34;Generate an anonymous label, in a macro for example

    Args:
        prefix (str): [description]

    Returns:
        str: [description]
    &#34;&#34;&#34;
    if prefix not in self.anonymous_labels:
        self.anonymous_labels[prefix] = 0
    else:
        self.anonymous_labels[prefix] += 1

    return f&#34;_{prefix}_{self.anonymous_labels[prefix]}&#34;</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_bytecode"><code class="name flex">
<span>def <span class="ident">get_bytecode</span></span>(<span>self, instr: <a title="shazzam.Instruction.Instruction" href="Instruction.html#shazzam.Instruction.Instruction">Instruction</a>) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instr</code></strong> :&ensp;<code>Instruction</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytearray</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bytecode(self, instr: Instruction) -&gt; bytearray:
    &#34;&#34;&#34;[summary]

    Args:
        instr (Instruction): [description]

    Returns:
        bytearray: [description]
    &#34;&#34;&#34;
    ope = instr.get_operand()
    op = instr.get_opcode()

    if ope is not None:
        if instr.get_size() == 2+1:
            self.logger.debug(
                f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:04X}&#34;)
            data = [op, ope &amp; 0xff, (ope &gt;&gt; 8) &amp; 0xff]
        else:
            self.logger.debug(
                f&#34;Get bytecode for {instr:}: opcode: {op:02X} operand: {ope:02X}&#34;)
            data = [op, ope &amp; 0xff]
    else:
        self.logger.debug(f&#34;Get bytecode for {instr:}: opcode: {op:02X}&#34;)
        data = [instr.get_opcode()]

    self.logger.debug(f&#34;Got bytecode for {instr}: {data}&#34;)

    return bytearray(data)</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_label"><code class="name flex">
<span>def <span class="ident">get_label</span></span>(<span>self, name: str) ‑> <a title="shazzam.Address.Address" href="Address.html#shazzam.Address.Address">Address</a></span>
</code></dt>
<dd>
<div class="desc"><p>get_label</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Address</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_label(self, name: str) -&gt; Address:
    &#34;&#34;&#34;get_label

    Args:
        name (str): [description]

    Raises:
        ValueError: [description]

    Returns:
        Address: [description]
    &#34;&#34;&#34;
    if name not in self.labels:
        self.logger.warning(f&#34;label &#39;{name}&#39; cannot be found in segment&#34;)
        raise ValueError(f&#34;Cannot find label &#39;{name}&#39; in segment&#34;)

    return self.labels[name]</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_last_instruction"><code class="name flex">
<span>def <span class="ident">get_last_instruction</span></span>(<span>self) ‑> <a title="shazzam.Instruction.Instruction" href="Instruction.html#shazzam.Instruction.Instruction">Instruction</a></span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Instruction</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_instruction(self) -&gt; Instruction:
    &#34;&#34;&#34;[summary]

    Returns:
        Instruction: [description]
    &#34;&#34;&#34;
    self.logger.debug(
        f&#34;Instructions in the current segment: {list(self.instructions.keys())}&#34;)
    return self.instructions[list(self.instructions.keys())[-1]]</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_segment_bytecode"><code class="name flex">
<span>def <span class="ident">get_segment_bytecode</span></span>(<span>self) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>get_segment_bytecode</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytearray</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_segment_bytecode(self) -&gt; bytearray:
    &#34;&#34;&#34;get_segment_bytecode

    Returns:
        bytearray: [description]
    &#34;&#34;&#34;
    self.resolve_labels()

    bytecode = bytearray([])
    for adr, instr in self.instructions.items():
        bcode = self.get_bytecode(instr)
        bytecode += bcode

    return bytecode</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.get_stats"><code class="name flex">
<span>def <span class="ident">get_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stats(self):
    &#34;&#34;&#34;[summary]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    if len(self.instructions) == 0:
        return Alias({
            &#34;start_address&#34;: hex(self.start_adr),
        })

    last_instr = self.get_last_instruction()
    return Alias({
        &#34;size&#34;: self.next_position - self.start_adr,
        &#34;cycles&#34;: self.total_cycles_used,
        &#34;instructions&#34;: len(self.instructions),
        &#34;start_address&#34;: hex(self.start_adr),
        &#34;current_address&#34;: hex(self.next_position),
        &#34;last_instruction&#34;: {
            &#34;code&#34;: str(last_instr),
            &#34;size&#34;: last_instr.get_size(),
            &#34;cycles&#34;: last_instr.get_cycle_count()
        }
    })</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.need_label"><code class="name flex">
<span>def <span class="ident">need_label</span></span>(<span>self, name: str, relative: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>relative</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def need_label(self, name: str, relative: bool = False) -&gt; None:
    &#34;&#34;&#34;[summary]

    Args:
        label (str): [description]
        relative (bool, optional): [description]. Defaults to False.
    &#34;&#34;&#34;
    self.required_labels[name] = {
        &#34;from&#34;: self.next_position,
        &#34;relative&#34;: relative
    }</code></pre>
</details>
</dd>
<dt id="shazzam.Segment.Segment.resolve_labels"><code class="name flex">
<span>def <span class="ident">resolve_labels</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Replace all instructions with their absolute address.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_labels(self) -&gt; None:
    &#34;&#34;&#34;Replace all instructions with their absolute address.

    Raises:
        ValueError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    # move end of segment labels
    for label, adr in self.labels.items():
        if adr.value == self.end_adr:
            adr.value = max(list(self.instructions.keys()))
            self.logger.info(f&#34;Label {label} moved to address ${adr.value:04X}&#34;)

    # check labels
    self.logger.debug(f&#34;Required labels: {self.required_labels}&#34;)
    for label, params in self.required_labels.items():

        if (label not in self.labels) and (label not in g._PROGRAM.global_labels):
            self.logger.debug(&#34;global labels:&#34;, g._PROGRAM.global_labels)
            raise ValueError(
                f&#34;Label {label} is used but not defined locally or globally!&#34;)

        if params[&#39;relative&#39;] and abs(params[&#39;from&#39;] - self.labels[label].address) &gt; 255:
            raise ValueError(
                f&#34;Label {label} branch at {params[&#39;from&#39;]} is more than 1 bytes!&#34;)

    # resolve labels now!
    for adr, instr in self.instructions.items():
        self.logger.debug(f&#34;Checking label for {instr} at {adr:04X}&#34;)

        if instr.immediate and instr.immediate.name:
            self.logger.debug(
                f&#34;-&gt; immediate label name: {instr.immediate.name}&#34;)

            if instr.immediate.name in self.labels:

                val = self.labels[instr.immediate.name].value &amp; 0xff if not instr.immediate.high_byte else (
                    self.labels[instr.immediate.name].value &gt;&gt; 8) &amp; 0xff

                instr.immediate.value = val
                instr.immediate.name = self.labels[instr.immediate.name].name

            elif instr.immediate.name in g._PROGRAM.global_labels:
                val = g._PROGRAM.global_labels[instr.immediate.name].value &amp; 0xff if not instr.immediate.high_byte else (
                    g._PROGRAM.global_labels[instr.immediate.name].value &gt;&gt; 8) &amp; 0xff

                instr.immediate.value = val
                instr.immediate.name = g._PROGRAM.global_labels[instr.immediate.name].name
            else:
                raise ValueError(
                    f&#34;Label {label} cannot be resolved locally or globally!&#34;)

        elif instr.address and instr.address.name:
            self.logger.debug(
                f&#34;-&gt; address label name: {instr.address.name}&#34;)
            if instr.address.name in self.labels:

                if instr.mode == &#39;rel&#39;:
                    self.logger.debug(
                        f&#34;label address: {self.labels[instr.address.name].value}&#34;)
                    instr.address.value = self.labels[instr.address.name].value
                    if adr &lt; self.labels[instr.address.name].value:
                        instr.address.relative = self.labels[instr.address.name].value - adr - instr.get_size(
                        )
                    else:
                        instr.address.relative = adr - \
                            self.labels[instr.address.name].value - \
                            instr.get_size()

                    self.logger.debug(
                        f&#34;Use relative addressing to label {instr.address.name} at {self.labels[instr.address.name].value:04X} from {adr:04X}&#34;)
                else:
                    instr.address.value = self.labels[instr.address.name].value
                    instr.address.name = self.labels[instr.address.name].name

            elif instr.address.name in g._PROGRAM.global_labels:
                instr.address.value = g._PROGRAM.global_labels[instr.address.name].value
                instr.address.name = g._PROGRAM.global_labels[instr.address.name].name
            else:
                raise ValueError(
                    f&#34;Label {label} cannot be resolved locally or globally!&#34;)

            self.logger.debug(
                f&#34;Label {instr.address.name} replaced by absolute address {instr.address.value:04X}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="shazzam.Segment.SegmentType"><code class="flex name class">
<span>class <span class="ident">SegmentType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegmentType(Enum):
    CODE = 0
    REGISTERS = 1
    SPRITE = 2
    CHARACTERS = 3
    SCREEN_MEM = 4
    BITMAP = 5
    GENERIC_DATA = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="shazzam.Segment.SegmentType.BITMAP"><code class="name">var <span class="ident">BITMAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Segment.SegmentType.CHARACTERS"><code class="name">var <span class="ident">CHARACTERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Segment.SegmentType.CODE"><code class="name">var <span class="ident">CODE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Segment.SegmentType.GENERIC_DATA"><code class="name">var <span class="ident">GENERIC_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Segment.SegmentType.REGISTERS"><code class="name">var <span class="ident">REGISTERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Segment.SegmentType.SCREEN_MEM"><code class="name">var <span class="ident">SCREEN_MEM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="shazzam.Segment.SegmentType.SPRITE"><code class="name">var <span class="ident">SPRITE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="shazzam" href="index.html">shazzam</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="shazzam.Segment.Segment" href="#shazzam.Segment.Segment">Segment</a></code></h4>
<ul class="">
<li><code><a title="shazzam.Segment.Segment.add_byte" href="#shazzam.Segment.Segment.add_byte">add_byte</a></code></li>
<li><code><a title="shazzam.Segment.Segment.add_instruction" href="#shazzam.Segment.Segment.add_instruction">add_instruction</a></code></li>
<li><code><a title="shazzam.Segment.Segment.add_label" href="#shazzam.Segment.Segment.add_label">add_label</a></code></li>
<li><code><a title="shazzam.Segment.Segment.add_rasterline" href="#shazzam.Segment.Segment.add_rasterline">add_rasterline</a></code></li>
<li><code><a title="shazzam.Segment.Segment.change_format" href="#shazzam.Segment.Segment.change_format">change_format</a></code></li>
<li><code><a title="shazzam.Segment.Segment.close" href="#shazzam.Segment.Segment.close">close</a></code></li>
<li><code><a title="shazzam.Segment.Segment.comments_chars" href="#shazzam.Segment.Segment.comments_chars">comments_chars</a></code></li>
<li><code><a title="shazzam.Segment.Segment.directive_prefix" href="#shazzam.Segment.Segment.directive_prefix">directive_prefix</a></code></li>
<li><code><a title="shazzam.Segment.Segment.emulate" href="#shazzam.Segment.Segment.emulate">emulate</a></code></li>
<li><code><a title="shazzam.Segment.Segment.gen_code" href="#shazzam.Segment.Segment.gen_code">gen_code</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_anonymous_label" href="#shazzam.Segment.Segment.get_anonymous_label">get_anonymous_label</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_bytecode" href="#shazzam.Segment.Segment.get_bytecode">get_bytecode</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_label" href="#shazzam.Segment.Segment.get_label">get_label</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_last_instruction" href="#shazzam.Segment.Segment.get_last_instruction">get_last_instruction</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_segment_bytecode" href="#shazzam.Segment.Segment.get_segment_bytecode">get_segment_bytecode</a></code></li>
<li><code><a title="shazzam.Segment.Segment.get_stats" href="#shazzam.Segment.Segment.get_stats">get_stats</a></code></li>
<li><code><a title="shazzam.Segment.Segment.need_label" href="#shazzam.Segment.Segment.need_label">need_label</a></code></li>
<li><code><a title="shazzam.Segment.Segment.resolve_labels" href="#shazzam.Segment.Segment.resolve_labels">resolve_labels</a></code></li>
<li><code><a title="shazzam.Segment.Segment.size" href="#shazzam.Segment.Segment.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="shazzam.Segment.SegmentType" href="#shazzam.Segment.SegmentType">SegmentType</a></code></h4>
<ul class="two-column">
<li><code><a title="shazzam.Segment.SegmentType.BITMAP" href="#shazzam.Segment.SegmentType.BITMAP">BITMAP</a></code></li>
<li><code><a title="shazzam.Segment.SegmentType.CHARACTERS" href="#shazzam.Segment.SegmentType.CHARACTERS">CHARACTERS</a></code></li>
<li><code><a title="shazzam.Segment.SegmentType.CODE" href="#shazzam.Segment.SegmentType.CODE">CODE</a></code></li>
<li><code><a title="shazzam.Segment.SegmentType.GENERIC_DATA" href="#shazzam.Segment.SegmentType.GENERIC_DATA">GENERIC_DATA</a></code></li>
<li><code><a title="shazzam.Segment.SegmentType.REGISTERS" href="#shazzam.Segment.SegmentType.REGISTERS">REGISTERS</a></code></li>
<li><code><a title="shazzam.Segment.SegmentType.SCREEN_MEM" href="#shazzam.Segment.SegmentType.SCREEN_MEM">SCREEN_MEM</a></code></li>
<li><code><a title="shazzam.Segment.SegmentType.SPRITE" href="#shazzam.Segment.SegmentType.SPRITE">SPRITE</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>